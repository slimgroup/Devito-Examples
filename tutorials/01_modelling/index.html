<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Mathias Louboutin" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Acoustic modeling - SLIM's Devito examples</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Acoustic modeling";
        var mkdocs_page_input_path = "tutorials/01_modelling.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> SLIM's Devito examples
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Acoustic modeling</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#modelling-workflow">Modelling workflow</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#the-acoustic-seismic-wave-equation">The acoustic seismic wave equation</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../accuracy/">Convergence analysis for the acoustic wave-equation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../02_rtm/">Acoustic RTM</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../03_fwi/">Acoustic FWI</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../04_dask/">Parallel acoustic FWI with Dask</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../05_staggered_acoustic/">First order acoustic modeling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../06_elastic/">Elastic modeling with constant parameters</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../06_elastic_varying_parameters/">Elastic modeling with varying parameters</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">The Leading Edge tutorials</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../TLE_Forward/">Forward modeling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../TLE_Adjoint/">Adjoint Modeling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../TLE_fwi/">FWI and algorithms</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">SLIM's Devito examples</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Tutorials</li>
      <li class="breadcrumb-item active">Acoustic modeling</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="01-introduction-to-seismic-modelling">01 - Introduction to seismic modelling</h1>
<p>This notebook is the first in a series of tutorials highlighting various aspects of seismic inversion based on Devito operators. In this first example we aim to highlight the core ideas behind seismic modelling, where we create a numerical model that captures the processes involved in a seismic survey. This forward model will then form the basis for further tutorials on the implementation of inversion processes using Devito operators.</p>
<h2 id="modelling-workflow">Modelling workflow</h2>
<p>The core process we are aiming to model is a seismic survey, which consists of two main components:</p>
<ul>
<li><strong>Source</strong> - A source is positioned at a single or a few physical locations where artificial pressure is injected into the domain we want to model. In the case of land survey, it is usually dynamite blowing up at a given location, or a vibroseis (a vibrating engine generating continuous sound waves). For a marine survey, the source is an air gun sending a bubble of compressed air into the water that will expand and generate a seismic wave.</li>
<li><strong>Receiver</strong> - A set of microphones or hydrophones are used to measure the resulting wave and create a set of measurements called a <em>Shot Record</em>. These measurements are recorded at multiple locations, and usually at the surface of the domain or at the bottom of the ocean in some marine cases.</li>
</ul>
<p>In order to create a numerical model of a seismic survey, we need to solve the wave equation and implement source and receiver interpolation to inject the source and record the seismic wave at sparse point locations in the grid.</p>
<p><img src='./survey-ship-diagram.png' width=400></p>
<h2 id="the-acoustic-seismic-wave-equation">The acoustic seismic wave equation</h2>
<p>The acoustic wave equation for the square slowness <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>, defined as <span class="arithmatex"><span class="MathJax_Preview">m=\frac{1}{c^2}</span><script type="math/tex">m=\frac{1}{c^2}</script></span>, where <span class="arithmatex"><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span> is the speed of sound in the given physical media, and a source <span class="arithmatex"><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> is given by:</p>
<div class="arithmatex">
<div class="MathJax_Preview">\begin{cases}
 &amp;m \frac{d^2 u(x,t)}{dt^2} - \nabla^2 u(x,t) = q \ \text{in } \Omega \\
 &amp;u(.,t=0) = 0 \\
 &amp;\frac{d u(x,t)}{dt}|_{t=0} = 0 
\end{cases}</div>
<script type="math/tex; mode=display">\begin{cases}
 &m \frac{d^2 u(x,t)}{dt^2} - \nabla^2 u(x,t) = q \ \text{in } \Omega \\
 &u(.,t=0) = 0 \\
 &\frac{d u(x,t)}{dt}|_{t=0} = 0 
\end{cases}</script>
</div>
<p>with the zero initial conditions to guarantee unicity of the solution.
The boundary conditions are Dirichlet conditions:
<script type="math/tex; mode=display">\begin{equation}
 u(x,t)|_\delta\Omega = 0
\end{equation}</script>
</p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\delta\Omega</span><script type="math/tex">\delta\Omega</script></span> is the surface of the boundary of the model <span class="arithmatex"><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span>.</p>
<h1 id="finite-domains">Finite domains</h1>
<p>The last piece of the puzzle is the computational limitation. In the field, the seismic wave propagates in every direction to an "infinite" distance. However, solving the wave equation in a mathematically/discrete infinite domain is not feasible. In order to compensate, Absorbing Boundary Conditions (ABC) or Perfectly Matched Layers (PML) are required to mimic an infinite domain. These two methods allow to approximate an infinite media by damping and absorbing the waves at the limit of the domain to avoid reflections.</p>
<p>The simplest of these methods is the absorbing damping mask. The core idea is to extend the physical domain and to add a Sponge mask in this extension that will absorb the incident waves. The acoustic wave equation with this damping mask can be rewritten as:</p>
<div class="arithmatex">
<div class="MathJax_Preview">\begin{cases} 
 &amp;m \frac{d^2 u(x,t)}{dt^2} - \nabla^2 u(x,t) + \eta \frac{d u(x,t)}{dt}=q  \ \text{in } \Omega \\
 &amp;u(.,0) = 0 \\
 &amp;\frac{d u(x,t)}{dt}|_{t=0} = 0 
\end{cases}</div>
<script type="math/tex; mode=display">\begin{cases} 
 &m \frac{d^2 u(x,t)}{dt^2} - \nabla^2 u(x,t) + \eta \frac{d u(x,t)}{dt}=q  \ \text{in } \Omega \\
 &u(.,0) = 0 \\
 &\frac{d u(x,t)}{dt}|_{t=0} = 0 
\end{cases}</script>
</div>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\eta</span><script type="math/tex">\eta</script></span> is the damping mask equal to <span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span> inside the physical domain and increasing inside the sponge layer. Multiple choice of profile can be chosen for <span class="arithmatex"><span class="MathJax_Preview">\eta</span><script type="math/tex">\eta</script></span> from linear to exponential.</p>
<h1 id="seismic-modelling-with-devito">Seismic modelling with devito</h1>
<p>We describe here a step by step setup of seismic modelling with Devito in a simple 2D case. We will create a physical model of our domain and define a single source and an according set of receivers to model for the forward model. But first, we initialize some basic utilities.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>
<span class="c1"># Adding ignore due to (probably an np notebook magic) bug</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</code></pre></div>
<h2 id="define-the-physical-problem">Define the physical problem</h2>
<p>The first step is to define the physical model:</p>
<ul>
<li>What are the physical dimensions of interest</li>
<li>What is the velocity profile of this physical domain</li>
</ul>
<p>We will create a simple velocity model here by hand for demonstration purposes. This model essentially consists of two layers, each with a different velocity: <span class="arithmatex"><span class="MathJax_Preview">1.5km/s</span><script type="math/tex">1.5km/s</script></span> in the top layer and <span class="arithmatex"><span class="MathJax_Preview">2.5km/s</span><script type="math/tex">2.5km/s</script></span> in the bottom layer. We will use this simple model a lot in the following tutorials, so we will rely on a utility function to create it again later.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">Model</span><span class="p">,</span> <span class="n">plot_velocity</span>

<span class="c1"># Define a physical size</span>
<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">101</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>  <span class="c1"># Number of grid point (nx, nz)</span>
<span class="n">spacing</span> <span class="o">=</span> <span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">)</span>  <span class="c1"># Grid spacing in m. The domain size is now 1km by 1km</span>
<span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>  <span class="c1"># What is the location of the top left corner. This is necessary to define</span>
<span class="c1"># the absolute location of the source and receivers</span>

<span class="c1"># Define a velocity profile. The velocity is in km/s</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">v</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">51</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">v</span><span class="p">[:,</span> <span class="mi">51</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">2.5</span>

<span class="c1"># With the velocity and model size defined, we can create the seismic model that</span>
<span class="c1"># encapsulates this properties. We also define the size of the absorbing layer as 10 grid points</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">vp</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span>
              <span class="n">space_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nbl</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="s2">&quot;damp&quot;</span><span class="p">)</span>

<span class="n">plot_velocity</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</code></pre></div>
<pre><code>Operator `initdamp` ran in 0.01 s
Operator `pad_vp` ran in 0.01 s
</code></pre>
<p><img alt="svg" src="../01_modelling_files/01_modelling_5_1.svg" /></p>
<h1 id="acquisition-geometry">Acquisition geometry</h1>
<p>To fully define our problem setup we also need to define the source that injects the wave to model and the set of receiver locations at which to sample the wavefield. The source time signature will be modelled using a Ricker wavelet defined as</p>
<div class="arithmatex">
<div class="MathJax_Preview">\begin{equation}
  q(t) = (1-2\pi^2 f_0^2 (t - \frac{1}{f_0})^2 )e^{- \pi^2 f_0^2 (t - \frac{1}{f_0})}
\end{equation}</div>
<script type="math/tex; mode=display">\begin{equation}
  q(t) = (1-2\pi^2 f_0^2 (t - \frac{1}{f_0})^2 )e^{- \pi^2 f_0^2 (t - \frac{1}{f_0})}
\end{equation}</script>
</div>
<p>To fully define the source signature we first need to define the time duration for our model and the timestep size, which is dictated by the CFL condition and our grid spacing. Luckily, our <code>Model</code> utility provides us with the critical timestep size, so we can fully discretize our model time axis as an array:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeAxis</span>

<span class="n">t0</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1"># Simulation starts a t=0</span>
<span class="n">tn</span> <span class="o">=</span> <span class="mf">1000.</span>  <span class="c1"># Simulation last 1 second (1000 ms)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">critical_dt</span>  <span class="c1"># Time step from model grid spacing</span>

<span class="n">time_range</span> <span class="o">=</span> <span class="n">TimeAxis</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">t0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">tn</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
</code></pre></div>
<p>The source is positioned at a <span class="arithmatex"><span class="MathJax_Preview">20m</span><script type="math/tex">20m</script></span> depth and at the middle of the <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> axis (<span class="arithmatex"><span class="MathJax_Preview">x_{src}=500m</span><script type="math/tex">x_{src}=500m</script></span>), with a peak wavelet frequency of <span class="arithmatex"><span class="MathJax_Preview">10Hz</span><script type="math/tex">10Hz</script></span>.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">RickerSource</span>

<span class="n">f0</span> <span class="o">=</span> <span class="mf">0.010</span>  <span class="c1"># Source peak frequency is 10Hz (0.010 kHz)</span>
<span class="n">src</span> <span class="o">=</span> <span class="n">RickerSource</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;src&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="n">f0</span><span class="p">,</span>
                   <span class="n">npoint</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_range</span><span class="o">=</span><span class="n">time_range</span><span class="p">)</span>

<span class="c1"># First, position source centrally in all dimensions, then set depth</span>
<span class="n">src</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">domain_size</span><span class="p">)</span> <span class="o">*</span> <span class="mf">.5</span>
<span class="n">src</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">20.</span>  <span class="c1"># Depth is 20m</span>

<span class="c1"># We can plot the time signature to see the wavelet</span>
<span class="n">src</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>
<p><img alt="svg" src="../01_modelling_files/01_modelling_9_0.svg" /></p>
<p>Similarly to our source object, we can now define our receiver geometry as a symbol of type <code>Receiver</code>. It is worth noting here that both utility classes, <code>RickerSource</code> and <code>Receiver</code> are thin wrappers around the Devito's <code>SparseTimeFunction</code> type, which encapsulates sparse point data and allows us to inject and interpolate values into and out of the computational grid. As we have already seen, both types provide a <code>.coordinates</code> property to define the position within the domain of all points encapsulated by that symbol. </p>
<p>In this example we will position receivers at the same depth as the source, every <span class="arithmatex"><span class="MathJax_Preview">10m</span><script type="math/tex">10m</script></span> along the x axis. The <code>rec.data</code> property will be initialized, but left empty, as we will compute the receiver readings during the simulation.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">Receiver</span>

<span class="c1"># Create symbol for 101 receivers</span>
<span class="n">rec</span> <span class="o">=</span> <span class="n">Receiver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;rec&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">npoint</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">time_range</span><span class="o">=</span><span class="n">time_range</span><span class="p">)</span>

<span class="c1"># Prescribe even spacing for receivers along the x-axis</span>
<span class="n">rec</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">domain_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="mi">101</span><span class="p">)</span>
<span class="n">rec</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">20.</span>  <span class="c1"># Depth is 20m</span>

<span class="c1"># We can now show the source and receivers within our domain:</span>
<span class="c1"># Red dot: Source location</span>
<span class="c1"># Green dots: Receiver locations (every 4th point)</span>
<span class="n">plot_velocity</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
              <span class="n">receiver</span><span class="o">=</span><span class="n">rec</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">data</span><span class="p">[::</span><span class="mi">4</span><span class="p">,</span> <span class="p">:])</span>
</code></pre></div>
<p><img alt="svg" src="../01_modelling_files/01_modelling_11_0.svg" /></p>
<h1 id="finite-difference-discretization">Finite-difference discretization</h1>
<p>Devito is a finite-difference DSL that solves the discretized wave-equation on a Cartesian grid. The finite-difference approximation is derived from Taylor expansions of the continuous field after removing the error term.</p>
<h2 id="time-discretization">Time discretization</h2>
<p>We only consider the second order time discretization for now. From the Taylor expansion, the second order discrete approximation of the second order time derivative is:
<script type="math/tex; mode=display">\begin{equation}
\begin{aligned}
 \frac{d^2 u(x,t)}{dt^2} = \frac{\mathbf{u}(\mathbf{x},\mathbf{t+\Delta t}) - 2 \mathbf{u}(\mathbf{x},\mathbf{t}) + \mathbf{u}(\mathbf{x},\mathbf{t-\Delta t})}{\mathbf{\Delta t}^2} + O(\mathbf{\Delta t}^2).
\end{aligned}
\end{equation}</script>
</p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}</span><script type="math/tex">\mathbf{u}</script></span> is the discrete wavefield, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Delta t}</span><script type="math/tex">\mathbf{\Delta t}</script></span> is the discrete
time-step (distance between two consecutive discrete time points) and <span class="arithmatex"><span class="MathJax_Preview">O(\mathbf{\Delta
  t}^2)</span><script type="math/tex">O(\mathbf{\Delta
  t}^2)</script></span> is the discretization error term. The discretized approximation of the
second order time derivative is then given by dropping the error term. This derivative is represented in Devito by <code>u.dt2</code> where u is a <code>TimeFunction</code> object.</p>
<h2 id="spatial-discretization">Spatial discretization</h2>
<p>We define the discrete Laplacian as the sum of the second order spatial
derivatives in the three dimensions:
<script type="math/tex; mode=display">\begin{equation}
\begin{aligned}
\Delta \mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t})= \sum_{j=1}^{j=\frac{k}{2}} \Bigg[\alpha_j \Bigg(&
\mathbf{u}(\mathbf{x+jdx},\mathbf{y},\mathbf{z},\mathbf{t})+\mathbf{u}(\mathbf{x-jdx},\mathbf{y},\mathbf{z},\mathbf{t}) + \\
&\mathbf{u}(\mathbf{x},\mathbf{y+jdy},\mathbf{z},\mathbf{t})+\mathbf{u}(\mathbf{x},\mathbf{y-jdy},\mathbf{z}\mathbf{t}) + \\
&\mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z+jdz},\mathbf{t})+\mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z-jdz},\mathbf{t})\Bigg) \Bigg] + \\
&3\alpha_0 \mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t}).
\end{aligned}
\end{equation}</script>
</p>
<p>This derivative is represented in Devito by <code>u.laplace</code> where u is a <code>TimeFunction</code> object.</p>
<h2 id="wave-equation">Wave equation</h2>
<p>With the space and time discretization defined, we can fully discretize the wave-equation with the combination of time and space discretizations and obtain the following second order in time and <span class="arithmatex"><span class="MathJax_Preview">k^{th}</span><script type="math/tex">k^{th}</script></span> order in space discrete stencil to update one grid point at position <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}, \mathbf{y},\mathbf{z}</span><script type="math/tex">\mathbf{x}, \mathbf{y},\mathbf{z}</script></span> at time <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>, i.e.
<script type="math/tex; mode=display">\begin{equation}
\begin{aligned}
\mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t+\Delta t}) = &2\mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t}) - \mathbf{u}(\mathbf{x},\mathbf{y}, \mathbf{z},\mathbf{t-\Delta t}) +\\
& \frac{\mathbf{\Delta t}^2}{\mathbf{m(\mathbf{x},\mathbf{y},\mathbf{z})}} \Big(\Delta \mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t}) + \mathbf{q}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t}) \Big). 
\end{aligned}
\end{equation}</script>
</p>
<div class="highlight"><pre><span></span><code><span class="c1"># In order to represent the wavefield u and the square slowness we need symbolic objects </span>
<span class="c1"># corresponding to time-space-varying field (u, TimeFunction) and </span>
<span class="c1"># space-varying field (m, Function)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">devito</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeFunction</span>

<span class="c1"># Define the wavefield with the size of the model and the time dimension</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">time_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># We can now write the PDE</span>
<span class="n">pde</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">dt2</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">laplace</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">damp</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">dt</span>

<span class="c1"># The PDE representation is as on paper</span>
<span class="n">pde</span>
</code></pre></div>
<p><span class="arithmatex"><span class="MathJax_Preview">\displaystyle \operatorname{damp}{\left(x,y \right)} \frac{\partial}{\partial t} u{\left(t,x,y \right)} - \frac{\partial^{2}}{\partial x^{2}} u{\left(t,x,y \right)} - \frac{\partial^{2}}{\partial y^{2}} u{\left(t,x,y \right)} + \frac{\frac{\partial^{2}}{\partial t^{2}} u{\left(t,x,y \right)}}{\operatorname{vp}^{2}{\left(x,y \right)}}</span><script type="math/tex">\displaystyle \operatorname{damp}{\left(x,y \right)} \frac{\partial}{\partial t} u{\left(t,x,y \right)} - \frac{\partial^{2}}{\partial x^{2}} u{\left(t,x,y \right)} - \frac{\partial^{2}}{\partial y^{2}} u{\left(t,x,y \right)} + \frac{\frac{\partial^{2}}{\partial t^{2}} u{\left(t,x,y \right)}}{\operatorname{vp}^{2}{\left(x,y \right)}}</script></span></p>
<div class="highlight"><pre><span></span><code><span class="c1"># This discrete PDE can be solved in a time-marching way updating u(t+dt) from the previous time step</span>
<span class="c1"># Devito as a shortcut for u(t+dt) which is u.forward. We can then rewrite the PDE as </span>
<span class="c1"># a time marching updating equation known as a stencil using customized SymPy functions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">devito</span><span class="w"> </span><span class="kn">import</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">solve</span>

<span class="n">stencil</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span> <span class="n">solve</span><span class="p">(</span><span class="n">pde</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">))</span>
<span class="n">stencil</span>
</code></pre></div>
<p><span class="arithmatex"><span class="MathJax_Preview">\displaystyle u{\left(t + dt,x,y \right)} = \frac{- \frac{- \frac{2.0 u{\left(t,x,y \right)}}{dt^{2}} + \frac{u{\left(t - dt,x,y \right)}}{dt^{2}}}{\operatorname{vp}^{2}{\left(x,y \right)}} + \frac{\partial^{2}}{\partial x^{2}} u{\left(t,x,y \right)} + \frac{\partial^{2}}{\partial y^{2}} u{\left(t,x,y \right)} + \frac{\operatorname{damp}{\left(x,y \right)} u{\left(t,x,y \right)}}{dt}}{\frac{\operatorname{damp}{\left(x,y \right)}}{dt} + \frac{1}{dt^{2} \operatorname{vp}^{2}{\left(x,y \right)}}}</span><script type="math/tex">\displaystyle u{\left(t + dt,x,y \right)} = \frac{- \frac{- \frac{2.0 u{\left(t,x,y \right)}}{dt^{2}} + \frac{u{\left(t - dt,x,y \right)}}{dt^{2}}}{\operatorname{vp}^{2}{\left(x,y \right)}} + \frac{\partial^{2}}{\partial x^{2}} u{\left(t,x,y \right)} + \frac{\partial^{2}}{\partial y^{2}} u{\left(t,x,y \right)} + \frac{\operatorname{damp}{\left(x,y \right)} u{\left(t,x,y \right)}}{dt}}{\frac{\operatorname{damp}{\left(x,y \right)}}{dt} + \frac{1}{dt^{2} \operatorname{vp}^{2}{\left(x,y \right)}}}</script></span></p>
<h1 id="source-injection-and-receiver-interpolation">Source injection and receiver interpolation</h1>
<p>With a numerical scheme to solve the homogenous wave equation, we need to add the source to introduce seismic waves and to implement the measurement operator, and interpolation operator. This operation is linked to the discrete scheme and needs to be done at the proper time step. The semi-discretized in time wave equation with a source reads:</p>
<div class="arithmatex">
<div class="MathJax_Preview">\begin{equation}
\begin{aligned}
\mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t+\Delta t}) = &amp;2\mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t}) - \mathbf{u}(\mathbf{x},\mathbf{y}, \mathbf{z},\mathbf{t-\Delta t}) +\\
&amp; \frac{\mathbf{\Delta t}^2}{\mathbf{m(\mathbf{x},\mathbf{y},\mathbf{z})}} \Big(\Delta \mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t}) + \mathbf{q}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t}) \Big). 
\end{aligned}
\end{equation}</div>
<script type="math/tex; mode=display">\begin{equation}
\begin{aligned}
\mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t+\Delta t}) = &2\mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t}) - \mathbf{u}(\mathbf{x},\mathbf{y}, \mathbf{z},\mathbf{t-\Delta t}) +\\
& \frac{\mathbf{\Delta t}^2}{\mathbf{m(\mathbf{x},\mathbf{y},\mathbf{z})}} \Big(\Delta \mathbf{u}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t}) + \mathbf{q}(\mathbf{x},\mathbf{y},\mathbf{z},\mathbf{t}) \Big). 
\end{aligned}
\end{equation}</script>
</div>
<p>It shows that in order to update <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}</span><script type="math/tex">\mathbf{u}</script></span> at time <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t+\Delta t}</span><script type="math/tex">\mathbf{t+\Delta t}</script></span> we have to inject the value of the source term <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span> of time <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>. In Devito, it corresponds the update of <span class="arithmatex"><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> at index <span class="arithmatex"><span class="MathJax_Preview">t+1</span><script type="math/tex">t+1</script></span> (t = time implicitly) with the source of time <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>.
On the receiver side, the problem is either as it only requires to record the data at the given time step <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> for the receiver at time <span class="arithmatex"><span class="MathJax_Preview">time=t</span><script type="math/tex">time=t</script></span>.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Finally we define the source injection and receiver read function to generate the corresponding code</span>
<span class="n">src_term</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">src</span> <span class="o">*</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">model</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>

<span class="c1"># Create interpolation expression for receivers</span>
<span class="n">rec_term</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
</code></pre></div>
<h1 id="devito-operator-and-solve">Devito operator and solve</h1>
<p>After constructing all the necessary expressions for updating the wavefield, injecting the source term and interpolating onto the receiver points, we can now create the Devito operator that will generate the C code at runtime. When creating the operator, Devito's two optimization engines will log which performance optimizations have been performed:
* <strong>DSE:</strong> The Devito Symbolics Engine will attempt to reduce the number of operations required by the kernel.
* <strong>DLE:</strong> The Devito Loop Engine will perform various loop-level optimizations to improve runtime performance.</p>
<p><strong>Note</strong>: The argument <code>subs=model.spacing_map</code> causes the operator to substitute values for our current grid spacing into the expressions before code generation. This reduces the number of floating point operations executed by the kernel by pre-evaluating certain coefficients.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">devito</span><span class="w"> </span><span class="kn">import</span> <span class="n">Operator</span>

<span class="n">op</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">([</span><span class="n">stencil</span><span class="p">]</span> <span class="o">+</span> <span class="n">src_term</span> <span class="o">+</span> <span class="n">rec_term</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">spacing_map</span><span class="p">)</span>
</code></pre></div>
<p>Now we can execute the create operator for a number of timesteps. We specify the number of timesteps to compute with the keyword <code>time</code> and the timestep size with <code>dt</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>
<span class="n">op</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">time_range</span><span class="o">.</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">critical_dt</span><span class="p">)</span>
</code></pre></div>
<pre><code>Operator `Kernel` ran in 0.01 s





PerformanceSummary([(PerfKey(name='section0', rank=None),
                     PerfEntry(time=0.004936999999999981, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])),
                    (PerfKey(name='section1', rank=None),
                     PerfEntry(time=2.600000000000001e-05, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])),
                    (PerfKey(name='section2', rank=None),
                     PerfEntry(time=0.0007560000000000057, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))])
</code></pre>
<p>After running our operator kernel, the data associated with the receiver symbol <code>rec.data</code> has now been populated due to the interpolation expression we inserted into the operator. This allows us the visualize the shot record:</p>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_shotrecord</span>

<span class="n">plot_shotrecord</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>
</code></pre></div>
<p><img alt="svg" src="../01_modelling_files/01_modelling_22_0.svg" /></p>
<div class="highlight"><pre><span></span><code><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="mi">370</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../.." class="btn btn-neutral float-left" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../accuracy/" class="btn btn-neutral float-right" title="Convergence analysis for the acoustic wave-equation">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright (c) 2020 SLIM group @ Georgia Institute of Technology.</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/mkdocs/mkdocs/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../.." style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../accuracy/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
