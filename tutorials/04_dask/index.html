<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Mathias Louboutin" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Parallel acoustic FWI with Dask - SLIM's Devito examples</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Parallel acoustic FWI with Dask";
        var mkdocs_page_input_path = "tutorials/04_dask.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> SLIM's Devito examples
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../01_modelling/">Acoustic modeling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../accuracy/">Convergence analysis for the acoustic wave-equation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../02_rtm/">Acoustic RTM</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../03_fwi/">Acoustic FWI</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Parallel acoustic FWI with Dask</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gpu-aware-dask">GPU Aware Dask</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#set-up-velocity-models">Set up velocity models</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#acquisition-geometry">Acquisition geometry</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#forward-modeling">Forward modeling</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#parallel-full-waveform-inversion">Parallel Full-Waveform Inversion</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#fwi-with-scipys-l-bfgs">FWI with SciPy's L-BFGS</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#next-steps">Next steps</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../05_staggered_acoustic/">First order acoustic modeling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../06_elastic/">Elastic modeling with constant parameters</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../06_elastic_varying_parameters/">Elastic modeling with varying parameters</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">The Leading Edge tutorials</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../TLE_Forward/">Forward modeling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../TLE_Adjoint/">Adjoint Modeling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../TLE_fwi/">FWI and algorithms</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">SLIM's Devito examples</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Tutorials</li>
      <li class="breadcrumb-item active">Parallel acoustic FWI with Dask</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="04-full-waveform-inversion-with-devito-and-dask">04 - Full Waveform Inversion with Devito and Dask</h1>
<h2 id="introduction">Introduction</h2>
<p>In this tutorial, we will build on the <a href="https://github.com/devitocodes/devito/blob/main/examples/seismic/tutorials/03_fwi.ipynb">previous</a> FWI tutorial and implement parallel versions of both forward modeling and FWI objective functions. Furthermore, we will show how our parallel FWI function can be passed to black-box third party optimization libraries, such as SciPy's <a href="https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html">optimize</a> package, to access sophisticated optimization algorithms without having to implement them from scratch!</p>
<p>To implement parallel versions of forward modeling and FWI, we will use <a href="https://dask.pydata.org/en/latest/#dask">Dask</a>, a Python library for distributed computing based on parallel data structures and task-based programming. As computing multiple seismic shot records or gradients for subsequent source locations is an embarassingly parallel process, we will use Dask to dynamically distribute our workload to a pool of available workers and afterwards collect the results.</p>
<p>The first part of this tutorial closely follows <a href="https://github.com/devitocodes/devito/blob/main/examples/seismic/tutorials/03_fwi.ipynb">tutorial 3</a> and consists of reading the velocity model and setting up the acquisition geometry. Subsequently, we will implement serial versions of forward modeling and FWI objective functions and then show how we can use Dask to implement parallel versions of these functions. Finally, we will show how to write a wrapper that lets us pass our objective function to scipy's optimize package and how to run a small 2D FWI example using a limited-memory Quasi-Newton method.</p>
<h2 id="gpu-aware-dask">GPU Aware Dask</h2>
<p>The default method to start a Dask Cluster is LocalCluster(...).  This method enables CPU worker threads, but it shares one GPU for all workers.  To enable Dask to use multi-GPU, or a GPU per Dask worker, the method to start a Dask Cluster needs to be changed to LocalCUDACluster.  This Dask modification is pulled from the Rapids.ai open source project.</p>
<p>Reference: <a href="https://github.com/rapidsai/dask-cuda">https://github.com/rapidsai/dask-cuda</a></p>
<div class="highlight"><pre><span></span><code><span class="n">USE_GPU_AWARE_DASK</span> <span class="o">=</span> <span class="kc">False</span>
</code></pre></div>
<h2 id="set-up-velocity-models">Set up velocity models</h2>
<p>As before, we start by reading the true (i.e. unknown) velocity model, as well as the starting model for FWI. For our example, we once again use the 2D Camembert model with a transmission acquisition set up, which involves having sources on one side of the model and receivers on the other side.</p>
<p>In reality, we obvisouly cannot know what the true velocity is, but here we use the true model to generate our own data (inverse crime alert!) and to compare it to our FWI result.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">demo_model</span>

<span class="c1"># Set up velocity model</span>
<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">101</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>      <span class="c1"># Number of grid points (nx, nz).</span>
<span class="n">spacing</span> <span class="o">=</span> <span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">)</span>    <span class="c1"># Grid spacing in m. The domain size is now 1km by 1km.</span>
<span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>         <span class="c1"># Need origin to define relative source and receiver locations.</span>
<span class="n">nbl</span> <span class="o">=</span> <span class="mi">40</span>

<span class="c1"># True model</span>
<span class="n">model1</span> <span class="o">=</span> <span class="n">demo_model</span><span class="p">(</span><span class="s1">&#39;circle-isotropic&#39;</span><span class="p">,</span> <span class="n">vp_circle</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">vp_background</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span>
    <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span> <span class="n">nbl</span><span class="o">=</span><span class="n">nbl</span><span class="p">)</span>

<span class="c1"># Initial model</span>
<span class="n">model0</span> <span class="o">=</span> <span class="n">demo_model</span><span class="p">(</span><span class="s1">&#39;circle-isotropic&#39;</span><span class="p">,</span> <span class="n">vp_circle</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">vp_background</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span>
    <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span> <span class="n">nbl</span><span class="o">=</span><span class="n">nbl</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">model1</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
</code></pre></div>
<pre><code>Operator `initdamp` run in 0.01 s
Operator `padfunc` run in 0.01 s
Operator `initdamp` run in 0.01 s
Operator `padfunc` run in 0.01 s
</code></pre>
<h2 id="acquisition-geometry">Acquisition geometry</h2>
<p>For the acquisition geometry, we use the same setup as in tutorial 3 and position 5 source position on one side of the model, and an array of 101 receivers on the other side. Note that now our source coordinate array (<code>src_coordinates</code>) is a 5 x 2 array, containing the shot locations of all 5 source experiments. After defining the source/receiver coordinates, we set up individual geometry objects for both the observed data (using <code>model</code>) and the predicted data (using <code>model0</code>).</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">AcquisitionGeometry</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Set up acquisiton geometry</span>
<span class="n">t0</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="n">tn</span> <span class="o">=</span> <span class="mf">1000.</span> 
<span class="n">f0</span> <span class="o">=</span> <span class="mf">0.010</span>

<span class="c1"># Set up source geometry, but define 5 sources instead of just one.</span>
<span class="n">nsources</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">src_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nsources</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">src_coordinates</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">model1</span><span class="o">.</span><span class="n">domain_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="n">nsources</span><span class="p">)</span>
<span class="n">src_coordinates</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">20.</span>  <span class="c1"># Source depth is 20m</span>

<span class="c1"># Initialize receivers for synthetic and imaging data</span>
<span class="n">nreceivers</span> <span class="o">=</span> <span class="mi">101</span>
<span class="n">rec_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nreceivers</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">rec_coordinates</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">model1</span><span class="o">.</span><span class="n">domain_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="n">nreceivers</span><span class="p">)</span>
<span class="n">rec_coordinates</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">980.</span>    <span class="c1"># Receiver depth</span>
<span class="c1"># Set up geometry objects for observed and predicted data</span>
<span class="n">geometry1</span> <span class="o">=</span> <span class="n">AcquisitionGeometry</span><span class="p">(</span><span class="n">model1</span><span class="p">,</span> <span class="n">rec_coordinates</span><span class="p">,</span> <span class="n">src_coordinates</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="n">f0</span><span class="p">,</span> <span class="n">src_type</span><span class="o">=</span><span class="s1">&#39;Ricker&#39;</span><span class="p">)</span>
<span class="n">geometry0</span> <span class="o">=</span> <span class="n">AcquisitionGeometry</span><span class="p">(</span><span class="n">model0</span><span class="p">,</span> <span class="n">rec_coordinates</span><span class="p">,</span> <span class="n">src_coordinates</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="n">f0</span><span class="p">,</span> <span class="n">src_type</span><span class="o">=</span><span class="s1">&#39;Ricker&#39;</span><span class="p">)</span>
</code></pre></div>
<h2 id="forward-modeling">Forward modeling</h2>
<p>Before diving into FWI, we will start with forward modeling and show how we can use Dask to implement a parallel wrapper around a serial modeling function to compute seismic shot records for multiple source locations in parallel.</p>
<p>First, we implement a forward modeling function for a single shot, which takes a geometry data structure as the only mandatory input argument. This function assumes that the geometry structure only contains a <em>single</em> source location. To solve the wave equation for the current shot location and model as specified in <code>geometry</code>, we use the <code>AcousticSolver</code> from previous tutorials, which is an abstract layer built on top of (generic) Devito objects. <code>AcousticSolver</code> contains Devito implementations of forward and adjoint wave equations, as well as Jacobians as specified in tutorials 1 and 2, so we don't have to re-implement these PDEs here.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic.acoustic</span><span class="w"> </span><span class="kn">import</span> <span class="n">AcousticWaveSolver</span>

<span class="c1"># Serial modeling function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">forward_modeling_single_shot</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">4.0</span><span class="p">):</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">AcousticWaveSolver</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">d_obs</span><span class="p">,</span> <span class="n">u0</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">vp</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">vp</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">d_obs</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">dt</span><span class="p">),</span> <span class="n">u0</span>
</code></pre></div>
<p>With our modeling function for a single shot record in place, we now implement our parallel version of our modeling function, which consists of a loop over all source locations. As the <code>geometry</code> object in <code>forward_modeling_single_shot</code> expects only a single source location, we set up a new geometry structure for the i-th source location to pass to our modeling function. However, rather than simpling calling the modeling function for single shots, we tell Dask to create a <em>task</em> for each source location and to distribute them to the available parallel workers. Dask returns a remote reference  to the result on each worker called <code>future</code>. The <code>wait</code> statement tells our function to wait for all tasks to finish their computations, after which we collect the modeled shot records from the workers.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Parallel modeling function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">forward_modeling_multi_shots</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">4.0</span><span class="p">):</span>

    <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsrc</span><span class="p">):</span>

        <span class="c1"># Geometry for current shot</span>
        <span class="n">geometry_i</span> <span class="o">=</span> <span class="n">AcquisitionGeometry</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">rec_positions</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">src_positions</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> 
            <span class="n">geometry</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">tn</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">f0</span><span class="p">,</span> <span class="n">src_type</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">src_type</span><span class="p">)</span>

        <span class="c1"># Call serial modeling function for each index</span>
        <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">forward_modeling_single_shot</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">geometry_i</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">))</span>

    <span class="c1"># Wait for all workers to finish and collect shots</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span>
    <span class="n">shots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsrc</span><span class="p">):</span>
        <span class="n">shots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">result</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">shots</span>
</code></pre></div>
<p>We can use this parallel modeling function to generate our own observed data set, which we will subsequently use for our FWI example. In reality, we would instead read our observed data from a SEG-Y file. To compute the data in parallel, we launch a pool of workers on our local machine and then call the parallel modeling function:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">distributed</span><span class="w"> </span><span class="kn">import</span> <span class="n">Client</span><span class="p">,</span> <span class="n">wait</span>

<span class="c1"># Start Dask cluster</span>
<span class="k">if</span> <span class="n">USE_GPU_AWARE_DASK</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">dask_cuda</span><span class="w"> </span><span class="kn">import</span> <span class="n">LocalCUDACluster</span>
    <span class="n">cluster</span> <span class="o">=</span> <span class="n">LocalCUDACluster</span><span class="p">(</span><span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">death_timeout</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span> 
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">distributed</span><span class="w"> </span><span class="kn">import</span> <span class="n">LocalCluster</span>
    <span class="n">cluster</span> <span class="o">=</span> <span class="n">LocalCluster</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="n">nsources</span><span class="p">,</span> <span class="n">death_timeout</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span>

<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>

<span class="c1"># Compute observed data in parallel (inverse crime). In real life we would read the SEG-Y data here.</span>
<span class="n">d_obs</span> <span class="o">=</span> <span class="n">forward_modeling_multi_shots</span><span class="p">(</span><span class="n">model1</span><span class="p">,</span> <span class="n">geometry1</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>
<p>The variable <code>d_obs</code> is a list of the 5 shots records and we can plot one of the shot records as follows:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_shotrecord</span>

<span class="c1"># Plot shot no. 3 of 5</span>
<span class="n">plot_shotrecord</span><span class="p">(</span><span class="n">d_obs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">model1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>
</code></pre></div>
<p><img alt="png" src="../04_dask_files/04_dask_20_0.png" /></p>
<h2 id="parallel-full-waveform-inversion">Parallel Full-Waveform Inversion</h2>
<p>Now that we know how to use Dask to implement a parallel loop around a (serial) modeling function for a single shot, we can apply the same concept to an FWI objective function, which computes the FWI function value and gradient for a given geometry and observed shot record. This function follows largely the structure in tutorial 3 and involves computing the predicted data and backpropagating the residual to compute the gradient. As we do not want to update the velocity in the area of the absorbing boundaries, we only return the gradient on the (original) physical grid.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">devito</span><span class="w"> </span><span class="kn">import</span> <span class="n">Function</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">Receiver</span>

<span class="c1"># Serial FWI objective function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fwi_objective_single_shot</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">d_obs</span><span class="p">):</span>

    <span class="c1"># Devito objects for gradient and data residual</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;grad&quot;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">residual</span> <span class="o">=</span> <span class="n">Receiver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;rec&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
                        <span class="n">time_range</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">time_axis</span><span class="p">,</span> 
                        <span class="n">coordinates</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">rec_positions</span><span class="p">)</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">AcousticWaveSolver</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Predicted data and residual</span>
    <span class="n">d_pred</span><span class="p">,</span> <span class="n">u0</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">vp</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">vp</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">residual</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">d_pred</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">-</span> <span class="n">d_obs</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[:][</span><span class="mi">0</span><span class="p">:</span><span class="n">d_pred</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>

    <span class="c1"># Function value and gradient    </span>
    <span class="n">fval</span> <span class="o">=</span> <span class="mf">.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residual</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">rec</span><span class="o">=</span><span class="n">residual</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u0</span><span class="p">,</span> <span class="n">vp</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">vp</span><span class="p">,</span> <span class="n">grad</span><span class="o">=</span><span class="n">grad</span><span class="p">)</span>

    <span class="c1"># Convert to numpy array and remove absorbing boundaries</span>
    <span class="n">grad_crop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">data</span><span class="p">[:])[</span><span class="n">model</span><span class="o">.</span><span class="n">nbl</span><span class="p">:</span><span class="o">-</span><span class="n">model</span><span class="o">.</span><span class="n">nbl</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">nbl</span><span class="p">:</span><span class="o">-</span><span class="n">model</span><span class="o">.</span><span class="n">nbl</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">fval</span><span class="p">,</span> <span class="n">grad_crop</span>
</code></pre></div>
<p>As for the serial modeling function, we can call <code>fwi_objective_single_shot</code> with a geometry structure containing a single source location and a single observed shot record. Since we are interested in evaluating this function for multiple sources in parallel, we follow the strategy from our forward modeling example and implement a parallel loop over all shots, in which we create a task for each shot location. As before, we use Dask to create one task per shot location and evaluate the single-shot FWI objective function for each source. We wait for all computations to finish via <code>wait(futures)</code> and then we sum the function values and gradients from all workers.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Parallel FWI objective function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fwi_objective_multi_shots</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">d_obs</span><span class="p">):</span>

    <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsrc</span><span class="p">):</span>

        <span class="c1"># Geometry for current shot</span>
        <span class="n">geometry_i</span> <span class="o">=</span> <span class="n">AcquisitionGeometry</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">rec_positions</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">src_positions</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> 
            <span class="n">geometry</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">tn</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">f0</span><span class="p">,</span> <span class="n">src_type</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">src_type</span><span class="p">)</span>

        <span class="c1"># Call serial FWI objective function for each shot location</span>
        <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">fwi_objective_single_shot</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">geometry_i</span><span class="p">,</span> <span class="n">d_obs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="c1"># Wait for all workers to finish and collect function values and gradients</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span>
    <span class="n">fval</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsrc</span><span class="p">):</span>
        <span class="n">fval</span> <span class="o">+=</span> <span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">result</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">grad</span> <span class="o">+=</span> <span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">result</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">fval</span><span class="p">,</span> <span class="n">grad</span>
</code></pre></div>
<p>We can compute a single gradient of the FWI objective function for all shots by passing the geometry structure with the initial model to the objective function, as well as the observed data we generated earlier.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Compute FWI gradient for 5 shots</span>
<span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">fwi_objective_multi_shots</span><span class="p">(</span><span class="n">model0</span><span class="p">,</span> <span class="n">geometry0</span><span class="p">,</span> <span class="n">d_obs</span><span class="p">)</span>
</code></pre></div>
<p>The physical units of the gradient are <span class="arithmatex"><span class="MathJax_Preview">s^2/km^2</span><script type="math/tex">s^2/km^2</script></span>, which means our gradient is an update of the squared slowness, rather than of the velocity.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_image</span>

<span class="c1"># Plot g</span>
<span class="n">plot_image</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model1</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">vmin</span><span class="o">=-</span><span class="mf">6e3</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">6e3</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;cividis&quot;</span><span class="p">)</span>
</code></pre></div>
<p><img alt="png" src="../04_dask_files/04_dask_29_0.png" /></p>
<h2 id="fwi-with-scipys-l-bfgs">FWI with SciPy's L-BFGS</h2>
<p>With our parallel FWI objective function in place, we can in principle implement a wide range of gradient-based optimization algorithms for FWI, such as (stochastic) gradient descent or the nonlinear conjugate gradient method. However, many optimization algorithms, especially second order methods or algorithms for constrained optimization, are far from trivial to implement correctly from scratch. Luckily, many optimization libraries exist that we can adapt for our purposes. </p>
<p>Here, we demonstrate how we can interface the scipy <em>optimize</em> package to run FWI with a limited-memory Quasi-Newton method. The scipy optimize package was not specifically designed for FWI, but this does not matter, as the library accepts any Python function that can be evaluated for a current model iterate <code>x</code> and returns the function value and gradient:</p>
<div class="highlight"><pre><span></span><code>f, g = objective_function(x, args)
</code></pre></div>
<p>where <code>f</code> is function value and <code>g</code> is a one-dimensional numpy array of type <code>float64</code>. Our parallel FWI function does not take the current model as an input argument, but instead expects a geometry structure and the observed data. Therefore, we have to write a little wrapper function called <code>loss</code>, which provides the input argument structure that is expected by <code>scipy.optimize</code>. The function takes the current model iteratve <code>x</code> (in squared slowness) as the first input argument and overwrites the current velocity in <code>geometry</code> with <code>x</code>. The gradient that is returned to <code>scipy.optimize</code> is converted to a numpy array of the required type (<code>float64</code>).</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Wrapper for scipy optimizer: x is current model in squared slowness [s^2/km^2]</span>
<span class="k">def</span><span class="w"> </span><span class="nf">loss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">d_obs</span><span class="p">):</span>

    <span class="c1"># Convert x to velocity</span>
    <span class="n">v_curr</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Overwrite current velocity in geometry (don&#39;t update boundary region)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s1">&#39;vp&#39;</span><span class="p">,</span> <span class="n">v_curr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Evaluate objective function </span>
    <span class="n">fval</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">fwi_objective_multi_shots</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">d_obs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fval</span><span class="p">,</span> <span class="n">grad</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>    <span class="c1"># scipy expects double precision vector</span>
</code></pre></div>
<p>The <code>scipy.optimize</code> function also takes an optional callback function as an input argument, which can be used to keep track of the model error as a function of the iteration number. The callback function takes the current model iterate <code>xk</code> as the only input argument and computes the <span class="arithmatex"><span class="MathJax_Preview">\ell_2</span><script type="math/tex">\ell_2</script></span>-misfit with the true model <code>m</code>:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Callback to track model error</span>
<span class="n">model_error</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fwi_callback</span><span class="p">(</span><span class="n">xk</span><span class="p">):</span>
    <span class="n">vp</span> <span class="o">=</span> <span class="n">model1</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">model1</span><span class="o">.</span><span class="n">nbl</span><span class="p">:</span><span class="o">-</span><span class="n">model1</span><span class="o">.</span><span class="n">nbl</span><span class="p">,</span> <span class="n">model1</span><span class="o">.</span><span class="n">nbl</span><span class="p">:</span><span class="o">-</span><span class="n">model1</span><span class="o">.</span><span class="n">nbl</span><span class="p">]</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">vp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">model_error</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">((</span><span class="n">xk</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span><span class="o">/</span><span class="n">m</span><span class="p">))</span>
</code></pre></div>
<p>The final preparation step before we can run our example, is the definition of box constraints for the velocity. At each iteration, the optimizer will project the current model iterate onto a feasible set of velocites as defined by the lower and upper bounds <code>vmin</code> and <code>vmax</code>. Box contraints allow us to prevent velocities from taking negative values or values that are too small or large for the stability criteria of our modeling stepping scheme. We define the box constraints for the velocity in <span class="arithmatex"><span class="MathJax_Preview">km/s</span><script type="math/tex">km/s</script></span> and then convert them to squared slownesses. Furthermore, we define our initial guess <code>m0</code>:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Box contraints</span>
<span class="n">vmin</span> <span class="o">=</span> <span class="mf">1.4</span>    <span class="c1"># do not allow velocities slower than water</span>
<span class="n">vmax</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">vmax</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">vmin</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">model0</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>    <span class="c1"># in [s^2/km^2]</span>

<span class="c1"># Initial guess</span>
<span class="n">v0</span> <span class="o">=</span> <span class="n">model0</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">model0</span><span class="o">.</span><span class="n">nbl</span><span class="p">:</span><span class="o">-</span><span class="n">model0</span><span class="o">.</span><span class="n">nbl</span><span class="p">,</span> <span class="n">model0</span><span class="o">.</span><span class="n">nbl</span><span class="p">:</span><span class="o">-</span><span class="n">model0</span><span class="o">.</span><span class="n">nbl</span><span class="p">]</span>
<span class="n">m0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
</code></pre></div>
<p>Finally, we run our 2D FWI example by calling the <code>optimize.minimize</code> function. The first input argument is the function to be minimized, which is our <code>loss</code> function. The second input argument is the starting value, which in our case is our initial model in squared slowness. The third input argument (<code>args</code>) are the arguments that are passed to the loss function other than <code>x</code>. For this example we use the L-BFGS algorithm, a limited-memory Quasi-Newton algorithm which builds up an approximation of the (inverse) hessian as we iterate. As our <code>loss</code> function returns the analytically computed gradient (as opposed to a numerically approximated gradient), we set the argument <code>jac=True</code>. Furthermore, we pass our callback function, box constraints and the maximum number of iterations (in this case 5) to the optimizer. </p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">optimize</span>

<span class="c1"># FWI with L-BFGS</span>
<span class="n">ftol</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">maxiter</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">m0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">model0</span><span class="p">,</span> <span class="n">geometry0</span><span class="p">,</span> <span class="n">d_obs</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
    <span class="n">callback</span><span class="o">=</span><span class="n">fwi_callback</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;ftol&#39;</span><span class="p">:</span><span class="n">ftol</span><span class="p">,</span> <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span><span class="n">maxiter</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">})</span>
</code></pre></div>
<pre><code>Operator `padfunc` run in 0.01 s
Operator `padfunc` run in 0.01 s
Operator `padfunc` run in 0.01 s
Operator `padfunc` run in 0.01 s
Operator `padfunc` run in 0.01 s
Operator `padfunc` run in 0.01 s
Operator `padfunc` run in 0.01 s
Operator `padfunc` run in 0.01 s
</code></pre>
<div class="highlight"><pre><span></span><code><span class="c1"># Check termination criteria</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">],</span> <span class="n">ftol</span><span class="p">)</span> <span class="ow">or</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;nit&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">maxiter</span>
</code></pre></div>
<p>After either the maximum iteration number is reached or we find the minimum of the objective function within some tolerance level <code>ftol</code>, the optimizer returns a dictionary with the results and some additional information. We convert the result back to the velocity in <span class="arithmatex"><span class="MathJax_Preview">km/s</span><script type="math/tex">km/s</script></span> and compare it to the true model:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Plot FWI result</span>
<span class="n">vp</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model1</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="n">plot_image</span><span class="p">(</span><span class="n">model1</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">model1</span><span class="o">.</span><span class="n">nbl</span><span class="p">:</span><span class="o">-</span><span class="n">model1</span><span class="o">.</span><span class="n">nbl</span><span class="p">,</span> <span class="n">model1</span><span class="o">.</span><span class="n">nbl</span><span class="p">:</span><span class="o">-</span><span class="n">model1</span><span class="o">.</span><span class="n">nbl</span><span class="p">],</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">2.4</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">2.8</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;cividis&quot;</span><span class="p">)</span>
<span class="n">plot_image</span><span class="p">(</span><span class="n">vp</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">2.4</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">2.8</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;cividis&quot;</span><span class="p">)</span>
</code></pre></div>
<p><img alt="png" src="../04_dask_files/04_dask_41_0.png" /></p>
<p><img alt="png" src="../04_dask_files/04_dask_41_1.png" /></p>
<p>Looking at the model error as a function of the iteration number, we find that the error decays monotonically, as we would expect.</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Plot model error</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">model_error</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Iteration number&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;L2-model error&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>
<p><img alt="png" src="../04_dask_files/04_dask_43_0.png" /></p>
<h2 id="next-steps">Next steps</h2>
<p>In our current example, the main process keeps all shot records in memory and distributes the data to the workers in the parallel pool. This works perfectly fine for 2D and even small 3D examples, but quickly becomes infeasible for large-scale data sets. Therefore, an extension of our current code should include the following steps if we want to scale things up in the future:</p>
<ul>
<li>
<p>Write shot records directly to disk on each worker and return a file pointer back to the main process.</p>
</li>
<li>
<p>Avoid sending the velocity model to the workers and read the model directly onto each worker.</p>
</li>
<li>
<p>Include optimal checkpointing or domain-decomposition to address the memory bottleneck in the gradient computations.</p>
</li>
</ul>
<p>For scaling Devito to industry-scale problems and being able to work on data sets in the range of multiple terabytes, it is furthermore necessary to have a fast SEG-Y reader that is able to scan through large data volumes and efficiently access blocks of data such as single shot records. Furthermore, we need the SEG-Y reader to be able to interact with Devito and automatically set up <code>geometry</code> objects from the SEG-Y headers. For this purpose, please check out the <a href="https://github.com/slimgroup/JUDI.jl">Julia Devito Inversion framework (JUDI)</a>, an extension built on top of Devito in the Julia programming language. JUDI consists on an abstract linear algebra framework and an interface to a fast and parallel SEG-Y reader called <a href="https://github.com/slimgroup/SegyIO.jl">SEGYIO.jl</a>, making it possible to:</p>
<ul>
<li>
<p>Scan large-scale data sets and create look-up tables from which shot records can be directly accessed through their byte locations (no need to loop over traces or read full files).</p>
</li>
<li>
<p>Use look-up tables to automatically set up Devito objects with source and receiver coordinates. </p>
</li>
<li>
<p>Work with out-of-core data containers that only read the data into memory when it is used for computations.</p>
</li>
</ul>
<p>You can find a full FWI example of the 3D Overthrust model using a 1.1 TB large data set on <a href="https://github.com/slimgroup/JUDI.jl/blob/master/examples/software_paper/examples/fwi_3D_overthrust_spg.jl">JUDI's Github page</a>.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../03_fwi/" class="btn btn-neutral float-left" title="Acoustic FWI"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../05_staggered_acoustic/" class="btn btn-neutral float-right" title="First order acoustic modeling">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright (c) 2020 SLIM group @ Georgia Institute of Technology.</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/mkdocs/mkdocs/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../03_fwi/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../05_staggered_acoustic/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
