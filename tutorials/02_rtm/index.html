<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Mathias Louboutin" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Acoustic RTM - SLIM's Devito examples</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Acoustic RTM";
        var mkdocs_page_input_path = "tutorials/02_rtm.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> SLIM's Devito examples
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../01_modelling/">Acoustic modeling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../accuracy/">Convergence analysis for the acoustic wave-equation</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Acoustic RTM</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#imaging-requirement">Imaging requirement</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#imaging-computational-setup">Imaging computational setup</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#notes-on-the-operators">Notes on the operators</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#computational-considerations">Computational considerations</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../03_fwi/">Acoustic FWI</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../04_dask/">Parallel acoustic FWI with Dask</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../05_staggered_acoustic/">First order acoustic modeling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../06_elastic/">Elastic modeling with constant parameters</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../07_elastic_varying_parameters.md">Elastic modeling with varying parameters</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">The Leading Edge tutorials</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../TLE_Forward/">Forward modeling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../TLE_Adjoint/">Adjoint Modeling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../TLE_fwi/">FWI and algorithms</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">SLIM's Devito examples</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Tutorials</li>
      <li class="breadcrumb-item active">Acoustic RTM</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="02-reverse-time-migration">02 - Reverse Time Migration</h1>
<p>This notebook is the second in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling operator and velocity model.</p>
<h2 id="imaging-requirement">Imaging requirement</h2>
<p>Seismic imaging relies on two known parameters:</p>
<ul>
<li>
<p><strong>Field data</strong> - or also called <strong>recorded data</strong>. This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will generate synthetic field data by modelling it with the <strong>true velocity model</strong>.</p>
</li>
<li>
<p><strong>Background velocity model</strong>. This is a velocity model that has been obtained by processing and inverting the field data. We will look at this methods in the following tutorial as it relies on the method we are describing here. This velocity model is usually a <strong>smooth version</strong> of the true velocity model.</p>
</li>
</ul>
<h2 id="imaging-computational-setup">Imaging computational setup</h2>
<p>In this tutorial, we will introduce the back-propagation operator. This operator simulates the adjoint wave-equation, that is a wave-equation solved in a reversed time order. This time reversal led to the naming of the method we present here, called Reverse Time Migration. The notion of adjoint in exploration geophysics is fundamental as most of the wave-equation based imaging and inversion methods rely on adjoint based optimization methods.</p>
<h2 id="notes-on-the-operators">Notes on the operators</h2>
<p>As we have already described the creation of a forward modelling operator, we will use a thin wrapper function instead. This wrapper is provided by a utility class called <code>AcousticWaveSolver</code>, which provides all the necessary operators for seismic modeling, imaging and inversion. The <code>AcousticWaveSolver</code> provides a more concise API for common wave propagation operators and caches the Devito <code>Operator</code> objects to avoid unnecessary recompilation. Operators introduced for the first time in this tutorial will be properly described.</p>
<p>As before we initialize printing and import some utilities. We also raise the Devito log level to avoid excessive logging for repeated operator invocations.</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">devito</span><span class="w"> </span><span class="kn">import</span> <span class="n">configuration</span>
<span class="n">configuration</span><span class="p">[</span><span class="s1">&#39;log-level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;WARNING&#39;</span>
</code></pre></div>
<h2 id="computational-considerations">Computational considerations</h2>
<p>Seismic inversion algorithms are generally very computationally demanding and require a large amount of memory to store the forward wavefield. In order to keep this tutorial as lightweight as possible we are using a very simple
velocity model that requires low temporal and spatial resolution. For a more realistic model, a second set of preset parameters for a reduced version of the 2D Marmousi data set [1] is provided below in comments. This can be run to create some more realistic subsurface images. However, this second preset is more computationally demanding and requires a slightly more powerful workstation.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Configure model presets</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">demo_model</span>

<span class="c1"># Enable model presets here:</span>
<span class="n">preset</span> <span class="o">=</span> <span class="s1">&#39;layers-isotropic&#39;</span>  <span class="c1"># A simple but cheap model (recommended)</span>
<span class="c1"># preset = &#39;marmousi2d-isotropic&#39;  # A larger more realistic model</span>

<span class="c1"># Standard preset with a simple two-layer model</span>
<span class="k">if</span> <span class="n">preset</span> <span class="o">==</span> <span class="s1">&#39;layers-isotropic&#39;</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_model</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">demo_model</span><span class="p">(</span><span class="s1">&#39;layers-isotropic&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">101</span><span class="p">,</span> <span class="mi">101</span><span class="p">),</span>
                          <span class="n">spacing</span><span class="o">=</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">),</span> <span class="n">nbl</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">nlayers</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">filter_sigma</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nshots</span> <span class="o">=</span> <span class="mi">21</span>
    <span class="n">nreceivers</span> <span class="o">=</span> <span class="mi">101</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">tn</span> <span class="o">=</span> <span class="mf">1000.</span>  <span class="c1"># Simulation last 1 second (1000 ms)</span>
    <span class="n">f0</span> <span class="o">=</span> <span class="mf">0.010</span>  <span class="c1"># Source peak frequency is 10Hz (0.010 kHz)</span>


<span class="c1"># A more computationally demanding preset based on the 2D Marmousi model</span>
<span class="k">if</span> <span class="n">preset</span> <span class="o">==</span> <span class="s1">&#39;marmousi2d-isotropic&#39;</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_model</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">demo_model</span><span class="p">(</span><span class="s1">&#39;marmousi2d-isotropic&#39;</span><span class="p">,</span> <span class="n">data_path</span><span class="o">=</span><span class="s1">&#39;../../../../data/&#39;</span><span class="p">,</span>
                          <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">nbl</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">filter_sigma</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">nshots</span> <span class="o">=</span> <span class="mi">301</span>  <span class="c1"># Need good covergae in shots, one every two grid points</span>
    <span class="n">nreceivers</span> <span class="o">=</span> <span class="mi">601</span>  <span class="c1"># One recevier every grid point</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">tn</span> <span class="o">=</span> <span class="mf">3500.</span>  <span class="c1"># Simulation last 3.5 second (3500 ms)</span>
    <span class="n">f0</span> <span class="o">=</span> <span class="mf">0.025</span>  <span class="c1"># Source peak frequency is 25Hz (0.025 kHz)</span>
</code></pre></div>
<h1 id="true-and-smooth-velocity-models">True and smooth velocity models</h1>
<p>First, we create the model data for the "true" model from a given demonstration preset. This model represents the subsurface topology for the purposes of this example and we will later use it to generate our synthetic data readings. We also generate a second model and apply a smoothing filter to it, which represents our initial model for the imaging algorithm. The perturbation between these two models can be thought of as the image we are trying to recover.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_velocity</span><span class="p">,</span> <span class="n">plot_perturbation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">devito</span><span class="w"> </span><span class="kn">import</span> <span class="n">gaussian_smooth</span>

<span class="c1"># Create true model from a preset</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">create_model</span><span class="p">()</span>

<span class="c1"># Create initial model and smooth the boundaries</span>
<span class="n">model0</span> <span class="o">=</span> <span class="n">create_model</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
<span class="n">gaussian_smooth</span><span class="p">(</span><span class="n">model0</span><span class="o">.</span><span class="n">vp</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">filter_sigma</span><span class="p">)</span>

<span class="c1"># Plot the true and initial model and the perturbation between them</span>
<span class="n">plot_velocity</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="n">plot_velocity</span><span class="p">(</span><span class="n">model0</span><span class="p">)</span>
<span class="n">plot_perturbation</span><span class="p">(</span><span class="n">model0</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
</code></pre></div>
<p><img alt="png" src="../02_rtm_files/02_rtm_6_0.png" /></p>
<p><img alt="png" src="../02_rtm_files/02_rtm_6_1.png" /></p>
<p><img alt="png" src="../02_rtm_files/02_rtm_6_2.png" /></p>
<h2 id="acquisition-geometry">Acquisition geometry</h2>
<p>Next we define the positioning and the wave signal of our source, as well as the location of our receivers. To generate the wavelet for our source we require the discretized values of time that we are going to use to model a single "shot",
which again depends on the grid spacing used in our model. For consistency this initial setup will look exactly as in the previous modelling tutorial, although we will vary the position of our source later on during the actual imaging algorithm.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>
<span class="c1"># Define acquisition geometry: source</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">AcquisitionGeometry</span>

<span class="c1"># First, position source centrally in all dimensions, then set depth</span>
<span class="n">src_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">src_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">domain_size</span><span class="p">)</span> <span class="o">*</span> <span class="mf">.5</span>
<span class="n">src_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">20.</span>  <span class="c1"># Depth is 20m</span>


<span class="c1"># Define acquisition geometry: receivers</span>

<span class="c1"># Initialize receivers for synthetic and imaging data</span>
<span class="n">rec_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nreceivers</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">rec_coordinates</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">domain_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="n">nreceivers</span><span class="p">)</span>
<span class="n">rec_coordinates</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">30.</span>

<span class="c1"># Geometry</span>

<span class="n">geometry</span> <span class="o">=</span> <span class="n">AcquisitionGeometry</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">rec_coordinates</span><span class="p">,</span> <span class="n">src_coordinates</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">.010</span><span class="p">,</span> <span class="n">src_type</span><span class="o">=</span><span class="s1">&#39;Ricker&#39;</span><span class="p">)</span>
<span class="c1"># We can plot the time signature to see the wavelet</span>
<span class="n">geometry</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>
<p><img alt="png" src="../02_rtm_files/02_rtm_8_0.png" /></p>
<h1 id="true-and-smooth-data">True and smooth data</h1>
<p>We can now generate the shot record (receiver readings) corresponding to our true and initial models. The difference between these two records will be the basis of the imaging procedure.</p>
<p>For this purpose we will use the same forward modelling operator that was introduced in the previous tutorial, provided by the <code>AcousticWaveSolver</code> utility class. This object instantiates a set of pre-defined operators according to an initial definition of the acquisition geometry, consisting of source and receiver symbols. The solver objects caches the individual operators and provides a slightly more high-level API that allows us to invoke the modelling modelling operators from the initial tutorial in a single line. In the following cells we use this to generate shot data by only specifying the respective model symbol <code>m</code> to use, and the solver will create and return a new <code>Receiver</code> object the represents the readings at the previously defined receiver coordinates.  </p>
<div class="highlight"><pre><span></span><code><span class="c1"># Compute synthetic data with forward operator </span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic.acoustic</span><span class="w"> </span><span class="kn">import</span> <span class="n">AcousticWaveSolver</span>

<span class="n">solver</span> <span class="o">=</span> <span class="n">AcousticWaveSolver</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">true_d</span> <span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">vp</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">vp</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># Compute initial data with forward operator </span>
<span class="n">smooth_d</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">vp</span><span class="o">=</span><span class="n">model0</span><span class="o">.</span><span class="n">vp</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>
<span class="c1"># Plot shot record for true and smooth velocity model and the difference</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_shotrecord</span>

<span class="n">plot_shotrecord</span><span class="p">(</span><span class="n">true_d</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>
<span class="n">plot_shotrecord</span><span class="p">(</span><span class="n">smooth_d</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>
<span class="n">plot_shotrecord</span><span class="p">(</span><span class="n">smooth_d</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">true_d</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>
</code></pre></div>
<p><img alt="png" src="../02_rtm_files/02_rtm_12_0.png" /></p>
<p><img alt="png" src="../02_rtm_files/02_rtm_12_1.png" /></p>
<p><img alt="png" src="../02_rtm_files/02_rtm_12_2.png" /></p>
<h1 id="imaging-with-back-propagation">Imaging with back-propagation</h1>
<p>As explained in the introduction of this tutorial, this method is based on back-propagation. </p>
<h2 id="adjoint-wave-equation">Adjoint wave equation</h2>
<p>If we go back to the modelling part, we can rewrite the simulation as a linear system solve:</p>
<div class="arithmatex">
<div class="MathJax_Preview">\begin{equation}
\mathbf{A}(\mathbf{m}) \mathbf{u} = \mathbf{q}
\end{equation}</div>
<script type="math/tex; mode=display">\begin{equation}
\mathbf{A}(\mathbf{m}) \mathbf{u} = \mathbf{q}
\end{equation}</script>
</div>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{m}</span><script type="math/tex">\mathbf{m}</script></span> is the discretized square slowness, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span> is the discretized source and <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}(\mathbf{m})</span><script type="math/tex">\mathbf{A}(\mathbf{m})</script></span> is the discretized wave-equation. The discretized wave-equation matricial representation is a lower triangular matrix that can be solve with forward substitution. The pointwise writing or the forward substitution leads to the time-stepping stencil.</p>
<p>On a small problem one could form the matrix explicitly and transpose it to obtain the adjoint discrete wave-equation:</p>
<div class="arithmatex">
<div class="MathJax_Preview">\begin{equation}
\mathbf{A}(\mathbf{m})^T \mathbf{v} = \delta \mathbf{d}
\end{equation}</div>
<script type="math/tex; mode=display">\begin{equation}
\mathbf{A}(\mathbf{m})^T \mathbf{v} = \delta \mathbf{d}
\end{equation}</script>
</div>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span> is the discrete <strong>adjoint wavefield</strong> and  <span class="arithmatex"><span class="MathJax_Preview">\delta \mathbf{d}</span><script type="math/tex">\delta \mathbf{d}</script></span> is the data residual defined as the difference between the field/observed data and the synthetic data <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_s = \mathbf{P}_r \mathbf{u}</span><script type="math/tex">\mathbf{d}_s = \mathbf{P}_r \mathbf{u}</script></span>. In our case we derive the discrete adjoint wave-equation from the discrete forward wave-equation to get its stencil. </p>
<h2 id="imaging">Imaging</h2>
<p>Wave-equation based imaging relies on one simple concept:</p>
<ul>
<li>If the background velocity model is cinematically correct, the forward wavefield <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}</span><script type="math/tex">\mathbf{u}</script></span> and the adjoint wavefield <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span> meet at the reflectors position at zero time offset. </li>
</ul>
<p>The sum over time of the zero time-offset correlation of these two fields then creates an image of the subsurface. Mathematically this leads to the simple imaging condition:</p>
<div class="arithmatex">
<div class="MathJax_Preview">\begin{equation}
  \text{Image} = \sum_{t=1}^{n_t} \mathbf{u}[t] \mathbf{v}[t]
\end{equation}</div>
<script type="math/tex; mode=display">\begin{equation}
  \text{Image} = \sum_{t=1}^{n_t} \mathbf{u}[t] \mathbf{v}[t]
\end{equation}</script>
</div>
<p>In the following tutorials we will describe a more advanced imaging condition that produces shaper and more accurate results.</p>
<h2 id="operator">Operator</h2>
<p>We will now define the imaging operator that computes the adjoint wavefield <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span> and correlates it with the forward wavefield <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}</span><script type="math/tex">\mathbf{u}</script></span>. This operator essentially consists of three components:
* Stencil update of the adjoint wavefield <code>v</code>
* Injection of the data residual at the adjoint source (forward receiver) location
* Correlation of <code>u</code> and <code>v</code> to compute the image contribution at each timestep</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Define gradient operator for imaging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">devito</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeFunction</span><span class="p">,</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">solve</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">PointSource</span>

<span class="k">def</span><span class="w"> </span><span class="nf">ImagingOperator</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
    <span class="c1"># Define the wavefield with the size of the model and the time dimension</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">time_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">time_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                     <span class="n">save</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">nt</span><span class="p">)</span>

    <span class="c1"># Define the wave equation, but with a negated damping term</span>
    <span class="n">eqn</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">dt2</span> <span class="o">-</span> <span class="n">v</span><span class="o">.</span><span class="n">laplace</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">damp</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Use `solve` to rearrange the equation into a stencil expression</span>
    <span class="n">stencil</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">backward</span><span class="p">,</span> <span class="n">solve</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">backward</span><span class="p">))</span>

    <span class="c1"># Define residual injection at the location of the forward receivers</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">critical_dt</span>
    <span class="n">residual</span> <span class="o">=</span> <span class="n">PointSource</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;residual&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
                           <span class="n">time_range</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">time_axis</span><span class="p">,</span>
                           <span class="n">coordinates</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">rec_positions</span><span class="p">)</span>    
    <span class="n">res_term</span> <span class="o">=</span> <span class="n">residual</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">backward</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">residual</span> <span class="o">*</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">model</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>

    <span class="c1"># Correlate u and v for the current time step and add it to the image</span>
    <span class="n">image_update</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span> <span class="o">-</span> <span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Operator</span><span class="p">([</span><span class="n">stencil</span><span class="p">]</span> <span class="o">+</span> <span class="n">res_term</span> <span class="o">+</span> <span class="p">[</span><span class="n">image_update</span><span class="p">],</span>
                    <span class="n">subs</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">spacing_map</span><span class="p">)</span>
</code></pre></div>
<h2 id="implementation-of-the-imaging-loop">Implementation of the imaging loop</h2>
<p>As just explained, the forward wave-equation is solved forward in time while the adjoint wave-equation is solved in a reversed time order. Therefore, the correlation of these two fields over time requires to store one of the two fields. The computational procedure for imaging follows:</p>
<ul>
<li>Simulate the forward wave-equation with the background velocity model to get the synthetic data and save the full wavefield <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}</span><script type="math/tex">\mathbf{u}</script></span></li>
<li>Compute the data residual</li>
<li>Back-propagate the data residual and compute on the fly the image contribution at each time step. </li>
</ul>
<p>This procedure is applied to multiple source positions (shots) and summed to obtain the full image of the subsurface. We can first visualize the varying locations of the sources that we will use. </p>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>

<span class="c1"># Prepare the varying source locations</span>
<span class="n">source_locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nshots</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">source_locations</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">nshots</span><span class="p">)</span>
<span class="n">source_locations</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">30.</span>

<span class="n">plot_velocity</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source_locations</span><span class="p">)</span>
</code></pre></div>
<p><img alt="png" src="../02_rtm_files/02_rtm_16_0.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1"># Run imaging loop over shots</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">devito</span><span class="w"> </span><span class="kn">import</span> <span class="n">Function</span>

<span class="c1"># Create image symbol and instantiate the previously defined imaging operator</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
<span class="n">op_imaging</span> <span class="o">=</span> <span class="n">ImagingOperator</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nshots</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Imaging source </span><span class="si">%d</span><span class="s1"> out of </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nshots</span><span class="p">))</span>

    <span class="c1"># Update source location</span>
    <span class="n">geometry</span><span class="o">.</span><span class="n">src_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">source_locations</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Generate synthetic data from true model</span>
    <span class="n">true_d</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">vp</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">vp</span><span class="p">)</span>

    <span class="c1"># Compute smooth data and full forward wavefield u0</span>
    <span class="n">smooth_d</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">vp</span><span class="o">=</span><span class="n">model0</span><span class="o">.</span><span class="n">vp</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Compute gradient from the data residual  </span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TimeFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">time_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">space_order</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">residual</span> <span class="o">=</span> <span class="n">smooth_d</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">true_d</span><span class="o">.</span><span class="n">data</span>
    <span class="n">op_imaging</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="n">u0</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">vp</span><span class="o">=</span><span class="n">model0</span><span class="o">.</span><span class="n">vp</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">model0</span><span class="o">.</span><span class="n">critical_dt</span><span class="p">,</span> 
               <span class="n">residual</span><span class="o">=</span><span class="n">residual</span><span class="p">)</span>
</code></pre></div>
<pre><code>Imaging source 1 out of 21
Imaging source 2 out of 21
Imaging source 3 out of 21
Imaging source 4 out of 21
Imaging source 5 out of 21
Imaging source 6 out of 21
Imaging source 7 out of 21
Imaging source 8 out of 21
Imaging source 9 out of 21
Imaging source 10 out of 21
Imaging source 11 out of 21
Imaging source 12 out of 21
Imaging source 13 out of 21
Imaging source 14 out of 21
Imaging source 15 out of 21
Imaging source 16 out of 21
Imaging source 17 out of 21
Imaging source 18 out of 21
Imaging source 19 out of 21
Imaging source 20 out of 21
Imaging source 21 out of 21
</code></pre>
<div class="highlight"><pre><span></span><code><span class="c1">#NBVAL_IGNORE_OUTPUT</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">examples.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_image</span>

<span class="c1"># Plot the inverted image</span>
<span class="n">plot_image</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div>
<p><img alt="png" src="../02_rtm_files/02_rtm_18_0.png" /></p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">devito</span><span class="w"> </span><span class="kn">import</span> <span class="n">norm</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="mf">1e7</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e1</span><span class="p">)</span>
</code></pre></div>
<p>And we have an image of the subsurface with a strong reflector at the original location.</p>
<h2 id="references">References</h2>
<p>[1] <em>Versteeg, R.J. &amp; Grau, G. (eds.) (1991): The Marmousi experience. Proc. EAGE workshop on Practical Aspects of Seismic Data Inversion (Copenhagen, 1990), Eur. Assoc. Explor. Geophysicists, Zeist.</em></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../accuracy/" class="btn btn-neutral float-left" title="Convergence analysis for the acoustic wave-equation"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../03_fwi/" class="btn btn-neutral float-right" title="Acoustic FWI">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright (c) 2020 SLIM group @ Georgia Institute of Technology.</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/mkdocs/mkdocs/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../accuracy/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../03_fwi/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
