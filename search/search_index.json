{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Devito-Examples This repository contains a set of examples and tutorials for seismic modeling and inversion using Devito . These examples use four different wave equations, namely The acoustic isotropic wave equation in seismic/acoustic The TTI pseudo-acoustic wave equation in seismic/tti The elastic isotropic wave equation in seismic/elastic The viscoelastic isotropic wave equation in seismic/elastic Currently, the acoustic isotropic wave equation solver also contains the propagator associated with the adjoint and linearized (Born) wave-equation solution and the gradient of the FWI objective (application of the Jacobian to data residual) Disclaimer The majority of these examples can also be found in the Devito examples directory, which is a fork of this repository. These examples for seismic applications have been developed and implemented by Mathias Louboutin at the Georgia Institute of Technology. For additional introductory examples, including tutorials on the Devito compiler, we refer to the Devito example directory on github since these were developed primarily by people from the Devito team at Imperial College London. The contributions by Mathias Louboutin were made as part of actvities at the Georgia Tech's Seismic Laboratory for Imaging and modeling ([SLIM). Installation To install this set of examples with its dependencies run in your terminal (OSX, Ubuntu): git clone https://github.com/slimgroup/Devito-Examples cd Devito-Examples pip install -e . This command will install all dependencies including Devito and will allow you to run the examples. To verify your installation you can run: python seismic/acoustic/acoustic_example.py -nd 1 Some of the examples require velocity models such as the marmousi-ii model. These models can be downloaded at devito-data to be used in the tutorials. How to navigate this directory Examples and tutorials are provided in the form of single Python files and as Jupyter notebooks.Jupyter notebooks are files with extension .ipynb . To execute these, run jupyter notebook , and then click on the desired notebook in the window that pops up in your browser. The seismic examples and tutorials are organized as follows: seismic/tutorials : A series of Jupyter notebooks of incremental complexity, showing a variety of Devito features in the context of seismic inversion operators. Among the discussed features are modeling, adjoint modeling, computing a gradient and a seismic image, FWI and elastic modeling on a staggered grid. seismic/acoustic : Example implementations of isotropic acoustic forward, adjoint, gradient and born operators, suitable for full-waveform inversion methods (FWI). seismic/tti : Example implementations of several anisotropic acoustic forward operators (TTI). seismic/elastic : Example implementation of an isotropic elastic forward operator. elastic , unlike acoustic and tti , fully exploits the tensorial nature of the Devito symbolic language. seismic/viscoelastic : Example implementation of an isotropic viscoelastic forward operator. Like elastic , viscoelastic exploits tensor functions for a neat and compact representation of the discretized partial differential equations. Related literature Some of these examples are described in the following papers: Devito's symbolic API for a description of the Devito API and symbolic capabilities. TTI imaging for small overview of imging in a TTI media (SEG abstract). Mathias Louboutin's thesis for Mathias Louboutin 's Thesis. More advanced geophysical application can be found in the JUDI repository. JUDI is a linear algebra DSL built on top of Devito for large scale inverse problems and includes abstractions for source/receivers and handles large SEG-Y datasets with SegyIO . A complete description of JUDI and the related seismic inversion application can be found in Philipp Witte's thesis .","title":"Home"},{"location":"#devito-examples","text":"This repository contains a set of examples and tutorials for seismic modeling and inversion using Devito . These examples use four different wave equations, namely The acoustic isotropic wave equation in seismic/acoustic The TTI pseudo-acoustic wave equation in seismic/tti The elastic isotropic wave equation in seismic/elastic The viscoelastic isotropic wave equation in seismic/elastic Currently, the acoustic isotropic wave equation solver also contains the propagator associated with the adjoint and linearized (Born) wave-equation solution and the gradient of the FWI objective (application of the Jacobian to data residual)","title":"Devito-Examples"},{"location":"#disclaimer","text":"The majority of these examples can also be found in the Devito examples directory, which is a fork of this repository. These examples for seismic applications have been developed and implemented by Mathias Louboutin at the Georgia Institute of Technology. For additional introductory examples, including tutorials on the Devito compiler, we refer to the Devito example directory on github since these were developed primarily by people from the Devito team at Imperial College London. The contributions by Mathias Louboutin were made as part of actvities at the Georgia Tech's Seismic Laboratory for Imaging and modeling ([SLIM).","title":"Disclaimer"},{"location":"#installation","text":"To install this set of examples with its dependencies run in your terminal (OSX, Ubuntu): git clone https://github.com/slimgroup/Devito-Examples cd Devito-Examples pip install -e . This command will install all dependencies including Devito and will allow you to run the examples. To verify your installation you can run: python seismic/acoustic/acoustic_example.py -nd 1 Some of the examples require velocity models such as the marmousi-ii model. These models can be downloaded at devito-data to be used in the tutorials.","title":"Installation"},{"location":"#how-to-navigate-this-directory","text":"Examples and tutorials are provided in the form of single Python files and as Jupyter notebooks.Jupyter notebooks are files with extension .ipynb . To execute these, run jupyter notebook , and then click on the desired notebook in the window that pops up in your browser. The seismic examples and tutorials are organized as follows: seismic/tutorials : A series of Jupyter notebooks of incremental complexity, showing a variety of Devito features in the context of seismic inversion operators. Among the discussed features are modeling, adjoint modeling, computing a gradient and a seismic image, FWI and elastic modeling on a staggered grid. seismic/acoustic : Example implementations of isotropic acoustic forward, adjoint, gradient and born operators, suitable for full-waveform inversion methods (FWI). seismic/tti : Example implementations of several anisotropic acoustic forward operators (TTI). seismic/elastic : Example implementation of an isotropic elastic forward operator. elastic , unlike acoustic and tti , fully exploits the tensorial nature of the Devito symbolic language. seismic/viscoelastic : Example implementation of an isotropic viscoelastic forward operator. Like elastic , viscoelastic exploits tensor functions for a neat and compact representation of the discretized partial differential equations.","title":"How to navigate this directory"},{"location":"#related-literature","text":"Some of these examples are described in the following papers: Devito's symbolic API for a description of the Devito API and symbolic capabilities. TTI imaging for small overview of imging in a TTI media (SEG abstract). Mathias Louboutin's thesis for Mathias Louboutin 's Thesis. More advanced geophysical application can be found in the JUDI repository. JUDI is a linear algebra DSL built on top of Devito for large scale inverse problems and includes abstractions for source/receivers and handles large SEG-Y datasets with SegyIO . A complete description of JUDI and the related seismic inversion application can be found in Philipp Witte's thesis .","title":"Related literature"},{"location":"tutorials/01_modelling/","text":"01 - Introduction to seismic modelling This notebook is the first in a series of tutorials highlighting various aspects of seismic inversion based on Devito operators. In this first example we aim to highlight the core ideas behind seismic modelling, where we create a numerical model that captures the processes involved in a seismic survey. This forward model will then form the basis for further tutorials on the implementation of inversion processes using Devito operators. Modelling workflow The core process we are aiming to model is a seismic survey, which consists of two main components: Source - A source is positioned at a single or a few physical locations where artificial pressure is injected into the domain we want to model. In the case of land survey, it is usually dynamite blowing up at a given location, or a vibroseis (a vibrating engine generating continuous sound waves). For a marine survey, the source is an air gun sending a bubble of compressed air into the water that will expand and generate a seismic wave. Receiver - A set of microphones or hydrophones are used to measure the resulting wave and create a set of measurements called a Shot Record . These measurements are recorded at multiple locations, and usually at the surface of the domain or at the bottom of the ocean in some marine cases. In order to create a numerical model of a seismic survey, we need to solve the wave equation and implement source and receiver interpolation to inject the source and record the seismic wave at sparse point locations in the grid. The acoustic seismic wave equation The acoustic wave equation for the square slowness m m , defined as m=\\frac{1}{c^2} m=\\frac{1}{c^2} , where c c is the speed of sound in the given physical media, and a source q q is given by: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} with the zero initial conditions to guarantee unicity of the solution. The boundary conditions are Dirichlet conditions: \\begin{equation} u(x,t)|_\\delta\\Omega = 0 \\end{equation} where \\delta\\Omega \\delta\\Omega is the surface of the boundary of the model \\Omega \\Omega . Finite domains The last piece of the puzzle is the computational limitation. In the field, the seismic wave propagates in every direction to an \"infinite\" distance. However, solving the wave equation in a mathematically/discrete infinite domain is not feasible. In order to compensate, Absorbing Boundary Conditions (ABC) or Perfectly Matched Layers (PML) are required to mimic an infinite domain. These two methods allow to approximate an infinite media by damping and absorbing the waves at the limit of the domain to avoid reflections. The simplest of these methods is the absorbing damping mask. The core idea is to extend the physical domain and to add a Sponge mask in this extension that will absorb the incident waves. The acoustic wave equation with this damping mask can be rewritten as: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} where \\eta \\eta is the damping mask equal to 0 0 inside the physical domain and increasing inside the sponge layer. Multiple choice of profile can be chosen for \\eta \\eta from linear to exponential. Seismic modelling with devito We describe here a step by step setup of seismic modelling with Devito in a simple 2D case. We will create a physical model of our domain and define a single source and an according set of receivers to model for the forward model. But first, we initialize some basic utilities. #NBVAL_IGNORE_OUTPUT # Adding ignore due to (probably an np notebook magic) bug import numpy as np % matplotlib inline Define the physical problem The first step is to define the physical model: What are the physical dimensions of interest What is the velocity profile of this physical domain We will create a simple velocity model here by hand for demonstration purposes. This model essentially consists of two layers, each with a different velocity: 1.5km/s 1.5km/s in the top layer and 2.5km/s 2.5km/s in the bottom layer. We will use this simple model a lot in the following tutorials, so we will rely on a utility function to create it again later. #NBVAL_IGNORE_OUTPUT from examples.seismic import Model , plot_velocity # Define a physical size shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # What is the location of the top left corner. This is necessary to define # the absolute location of the source and receivers # Define a velocity profile. The velocity is in km/s v = np . empty ( shape , dtype = np . float32 ) v [:, : 51 ] = 1.5 v [:, 51 :] = 2.5 # With the velocity and model size defined, we can create the seismic model that # encapsulates this properties. We also define the size of the absorbing layer as 10 grid points model = Model ( vp = v , origin = origin , shape = shape , spacing = spacing , space_order = 2 , nbl = 10 , bcs = \"damp\" ) plot_velocity ( model ) Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s Acquisition geometry To fully define our problem setup we also need to define the source that injects the wave to model and the set of receiver locations at which to sample the wavefield. The source time signature will be modelled using a Ricker wavelet defined as \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} To fully define the source signature we first need to define the time duration for our model and the timestep size, which is dictated by the CFL condition and our grid spacing. Luckily, our Model utility provides us with the critical timestep size, so we can fully discretize our model time axis as an array: from examples.seismic import TimeAxis t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) The source is positioned at a 20m 20m depth and at the middle of the x x axis ( x_{src}=500m x_{src}=500m ), with a peak wavelet frequency of 10Hz 10Hz . #NBVAL_IGNORE_OUTPUT from examples.seismic import RickerSource f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , npoint = 1 , time_range = time_range ) # First, position source centrally in all dimensions, then set depth src . coordinates . data [ 0 , :] = np . array ( model . domain_size ) * . 5 src . coordinates . data [ 0 , - 1 ] = 20. # Depth is 20m # We can plot the time signature to see the wavelet src . show () Similarly to our source object, we can now define our receiver geometry as a symbol of type Receiver . It is worth noting here that both utility classes, RickerSource and Receiver are thin wrappers around the Devito's SparseTimeFunction type, which encapsulates sparse point data and allows us to inject and interpolate values into and out of the computational grid. As we have already seen, both types provide a .coordinates property to define the position within the domain of all points encapsulated by that symbol. In this example we will position receivers at the same depth as the source, every 10m 10m along the x axis. The rec.data property will be initialized, but left empty, as we will compute the receiver readings during the simulation. #NBVAL_IGNORE_OUTPUT from examples.seismic import Receiver # Create symbol for 101 receivers rec = Receiver ( name = 'rec' , grid = model . grid , npoint = 101 , time_range = time_range ) # Prescribe even spacing for receivers along the x-axis rec . coordinates . data [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = 101 ) rec . coordinates . data [:, 1 ] = 20. # Depth is 20m # We can now show the source and receivers within our domain: # Red dot: Source location # Green dots: Receiver locations (every 4th point) plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 4 , :]) Finite-difference discretization Devito is a finite-difference DSL that solves the discretized wave-equation on a Cartesian grid. The finite-difference approximation is derived from Taylor expansions of the continuous field after removing the error term. Time discretization We only consider the second order time discretization for now. From the Taylor expansion, the second order discrete approximation of the second order time derivative is: \\begin{equation} \\begin{aligned} \\frac{d^2 u(x,t)}{dt^2} = \\frac{\\mathbf{u}(\\mathbf{x},\\mathbf{t+\\Delta t}) - 2 \\mathbf{u}(\\mathbf{x},\\mathbf{t}) + \\mathbf{u}(\\mathbf{x},\\mathbf{t-\\Delta t})}{\\mathbf{\\Delta t}^2} + O(\\mathbf{\\Delta t}^2). \\end{aligned} \\end{equation} where \\mathbf{u} \\mathbf{u} is the discrete wavefield, \\mathbf{\\Delta t} \\mathbf{\\Delta t} is the discrete time-step (distance between two consecutive discrete time points) and O(\\mathbf{\\Delta t}^2) O(\\mathbf{\\Delta t}^2) is the discretization error term. The discretized approximation of the second order time derivative is then given by dropping the error term. This derivative is represented in Devito by u.dt2 where u is a TimeFunction object. Spatial discretization We define the discrete Laplacian as the sum of the second order spatial derivatives in the three dimensions: \\begin{equation} \\begin{aligned} \\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t})= \\sum_{j=1}^{j=\\frac{k}{2}} \\Bigg[\\alpha_j \\Bigg(& \\mathbf{u}(\\mathbf{x+jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x-jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y+jdy},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y-jdy},\\mathbf{z}\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z+jdz},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z-jdz},\\mathbf{t})\\Bigg) \\Bigg] + \\\\ &3\\alpha_0 \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}). \\end{aligned} \\end{equation} This derivative is represented in Devito by u.laplace where u is a TimeFunction object. Wave equation With the space and time discretization defined, we can fully discretize the wave-equation with the combination of time and space discretizations and obtain the following second order in time and k^{th} k^{th} order in space discrete stencil to update one grid point at position \\mathbf{x}, \\mathbf{y},\\mathbf{z} \\mathbf{x}, \\mathbf{y},\\mathbf{z} at time \\mathbf{t} \\mathbf{t} , i.e. \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} # In order to represent the wavefield u and the square slowness we need symbolic objects # corresponding to time-space-varying field (u, TimeFunction) and # space-varying field (m, Function) from devito import TimeFunction # Define the wavefield with the size of the model and the time dimension u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 2 ) # We can now write the PDE pde = model . m * u . dt2 - u . laplace + model . damp * u . dt # The PDE representation is as on paper pde \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} # This discrete PDE can be solved in a time-marching way updating u(t+dt) from the previous time step # Devito as a shortcut for u(t+dt) which is u.forward. We can then rewrite the PDE as # a time marching updating equation known as a stencil using customized SymPy functions from devito import Eq , solve stencil = Eq ( u . forward , solve ( pde , u . forward )) Source injection and receiver interpolation With a numerical scheme to solve the homogenous wave equation, we need to add the source to introduce seismic waves and to implement the measurement operator, and interpolation operator. This operation is linked to the discrete scheme and needs to be done at the proper time step. The semi-discretized in time wave equation with a source reads: \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} It shows that in order to update \\mathbf{u} \\mathbf{u} at time \\mathbf{t+\\Delta t} \\mathbf{t+\\Delta t} we have to inject the value of the source term \\mathbf{q} \\mathbf{q} of time \\mathbf{t} \\mathbf{t} . In Devito, it corresponds the update of u u at index t+1 t+1 (t = time implicitly) with the source of time t t . On the receiver side, the problem is either as it only requires to record the data at the given time step t t for the receiver at time time=t time=t . # Finally we define the source injection and receiver read function to generate the corresponding code src_term = src . inject ( field = u . forward , expr = src * dt ** 2 / model . m ) # Create interpolation expression for receivers rec_term = rec . interpolate ( expr = u . forward ) Devito operator and solve After constructing all the necessary expressions for updating the wavefield, injecting the source term and interpolating onto the receiver points, we can now create the Devito operator that will generate the C code at runtime. When creating the operator, Devito's two optimization engines will log which performance optimizations have been performed: * DSE: The Devito Symbolics Engine will attempt to reduce the number of operations required by the kernel. * DLE: The Devito Loop Engine will perform various loop-level optimizations to improve runtime performance. Note : The argument subs=model.spacing_map causes the operator to substitute values for our current grid spacing into the expressions before code generation. This reduces the number of floating point operations executed by the kernel by pre-evaluating certain coefficients. #NBVAL_IGNORE_OUTPUT from devito import Operator op = Operator ([ stencil ] + src_term + rec_term , subs = model . spacing_map ) Now we can execute the create operator for a number of timesteps. We specify the number of timesteps to compute with the keyword time and the timestep size with dt . #NBVAL_IGNORE_OUTPUT op ( time = time_range . num - 1 , dt = model . critical_dt ) Operator `Kernel` run in 0.04 s PerformanceSummary([(PerfKey(name='section0', rank=None), PerfEntry(time=0.01473899999999997, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section1', rank=None), PerfEntry(time=0.009967999999999994, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section2', rank=None), PerfEntry(time=0.005742000000000012, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))]) After running our operator kernel, the data associated with the receiver symbol rec.data has now been populated due to the interpolation expression we inserted into the operator. This allows us the visualize the shot record: #NBVAL_IGNORE_OUTPUT from examples.seismic import plot_shotrecord plot_shotrecord ( rec . data , model , t0 , tn ) assert np . isclose ( np . linalg . norm ( rec . data ), 370 , rtol = 1 )","title":"Acoustic modeling"},{"location":"tutorials/01_modelling/#01-introduction-to-seismic-modelling","text":"This notebook is the first in a series of tutorials highlighting various aspects of seismic inversion based on Devito operators. In this first example we aim to highlight the core ideas behind seismic modelling, where we create a numerical model that captures the processes involved in a seismic survey. This forward model will then form the basis for further tutorials on the implementation of inversion processes using Devito operators.","title":"01 - Introduction to seismic modelling"},{"location":"tutorials/01_modelling/#modelling-workflow","text":"The core process we are aiming to model is a seismic survey, which consists of two main components: Source - A source is positioned at a single or a few physical locations where artificial pressure is injected into the domain we want to model. In the case of land survey, it is usually dynamite blowing up at a given location, or a vibroseis (a vibrating engine generating continuous sound waves). For a marine survey, the source is an air gun sending a bubble of compressed air into the water that will expand and generate a seismic wave. Receiver - A set of microphones or hydrophones are used to measure the resulting wave and create a set of measurements called a Shot Record . These measurements are recorded at multiple locations, and usually at the surface of the domain or at the bottom of the ocean in some marine cases. In order to create a numerical model of a seismic survey, we need to solve the wave equation and implement source and receiver interpolation to inject the source and record the seismic wave at sparse point locations in the grid.","title":"Modelling workflow"},{"location":"tutorials/01_modelling/#the-acoustic-seismic-wave-equation","text":"The acoustic wave equation for the square slowness m m , defined as m=\\frac{1}{c^2} m=\\frac{1}{c^2} , where c c is the speed of sound in the given physical media, and a source q q is given by: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} with the zero initial conditions to guarantee unicity of the solution. The boundary conditions are Dirichlet conditions: \\begin{equation} u(x,t)|_\\delta\\Omega = 0 \\end{equation} where \\delta\\Omega \\delta\\Omega is the surface of the boundary of the model \\Omega \\Omega .","title":"The acoustic seismic wave equation"},{"location":"tutorials/01_modelling/#finite-domains","text":"The last piece of the puzzle is the computational limitation. In the field, the seismic wave propagates in every direction to an \"infinite\" distance. However, solving the wave equation in a mathematically/discrete infinite domain is not feasible. In order to compensate, Absorbing Boundary Conditions (ABC) or Perfectly Matched Layers (PML) are required to mimic an infinite domain. These two methods allow to approximate an infinite media by damping and absorbing the waves at the limit of the domain to avoid reflections. The simplest of these methods is the absorbing damping mask. The core idea is to extend the physical domain and to add a Sponge mask in this extension that will absorb the incident waves. The acoustic wave equation with this damping mask can be rewritten as: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} where \\eta \\eta is the damping mask equal to 0 0 inside the physical domain and increasing inside the sponge layer. Multiple choice of profile can be chosen for \\eta \\eta from linear to exponential.","title":"Finite domains"},{"location":"tutorials/01_modelling/#seismic-modelling-with-devito","text":"We describe here a step by step setup of seismic modelling with Devito in a simple 2D case. We will create a physical model of our domain and define a single source and an according set of receivers to model for the forward model. But first, we initialize some basic utilities. #NBVAL_IGNORE_OUTPUT # Adding ignore due to (probably an np notebook magic) bug import numpy as np % matplotlib inline","title":"Seismic modelling with devito"},{"location":"tutorials/01_modelling/#define-the-physical-problem","text":"The first step is to define the physical model: What are the physical dimensions of interest What is the velocity profile of this physical domain We will create a simple velocity model here by hand for demonstration purposes. This model essentially consists of two layers, each with a different velocity: 1.5km/s 1.5km/s in the top layer and 2.5km/s 2.5km/s in the bottom layer. We will use this simple model a lot in the following tutorials, so we will rely on a utility function to create it again later. #NBVAL_IGNORE_OUTPUT from examples.seismic import Model , plot_velocity # Define a physical size shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # What is the location of the top left corner. This is necessary to define # the absolute location of the source and receivers # Define a velocity profile. The velocity is in km/s v = np . empty ( shape , dtype = np . float32 ) v [:, : 51 ] = 1.5 v [:, 51 :] = 2.5 # With the velocity and model size defined, we can create the seismic model that # encapsulates this properties. We also define the size of the absorbing layer as 10 grid points model = Model ( vp = v , origin = origin , shape = shape , spacing = spacing , space_order = 2 , nbl = 10 , bcs = \"damp\" ) plot_velocity ( model ) Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s","title":"Define the physical problem"},{"location":"tutorials/01_modelling/#acquisition-geometry","text":"To fully define our problem setup we also need to define the source that injects the wave to model and the set of receiver locations at which to sample the wavefield. The source time signature will be modelled using a Ricker wavelet defined as \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} To fully define the source signature we first need to define the time duration for our model and the timestep size, which is dictated by the CFL condition and our grid spacing. Luckily, our Model utility provides us with the critical timestep size, so we can fully discretize our model time axis as an array: from examples.seismic import TimeAxis t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) The source is positioned at a 20m 20m depth and at the middle of the x x axis ( x_{src}=500m x_{src}=500m ), with a peak wavelet frequency of 10Hz 10Hz . #NBVAL_IGNORE_OUTPUT from examples.seismic import RickerSource f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , npoint = 1 , time_range = time_range ) # First, position source centrally in all dimensions, then set depth src . coordinates . data [ 0 , :] = np . array ( model . domain_size ) * . 5 src . coordinates . data [ 0 , - 1 ] = 20. # Depth is 20m # We can plot the time signature to see the wavelet src . show () Similarly to our source object, we can now define our receiver geometry as a symbol of type Receiver . It is worth noting here that both utility classes, RickerSource and Receiver are thin wrappers around the Devito's SparseTimeFunction type, which encapsulates sparse point data and allows us to inject and interpolate values into and out of the computational grid. As we have already seen, both types provide a .coordinates property to define the position within the domain of all points encapsulated by that symbol. In this example we will position receivers at the same depth as the source, every 10m 10m along the x axis. The rec.data property will be initialized, but left empty, as we will compute the receiver readings during the simulation. #NBVAL_IGNORE_OUTPUT from examples.seismic import Receiver # Create symbol for 101 receivers rec = Receiver ( name = 'rec' , grid = model . grid , npoint = 101 , time_range = time_range ) # Prescribe even spacing for receivers along the x-axis rec . coordinates . data [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = 101 ) rec . coordinates . data [:, 1 ] = 20. # Depth is 20m # We can now show the source and receivers within our domain: # Red dot: Source location # Green dots: Receiver locations (every 4th point) plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 4 , :])","title":"Acquisition geometry"},{"location":"tutorials/01_modelling/#finite-difference-discretization","text":"Devito is a finite-difference DSL that solves the discretized wave-equation on a Cartesian grid. The finite-difference approximation is derived from Taylor expansions of the continuous field after removing the error term.","title":"Finite-difference discretization"},{"location":"tutorials/01_modelling/#time-discretization","text":"We only consider the second order time discretization for now. From the Taylor expansion, the second order discrete approximation of the second order time derivative is: \\begin{equation} \\begin{aligned} \\frac{d^2 u(x,t)}{dt^2} = \\frac{\\mathbf{u}(\\mathbf{x},\\mathbf{t+\\Delta t}) - 2 \\mathbf{u}(\\mathbf{x},\\mathbf{t}) + \\mathbf{u}(\\mathbf{x},\\mathbf{t-\\Delta t})}{\\mathbf{\\Delta t}^2} + O(\\mathbf{\\Delta t}^2). \\end{aligned} \\end{equation} where \\mathbf{u} \\mathbf{u} is the discrete wavefield, \\mathbf{\\Delta t} \\mathbf{\\Delta t} is the discrete time-step (distance between two consecutive discrete time points) and O(\\mathbf{\\Delta t}^2) O(\\mathbf{\\Delta t}^2) is the discretization error term. The discretized approximation of the second order time derivative is then given by dropping the error term. This derivative is represented in Devito by u.dt2 where u is a TimeFunction object.","title":"Time discretization"},{"location":"tutorials/01_modelling/#spatial-discretization","text":"We define the discrete Laplacian as the sum of the second order spatial derivatives in the three dimensions: \\begin{equation} \\begin{aligned} \\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t})= \\sum_{j=1}^{j=\\frac{k}{2}} \\Bigg[\\alpha_j \\Bigg(& \\mathbf{u}(\\mathbf{x+jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x-jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y+jdy},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y-jdy},\\mathbf{z}\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z+jdz},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z-jdz},\\mathbf{t})\\Bigg) \\Bigg] + \\\\ &3\\alpha_0 \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}). \\end{aligned} \\end{equation} This derivative is represented in Devito by u.laplace where u is a TimeFunction object.","title":"Spatial discretization"},{"location":"tutorials/01_modelling/#wave-equation","text":"With the space and time discretization defined, we can fully discretize the wave-equation with the combination of time and space discretizations and obtain the following second order in time and k^{th} k^{th} order in space discrete stencil to update one grid point at position \\mathbf{x}, \\mathbf{y},\\mathbf{z} \\mathbf{x}, \\mathbf{y},\\mathbf{z} at time \\mathbf{t} \\mathbf{t} , i.e. \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} # In order to represent the wavefield u and the square slowness we need symbolic objects # corresponding to time-space-varying field (u, TimeFunction) and # space-varying field (m, Function) from devito import TimeFunction # Define the wavefield with the size of the model and the time dimension u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 2 ) # We can now write the PDE pde = model . m * u . dt2 - u . laplace + model . damp * u . dt # The PDE representation is as on paper pde \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} # This discrete PDE can be solved in a time-marching way updating u(t+dt) from the previous time step # Devito as a shortcut for u(t+dt) which is u.forward. We can then rewrite the PDE as # a time marching updating equation known as a stencil using customized SymPy functions from devito import Eq , solve stencil = Eq ( u . forward , solve ( pde , u . forward ))","title":"Wave equation"},{"location":"tutorials/01_modelling/#source-injection-and-receiver-interpolation","text":"With a numerical scheme to solve the homogenous wave equation, we need to add the source to introduce seismic waves and to implement the measurement operator, and interpolation operator. This operation is linked to the discrete scheme and needs to be done at the proper time step. The semi-discretized in time wave equation with a source reads: \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} It shows that in order to update \\mathbf{u} \\mathbf{u} at time \\mathbf{t+\\Delta t} \\mathbf{t+\\Delta t} we have to inject the value of the source term \\mathbf{q} \\mathbf{q} of time \\mathbf{t} \\mathbf{t} . In Devito, it corresponds the update of u u at index t+1 t+1 (t = time implicitly) with the source of time t t . On the receiver side, the problem is either as it only requires to record the data at the given time step t t for the receiver at time time=t time=t . # Finally we define the source injection and receiver read function to generate the corresponding code src_term = src . inject ( field = u . forward , expr = src * dt ** 2 / model . m ) # Create interpolation expression for receivers rec_term = rec . interpolate ( expr = u . forward )","title":"Source injection and receiver interpolation"},{"location":"tutorials/01_modelling/#devito-operator-and-solve","text":"After constructing all the necessary expressions for updating the wavefield, injecting the source term and interpolating onto the receiver points, we can now create the Devito operator that will generate the C code at runtime. When creating the operator, Devito's two optimization engines will log which performance optimizations have been performed: * DSE: The Devito Symbolics Engine will attempt to reduce the number of operations required by the kernel. * DLE: The Devito Loop Engine will perform various loop-level optimizations to improve runtime performance. Note : The argument subs=model.spacing_map causes the operator to substitute values for our current grid spacing into the expressions before code generation. This reduces the number of floating point operations executed by the kernel by pre-evaluating certain coefficients. #NBVAL_IGNORE_OUTPUT from devito import Operator op = Operator ([ stencil ] + src_term + rec_term , subs = model . spacing_map ) Now we can execute the create operator for a number of timesteps. We specify the number of timesteps to compute with the keyword time and the timestep size with dt . #NBVAL_IGNORE_OUTPUT op ( time = time_range . num - 1 , dt = model . critical_dt ) Operator `Kernel` run in 0.04 s PerformanceSummary([(PerfKey(name='section0', rank=None), PerfEntry(time=0.01473899999999997, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section1', rank=None), PerfEntry(time=0.009967999999999994, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section2', rank=None), PerfEntry(time=0.005742000000000012, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))]) After running our operator kernel, the data associated with the receiver symbol rec.data has now been populated due to the interpolation expression we inserted into the operator. This allows us the visualize the shot record: #NBVAL_IGNORE_OUTPUT from examples.seismic import plot_shotrecord plot_shotrecord ( rec . data , model , t0 , tn ) assert np . isclose ( np . linalg . norm ( rec . data ), 370 , rtol = 1 )","title":"Devito operator and solve"},{"location":"tutorials/02_rtm/","text":"02 - Reverse Time Migration This notebook is the second in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling operator and velocity model. Imaging requirement Seismic imaging relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will generate synthetic field data by modelling it with the true velocity model . Background velocity model . This is a velocity model that has been obtained by processing and inverting the field data. We will look at this methods in the following tutorial as it relies on the method we are describing here. This velocity model is usually a smooth version of the true velocity model. Imaging computational setup In this tutorial, we will introduce the back-propagation operator. This operator simulates the adjoint wave-equation, that is a wave-equation solved in a reversed time order. This time reversal led to the naming of the method we present here, called Reverse Time Migration. The notion of adjoint in exploration geophysics is fundamental as most of the wave-equation based imaging and inversion methods rely on adjoint based optimization methods. Notes on the operators As we have already described the creation of a forward modelling operator, we will use a thin wrapper function instead. This wrapper is provided by a utility class called AcousticWaveSolver , which provides all the necessary operators for seismic modeling, imaging and inversion. The AcousticWaveSolver provides a more concise API for common wave propagation operators and caches the Devito Operator objects to avoid unnecessary recompilation. Operators introduced for the first time in this tutorial will be properly described. As before we initialize printing and import some utilities. We also raise the Devito log level to avoid excessive logging for repeated operator invocations. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING' Computational considerations Seismic inversion algorithms are generally very computationally demanding and require a large amount of memory to store the forward wavefield. In order to keep this tutorial as lightweight as possible we are using a very simple velocity model that requires low temporal and spatial resolution. For a more realistic model, a second set of preset parameters for a reduced version of the 2D Marmousi data set [1] is provided below in comments. This can be run to create some more realistic subsurface images. However, this second preset is more computationally demanding and requires a slightly more powerful workstation. # Configure model presets from examples.seismic import demo_model # Enable model presets here: preset = 'layers-isotropic' # A simple but cheap model (recommended) # preset = 'marmousi2d-isotropic' # A larger more realistic model # Standard preset with a simple two-layer model if preset == 'layers-isotropic' : def create_model ( grid = None ): return demo_model ( 'layers-isotropic' , origin = ( 0. , 0. ), shape = ( 101 , 101 ), spacing = ( 10. , 10. ), nbl = 20 , grid = grid , nlayers = 2 ) filter_sigma = ( 1 , 1 ) nshots = 21 nreceivers = 101 t0 = 0. tn = 1000. # Simulation last 1 second (1000 ms) f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) # A more computationally demanding preset based on the 2D Marmousi model if preset == 'marmousi2d-isotropic' : def create_model ( grid = None ): return demo_model ( 'marmousi2d-isotropic' , data_path = '../../../../data/' , grid = grid , nbl = 20 ) filter_sigma = ( 6 , 6 ) nshots = 301 # Need good covergae in shots, one every two grid points nreceivers = 601 # One recevier every grid point t0 = 0. tn = 3500. # Simulation last 3.5 second (3500 ms) f0 = 0.025 # Source peak frequency is 25Hz (0.025 kHz) True and smooth velocity models First, we create the model data for the \"true\" model from a given demonstration preset. This model represents the subsurface topology for the purposes of this example and we will later use it to generate our synthetic data readings. We also generate a second model and apply a smoothing filter to it, which represents our initial model for the imaging algorithm. The perturbation between these two models can be thought of as the image we are trying to recover. #NBVAL_IGNORE_OUTPUT from examples.seismic import plot_velocity , plot_perturbation from devito import gaussian_smooth # Create true model from a preset model = create_model () # Create initial model and smooth the boundaries model0 = create_model ( grid = model . grid ) gaussian_smooth ( model0 . vp , sigma = filter_sigma ) # Plot the true and initial model and the perturbation between them plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model ) Acquisition geometry Next we define the positioning and the wave signal of our source, as well as the location of our receivers. To generate the wavelet for our source we require the discretized values of time that we are going to use to model a single \"shot\", which again depends on the grid spacing used in our model. For consistency this initial setup will look exactly as in the previous modelling tutorial, although we will vary the position of our source later on during the actual imaging algorithm. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from examples.seismic import AcquisitionGeometry # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , - 1 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 1 ] = 30. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 =. 010 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show () True and smooth data We can now generate the shot record (receiver readings) corresponding to our true and initial models. The difference between these two records will be the basis of the imaging procedure. For this purpose we will use the same forward modelling operator that was introduced in the previous tutorial, provided by the AcousticWaveSolver utility class. This object instantiates a set of pre-defined operators according to an initial definition of the acquisition geometry, consisting of source and receiver symbols. The solver objects caches the individual operators and provides a slightly more high-level API that allows us to invoke the modelling modelling operators from the initial tutorial in a single line. In the following cells we use this to generate shot data by only specifying the respective model symbol m to use, and the solver will create and return a new Receiver object the represents the readings at the previously defined receiver coordinates. # Compute synthetic data with forward operator from examples.seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT # Plot shot record for true and smooth velocity model and the difference from examples.seismic import plot_shotrecord plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn ) Imaging with back-propagation As explained in the introduction of this tutorial, this method is based on back-propagation. Adjoint wave equation If we go back to the modelling part, we can rewrite the simulation as a linear system solve: \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} where \\mathbf{m} \\mathbf{m} is the discretized square slowness, \\mathbf{q} \\mathbf{q} is the discretized source and \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the discretized wave-equation. The discretized wave-equation matricial representation is a lower triangular matrix that can be solve with forward substitution. The pointwise writing or the forward substitution leads to the time-stepping stencil. On a small problem one could form the matrix explicitly and transpose it to obtain the adjoint discrete wave-equation: \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} where \\mathbf{v} \\mathbf{v} is the discrete adjoint wavefield and \\delta \\mathbf{d} \\delta \\mathbf{d} is the data residual defined as the difference between the field/observed data and the synthetic data \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} . In our case we derive the discrete adjoint wave-equation from the discrete forward wave-equation to get its stencil. Imaging Wave-equation based imaging relies on one simple concept: If the background velocity model is cinematically correct, the forward wavefield \\mathbf{u} \\mathbf{u} and the adjoint wavefield \\mathbf{v} \\mathbf{v} meet at the reflectors position at zero time offset. The sum over time of the zero time-offset correlation of these two fields then creates an image of the subsurface. Mathematically this leads to the simple imaging condition: \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} In the following tutorials we will describe a more advanced imaging condition that produces shaper and more accurate results. Operator We will now define the imaging operator that computes the adjoint wavefield \\mathbf{v} \\mathbf{v} and correlates it with the forward wavefield \\mathbf{u} \\mathbf{u} . This operator essentially consists of three components: * Stencil update of the adjoint wavefield v * Injection of the data residual at the adjoint source (forward receiver) location * Correlation of u and v to compute the image contribution at each timestep # Define gradient operator for imaging from devito import TimeFunction , Operator , Eq , solve from examples.seismic import PointSource def ImagingOperator ( model , image ): # Define the wavefield with the size of the model and the time dimension v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) u = TimeFunction ( name = 'u' , grid = model . grid , time_order = 2 , space_order = 4 , save = geometry . nt ) # Define the wave equation, but with a negated damping term eqn = model . m * v . dt2 - v . laplace + model . damp * v . dt . T # Use `solve` to rearrange the equation into a stencil expression stencil = Eq ( v . backward , solve ( eqn , v . backward )) # Define residual injection at the location of the forward receivers dt = model . critical_dt residual = PointSource ( name = 'residual' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m ) # Correlate u and v for the current time step and add it to the image image_update = Eq ( image , image - u * v ) return Operator ([ stencil ] + res_term + [ image_update ], subs = model . spacing_map ) Implementation of the imaging loop As just explained, the forward wave-equation is solved forward in time while the adjoint wave-equation is solved in a reversed time order. Therefore, the correlation of these two fields over time requires to store one of the two fields. The computational procedure for imaging follows: Simulate the forward wave-equation with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the image contribution at each time step. This procedure is applied to multiple source positions (shots) and summed to obtain the full image of the subsurface. We can first visualize the varying locations of the sources that we will use. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = np . linspace ( 0. , 1000 , num = nshots ) source_locations [:, 1 ] = 30. plot_velocity ( model , source = source_locations ) # Run imaging loop over shots from devito import Function # Create image symbol and instantiate the previously defined imaging operator image = Function ( name = 'image' , grid = model . grid ) op_imaging = ImagingOperator ( model , image ) for i in range ( nshots ): print ( 'Imaging source %d out of %d ' % ( i + 1 , nshots )) # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute smooth data and full forward wavefield u0 smooth_d , u0 , _ = solver . forward ( vp = model0 . vp , save = True ) # Compute gradient from the data residual v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) residual = smooth_d . data - true_d . data op_imaging ( u = u0 , v = v , vp = model0 . vp , dt = model0 . critical_dt , residual = residual ) Imaging source 1 out of 21 Imaging source 2 out of 21 Imaging source 3 out of 21 Imaging source 4 out of 21 Imaging source 5 out of 21 Imaging source 6 out of 21 Imaging source 7 out of 21 Imaging source 8 out of 21 Imaging source 9 out of 21 Imaging source 10 out of 21 Imaging source 11 out of 21 Imaging source 12 out of 21 Imaging source 13 out of 21 Imaging source 14 out of 21 Imaging source 15 out of 21 Imaging source 16 out of 21 Imaging source 17 out of 21 Imaging source 18 out of 21 Imaging source 19 out of 21 Imaging source 20 out of 21 Imaging source 21 out of 21 #NBVAL_IGNORE_OUTPUT from examples.seismic import plot_image # Plot the inverted image plot_image ( np . diff ( image . data , axis = 1 )) from devito import norm assert np . isclose ( norm ( image ), 1e7 , rtol = 1e1 ) And we have an image of the subsurface with a strong reflector at the original location. References [1] Versteeg, R.J. & Grau, G. (eds.) (1991): The Marmousi experience. Proc. EAGE workshop on Practical Aspects of Seismic Data Inversion (Copenhagen, 1990), Eur. Assoc. Explor. Geophysicists, Zeist.","title":"Acoustic RTM"},{"location":"tutorials/02_rtm/#02-reverse-time-migration","text":"This notebook is the second in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling operator and velocity model.","title":"02 - Reverse Time Migration"},{"location":"tutorials/02_rtm/#imaging-requirement","text":"Seismic imaging relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will generate synthetic field data by modelling it with the true velocity model . Background velocity model . This is a velocity model that has been obtained by processing and inverting the field data. We will look at this methods in the following tutorial as it relies on the method we are describing here. This velocity model is usually a smooth version of the true velocity model.","title":"Imaging requirement"},{"location":"tutorials/02_rtm/#imaging-computational-setup","text":"In this tutorial, we will introduce the back-propagation operator. This operator simulates the adjoint wave-equation, that is a wave-equation solved in a reversed time order. This time reversal led to the naming of the method we present here, called Reverse Time Migration. The notion of adjoint in exploration geophysics is fundamental as most of the wave-equation based imaging and inversion methods rely on adjoint based optimization methods.","title":"Imaging computational setup"},{"location":"tutorials/02_rtm/#notes-on-the-operators","text":"As we have already described the creation of a forward modelling operator, we will use a thin wrapper function instead. This wrapper is provided by a utility class called AcousticWaveSolver , which provides all the necessary operators for seismic modeling, imaging and inversion. The AcousticWaveSolver provides a more concise API for common wave propagation operators and caches the Devito Operator objects to avoid unnecessary recompilation. Operators introduced for the first time in this tutorial will be properly described. As before we initialize printing and import some utilities. We also raise the Devito log level to avoid excessive logging for repeated operator invocations. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING'","title":"Notes on the operators"},{"location":"tutorials/02_rtm/#computational-considerations","text":"Seismic inversion algorithms are generally very computationally demanding and require a large amount of memory to store the forward wavefield. In order to keep this tutorial as lightweight as possible we are using a very simple velocity model that requires low temporal and spatial resolution. For a more realistic model, a second set of preset parameters for a reduced version of the 2D Marmousi data set [1] is provided below in comments. This can be run to create some more realistic subsurface images. However, this second preset is more computationally demanding and requires a slightly more powerful workstation. # Configure model presets from examples.seismic import demo_model # Enable model presets here: preset = 'layers-isotropic' # A simple but cheap model (recommended) # preset = 'marmousi2d-isotropic' # A larger more realistic model # Standard preset with a simple two-layer model if preset == 'layers-isotropic' : def create_model ( grid = None ): return demo_model ( 'layers-isotropic' , origin = ( 0. , 0. ), shape = ( 101 , 101 ), spacing = ( 10. , 10. ), nbl = 20 , grid = grid , nlayers = 2 ) filter_sigma = ( 1 , 1 ) nshots = 21 nreceivers = 101 t0 = 0. tn = 1000. # Simulation last 1 second (1000 ms) f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) # A more computationally demanding preset based on the 2D Marmousi model if preset == 'marmousi2d-isotropic' : def create_model ( grid = None ): return demo_model ( 'marmousi2d-isotropic' , data_path = '../../../../data/' , grid = grid , nbl = 20 ) filter_sigma = ( 6 , 6 ) nshots = 301 # Need good covergae in shots, one every two grid points nreceivers = 601 # One recevier every grid point t0 = 0. tn = 3500. # Simulation last 3.5 second (3500 ms) f0 = 0.025 # Source peak frequency is 25Hz (0.025 kHz)","title":"Computational considerations"},{"location":"tutorials/02_rtm/#true-and-smooth-velocity-models","text":"First, we create the model data for the \"true\" model from a given demonstration preset. This model represents the subsurface topology for the purposes of this example and we will later use it to generate our synthetic data readings. We also generate a second model and apply a smoothing filter to it, which represents our initial model for the imaging algorithm. The perturbation between these two models can be thought of as the image we are trying to recover. #NBVAL_IGNORE_OUTPUT from examples.seismic import plot_velocity , plot_perturbation from devito import gaussian_smooth # Create true model from a preset model = create_model () # Create initial model and smooth the boundaries model0 = create_model ( grid = model . grid ) gaussian_smooth ( model0 . vp , sigma = filter_sigma ) # Plot the true and initial model and the perturbation between them plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model )","title":"True and smooth velocity models"},{"location":"tutorials/02_rtm/#acquisition-geometry","text":"Next we define the positioning and the wave signal of our source, as well as the location of our receivers. To generate the wavelet for our source we require the discretized values of time that we are going to use to model a single \"shot\", which again depends on the grid spacing used in our model. For consistency this initial setup will look exactly as in the previous modelling tutorial, although we will vary the position of our source later on during the actual imaging algorithm. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from examples.seismic import AcquisitionGeometry # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , - 1 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 1 ] = 30. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 =. 010 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show ()","title":"Acquisition geometry"},{"location":"tutorials/02_rtm/#true-and-smooth-data","text":"We can now generate the shot record (receiver readings) corresponding to our true and initial models. The difference between these two records will be the basis of the imaging procedure. For this purpose we will use the same forward modelling operator that was introduced in the previous tutorial, provided by the AcousticWaveSolver utility class. This object instantiates a set of pre-defined operators according to an initial definition of the acquisition geometry, consisting of source and receiver symbols. The solver objects caches the individual operators and provides a slightly more high-level API that allows us to invoke the modelling modelling operators from the initial tutorial in a single line. In the following cells we use this to generate shot data by only specifying the respective model symbol m to use, and the solver will create and return a new Receiver object the represents the readings at the previously defined receiver coordinates. # Compute synthetic data with forward operator from examples.seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT # Plot shot record for true and smooth velocity model and the difference from examples.seismic import plot_shotrecord plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn )","title":"True and smooth data"},{"location":"tutorials/02_rtm/#imaging-with-back-propagation","text":"As explained in the introduction of this tutorial, this method is based on back-propagation.","title":"Imaging with back-propagation"},{"location":"tutorials/02_rtm/#adjoint-wave-equation","text":"If we go back to the modelling part, we can rewrite the simulation as a linear system solve: \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} where \\mathbf{m} \\mathbf{m} is the discretized square slowness, \\mathbf{q} \\mathbf{q} is the discretized source and \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the discretized wave-equation. The discretized wave-equation matricial representation is a lower triangular matrix that can be solve with forward substitution. The pointwise writing or the forward substitution leads to the time-stepping stencil. On a small problem one could form the matrix explicitly and transpose it to obtain the adjoint discrete wave-equation: \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} where \\mathbf{v} \\mathbf{v} is the discrete adjoint wavefield and \\delta \\mathbf{d} \\delta \\mathbf{d} is the data residual defined as the difference between the field/observed data and the synthetic data \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} . In our case we derive the discrete adjoint wave-equation from the discrete forward wave-equation to get its stencil.","title":"Adjoint wave equation"},{"location":"tutorials/02_rtm/#imaging","text":"Wave-equation based imaging relies on one simple concept: If the background velocity model is cinematically correct, the forward wavefield \\mathbf{u} \\mathbf{u} and the adjoint wavefield \\mathbf{v} \\mathbf{v} meet at the reflectors position at zero time offset. The sum over time of the zero time-offset correlation of these two fields then creates an image of the subsurface. Mathematically this leads to the simple imaging condition: \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} In the following tutorials we will describe a more advanced imaging condition that produces shaper and more accurate results.","title":"Imaging"},{"location":"tutorials/02_rtm/#operator","text":"We will now define the imaging operator that computes the adjoint wavefield \\mathbf{v} \\mathbf{v} and correlates it with the forward wavefield \\mathbf{u} \\mathbf{u} . This operator essentially consists of three components: * Stencil update of the adjoint wavefield v * Injection of the data residual at the adjoint source (forward receiver) location * Correlation of u and v to compute the image contribution at each timestep # Define gradient operator for imaging from devito import TimeFunction , Operator , Eq , solve from examples.seismic import PointSource def ImagingOperator ( model , image ): # Define the wavefield with the size of the model and the time dimension v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) u = TimeFunction ( name = 'u' , grid = model . grid , time_order = 2 , space_order = 4 , save = geometry . nt ) # Define the wave equation, but with a negated damping term eqn = model . m * v . dt2 - v . laplace + model . damp * v . dt . T # Use `solve` to rearrange the equation into a stencil expression stencil = Eq ( v . backward , solve ( eqn , v . backward )) # Define residual injection at the location of the forward receivers dt = model . critical_dt residual = PointSource ( name = 'residual' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m ) # Correlate u and v for the current time step and add it to the image image_update = Eq ( image , image - u * v ) return Operator ([ stencil ] + res_term + [ image_update ], subs = model . spacing_map )","title":"Operator"},{"location":"tutorials/02_rtm/#implementation-of-the-imaging-loop","text":"As just explained, the forward wave-equation is solved forward in time while the adjoint wave-equation is solved in a reversed time order. Therefore, the correlation of these two fields over time requires to store one of the two fields. The computational procedure for imaging follows: Simulate the forward wave-equation with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the image contribution at each time step. This procedure is applied to multiple source positions (shots) and summed to obtain the full image of the subsurface. We can first visualize the varying locations of the sources that we will use. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = np . linspace ( 0. , 1000 , num = nshots ) source_locations [:, 1 ] = 30. plot_velocity ( model , source = source_locations ) # Run imaging loop over shots from devito import Function # Create image symbol and instantiate the previously defined imaging operator image = Function ( name = 'image' , grid = model . grid ) op_imaging = ImagingOperator ( model , image ) for i in range ( nshots ): print ( 'Imaging source %d out of %d ' % ( i + 1 , nshots )) # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute smooth data and full forward wavefield u0 smooth_d , u0 , _ = solver . forward ( vp = model0 . vp , save = True ) # Compute gradient from the data residual v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) residual = smooth_d . data - true_d . data op_imaging ( u = u0 , v = v , vp = model0 . vp , dt = model0 . critical_dt , residual = residual ) Imaging source 1 out of 21 Imaging source 2 out of 21 Imaging source 3 out of 21 Imaging source 4 out of 21 Imaging source 5 out of 21 Imaging source 6 out of 21 Imaging source 7 out of 21 Imaging source 8 out of 21 Imaging source 9 out of 21 Imaging source 10 out of 21 Imaging source 11 out of 21 Imaging source 12 out of 21 Imaging source 13 out of 21 Imaging source 14 out of 21 Imaging source 15 out of 21 Imaging source 16 out of 21 Imaging source 17 out of 21 Imaging source 18 out of 21 Imaging source 19 out of 21 Imaging source 20 out of 21 Imaging source 21 out of 21 #NBVAL_IGNORE_OUTPUT from examples.seismic import plot_image # Plot the inverted image plot_image ( np . diff ( image . data , axis = 1 )) from devito import norm assert np . isclose ( norm ( image ), 1e7 , rtol = 1e1 ) And we have an image of the subsurface with a strong reflector at the original location.","title":"Implementation of the imaging loop"},{"location":"tutorials/02_rtm/#references","text":"[1] Versteeg, R.J. & Grau, G. (eds.) (1991): The Marmousi experience. Proc. EAGE workshop on Practical Aspects of Seismic Data Inversion (Copenhagen, 1990), Eur. Assoc. Explor. Geophysicists, Zeist.","title":"References"},{"location":"tutorials/03_fwi/","text":"03 - Full-Waveform Inversion (FWI) This notebook is the third in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling and velocity model. Inversion requirement Seismic inversion relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will fake field data by modelling it with the true velocity model. Initial velocity model . This is a velocity model that has been obtained by processing the field data. This model is a rough and very smooth estimate of the velocity as an initial estimate for the inversion. This is a necessary requirement for any optimization (method). Inversion computational setup In this tutorial, we will introduce the gradient operator. This operator corresponds to the imaging condition introduced in the previous tutorial with some minor modifications that are defined by the objective function (also referred to in the tutorial series as the functional , f ) and its gradient, g . We will define these two terms in the tutorial too. Notes on the operators As we have already described the creation of a forward modelling operator, we will only call a wrapper function here. This wrapper already contains all the necessary operators for seismic modeling, imaging and inversion. Operators introduced for the first time in this tutorial will be properly described. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING' Computational considerations As we will see, FWI is computationally extremely demanding, even more than RTM. To keep this tutorial as lightwight as possible we therefore again use a very small demonstration model. We also define here a few parameters for the final example runs that can be changed to modify the overall runtime of the tutorial. nshots = 9 # Number of shots to create gradient from nreceivers = 101 # Number of receiver locations per shot fwi_iterations = 5 # Number of outer FWI iterations True and smooth velocity models We will use a very simple model domain, consisting of a circle within a 2D domain. We will again use the \"true\" model to generate our synthetic shot data and use a \"smooth\" model as our initial guess. In this case the smooth model is very smooth indeed - it is simply a constant background velocity without any features. #NBVAL_IGNORE_OUTPUT from examples.seismic import demo_model , plot_velocity , plot_perturbation # Define true and initial model shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # Need origin to define relative source and receiver locations model = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 ) model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 , grid = model . grid ) plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model ) assert model . grid == model0 . grid assert model . vp . grid == model0 . vp . grid Acquisition geometry In this tutorial, we will use the easiest case for inversion, namely a transmission experiment. The sources are located on one side of the model and the receivers on the other side. This allows to record most of the information necessary for inversion, as reflections usually lead to poor inversion results. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from examples.seismic import AcquisitionGeometry t0 = 0. tn = 1000. f0 = 0.010 # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , 0 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show () # Plot acquisition geometry plot_velocity ( model , source = geometry . src_positions , receiver = geometry . rec_positions [:: 4 , :]) True and smooth data We can generate shot records for the true and smoothed initial velocity models, since the difference between them will again form the basis of our imaging procedure. # Compute synthetic data with forward operator from examples.seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT from examples.seismic import plot_shotrecord # Plot shot record for true and smooth velocity model and the difference plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn ) Full-Waveform Inversion Formulation Full-waveform inversion (FWI) aims to invert an accurate model of the discrete wave velocity, \\mathbf{c} \\mathbf{c} , or equivalently the square slowness of the wave, \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} , from a given set of measurements of the pressure wavefield \\mathbf{u} \\mathbf{u} . This can be expressed as the following optimization problem [1, 2]: \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} where \\mathbf{P}_r \\mathbf{P}_r is the sampling operator at the receiver locations, \\mathbf{P}_s^T \\mathbf{P}_s^T is the injection operator at the source locations, \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the operator representing the discretized wave equation matrix, \\mathbf{u} \\mathbf{u} is the discrete synthetic pressure wavefield, \\mathbf{q}_s \\mathbf{q}_s is the corresponding pressure source and \\mathbf{d} \\mathbf{d} is the measured data. It is worth noting that \\mathbf{m} \\mathbf{m} is the unknown in this formulation and that multiple implementations of the wave equation operator \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) are possible. We have already defined a concrete solver scheme for \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) in the first tutorial, including appropriate implementations of the sampling operator \\mathbf{P}_r \\mathbf{P}_r and source term \\mathbf{q}_s \\mathbf{q}_s . To solve this optimization problem using a gradient-based method, we use the adjoint-state method to evaluate the gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) : \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} where n_t n_t is the number of computational time steps, \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) is the data residual (difference between the measured data and the modelled data), \\mathbf{J} \\mathbf{J} is the Jacobian operator and \\mathbf{v}_{tt} \\mathbf{v}_{tt} is the second-order time derivative of the adjoint wavefield solving: \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} We see that the gradient of the FWI function is the previously defined imaging condition with an extra second-order time derivative. We will therefore reuse the operators defined previously inside a Devito wrapper. FWI gradient operator To compute a single gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) in our optimization workflow we again use solver.forward to compute the entire forward wavefield \\mathbf{u} \\mathbf{u} and a similar pre-defined gradient operator to compute the adjoint wavefield v . The gradient operator provided by our solver utility also computes the correlation between the wavefields, allowing us to encode a similar procedure to the previous imaging tutorial as our gradient calculation: Simulate the forward wavefield with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the gradient contribution at each time step. This procedure is applied to multiple source positions and summed to obtain a gradient image of the subsurface. We again prepare the source locations for each shot and visualize them, before defining a single gradient computation over a number of shots as a single function. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations sources source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = 30. source_locations [:, 1 ] = np . linspace ( 0. , 1000 , num = nshots ) plot_velocity ( model , source = source_locations ) from devito import Eq , Operator # Computes the residual between observed and synthetic data into the residual def compute_residual ( residual , dobs , dsyn ): if residual . grid . distributor . is_parallel : # If we run with MPI, we have to compute the residual via an operator # First make sure we can take the difference and that receivers are at the # same position assert np . allclose ( dobs . coordinates . data [:], dsyn . coordinates . data ) assert np . allclose ( residual . coordinates . data [:], dsyn . coordinates . data ) # Create a difference operator diff_eq = Eq ( residual , dsyn . subs ({ dsyn . dimensions [ - 1 ]: residual . dimensions [ - 1 ]}) - dobs . subs ({ dobs . dimensions [ - 1 ]: residual . dimensions [ - 1 ]})) Operator ( diff_eq )() else : # A simple data difference is enough in serial residual . data [:] = dsyn . data [:] - dobs . data [:] return residual # Create FWI gradient kernel from devito import Function , TimeFunction , norm from examples.seismic import Receiver import scipy def fwi_gradient ( vp_in ): # Create symbols to hold the gradient grad = Function ( name = \"grad\" , grid = model . grid ) # Create placeholders for the data residual and data residual = Receiver ( name = 'residual' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) d_obs = Receiver ( name = 'd_obs' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) d_syn = Receiver ( name = 'd_syn' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) objective = 0. for i in range ( nshots ): # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model _ , _ , _ = solver . forward ( vp = model . vp , rec = d_obs ) # Compute smooth data and full forward wavefield u0 _ , u0 , _ = solver . forward ( vp = vp_in , save = True , rec = d_syn ) # Compute gradient from data residual and update objective function compute_residual ( residual , d_obs , d_syn ) objective += . 5 * norm ( residual ) ** 2 solver . gradient ( rec = residual , u = u0 , vp = vp_in , grad = grad ) return objective , grad Having defined our FWI gradient procedure we can compute the initial iteration from our starting model. This allows us to visualize the gradient alongside the model perturbation and the effect of the gradient update on the model. # Compute gradient of initial model ff , update = fwi_gradient ( model0 . vp ) assert np . isclose ( ff , 57283 , rtol = 1e0 ) #NBVAL_IGNORE_OUTPUT from devito import mmax from examples.seismic import plot_image # Plot the FWI gradient plot_image ( - update . data , vmin =- 1e4 , vmax = 1e4 , cmap = \"jet\" ) # Plot the difference between the true and initial model. # This is not known in practice as only the initial model is provided. plot_image ( model0 . vp . data - model . vp . data , vmin =- 1e-1 , vmax = 1e-1 , cmap = \"jet\" ) # Show what the update does to the model alpha = . 5 / mmax ( update ) plot_image ( model0 . vp . data + alpha * update . data , vmin = 2.5 , vmax = 3.0 , cmap = \"jet\" ) We see that the gradient and the true perturbation have the same sign, therefore, with an appropriate scaling factor, we will update the model in the correct direction. from sympy import Min , Max # Define bounding box constraints on the solution. def update_with_box ( vp , alpha , dm , vmin = 2.0 , vmax = 3.5 ): \"\"\" Apply gradient update in-place to vp with box constraint Notes: ------ For more advanced algorithm, one will need to gather the non-distributed velocity array to apply constrains and such. \"\"\" update = vp + alpha * dm update_eq = Eq ( vp , Max ( Min ( update , vmax ), vmin )) Operator ( update_eq )() #NBVAL_SKIP from devito import mmax # Run FWI with gradient descent history = np . zeros (( fwi_iterations , 1 )) for i in range ( 0 , fwi_iterations ): # Compute the functional value and gradient for the current # model estimate phi , direction = fwi_gradient ( model0 . vp ) # Store the history of the functional values history [ i ] = phi # Artificial Step length for gradient descent # In practice this would be replaced by a Linesearch (Wolfe, ...) # that would guarantee functional decrease Phi(m-alpha g) <= epsilon Phi(m) # where epsilon is a minimum decrease constant alpha = . 05 / mmax ( direction ) # Update the model estimate and enforce minimum/maximum values update_with_box ( model0 . vp , alpha , direction ) # Log the progress made print ( 'Objective value is %f at iteration %d ' % ( phi , i + 1 )) Objective value is 57285.103209 at iteration 1 Objective value is 35766.902505 at iteration 2 Objective value is 21002.932951 at iteration 3 Objective value is 11548.234192 at iteration 4 Objective value is 5786.186187 at iteration 5 #NBVAL_IGNORE_OUTPUT # Plot inverted velocity model plot_velocity ( model0 ) #NBVAL_SKIP import matplotlib.pyplot as plt # Plot objective function decrease plt . figure () plt . loglog ( history ) plt . xlabel ( 'Iteration number' ) plt . ylabel ( 'Misift value Phi' ) plt . title ( 'Convergence' ) plt . show () References [1] Virieux, J. and Operto, S.: An overview of full-waveform inversion in exploration geophysics, GEOPHYSICS, 74, WCC1\u2013WCC26, doi:10.1190/1.3238367, http://library.seg.org/doi/abs/10.1190/1.3238367 , 2009. [2] Haber, E., Chung, M., and Herrmann, F. J.: An effective method for parameter estimation with PDE constraints with multiple right hand sides, SIAM Journal on Optimization, 22, http://dx.doi.org/10.1137/11081126X , 2012. This notebook is part of the tutorial \"Optimised Symbolic Finite Difference Computation with Devito\" presented at the Intel\u00ae HPC Developer Conference 2017.","title":"Acoustic FWI"},{"location":"tutorials/03_fwi/#03-full-waveform-inversion-fwi","text":"This notebook is the third in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling and velocity model.","title":"03 - Full-Waveform Inversion (FWI)"},{"location":"tutorials/03_fwi/#inversion-requirement","text":"Seismic inversion relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will fake field data by modelling it with the true velocity model. Initial velocity model . This is a velocity model that has been obtained by processing the field data. This model is a rough and very smooth estimate of the velocity as an initial estimate for the inversion. This is a necessary requirement for any optimization (method).","title":"Inversion requirement"},{"location":"tutorials/03_fwi/#inversion-computational-setup","text":"In this tutorial, we will introduce the gradient operator. This operator corresponds to the imaging condition introduced in the previous tutorial with some minor modifications that are defined by the objective function (also referred to in the tutorial series as the functional , f ) and its gradient, g . We will define these two terms in the tutorial too.","title":"Inversion computational setup"},{"location":"tutorials/03_fwi/#notes-on-the-operators","text":"As we have already described the creation of a forward modelling operator, we will only call a wrapper function here. This wrapper already contains all the necessary operators for seismic modeling, imaging and inversion. Operators introduced for the first time in this tutorial will be properly described. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING'","title":"Notes on the operators"},{"location":"tutorials/03_fwi/#computational-considerations","text":"As we will see, FWI is computationally extremely demanding, even more than RTM. To keep this tutorial as lightwight as possible we therefore again use a very small demonstration model. We also define here a few parameters for the final example runs that can be changed to modify the overall runtime of the tutorial. nshots = 9 # Number of shots to create gradient from nreceivers = 101 # Number of receiver locations per shot fwi_iterations = 5 # Number of outer FWI iterations","title":"Computational considerations"},{"location":"tutorials/03_fwi/#true-and-smooth-velocity-models","text":"We will use a very simple model domain, consisting of a circle within a 2D domain. We will again use the \"true\" model to generate our synthetic shot data and use a \"smooth\" model as our initial guess. In this case the smooth model is very smooth indeed - it is simply a constant background velocity without any features. #NBVAL_IGNORE_OUTPUT from examples.seismic import demo_model , plot_velocity , plot_perturbation # Define true and initial model shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # Need origin to define relative source and receiver locations model = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 ) model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 , grid = model . grid ) plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model ) assert model . grid == model0 . grid assert model . vp . grid == model0 . vp . grid","title":"True and smooth velocity models"},{"location":"tutorials/03_fwi/#acquisition-geometry","text":"In this tutorial, we will use the easiest case for inversion, namely a transmission experiment. The sources are located on one side of the model and the receivers on the other side. This allows to record most of the information necessary for inversion, as reflections usually lead to poor inversion results. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from examples.seismic import AcquisitionGeometry t0 = 0. tn = 1000. f0 = 0.010 # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , 0 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show () # Plot acquisition geometry plot_velocity ( model , source = geometry . src_positions , receiver = geometry . rec_positions [:: 4 , :])","title":"Acquisition geometry"},{"location":"tutorials/03_fwi/#true-and-smooth-data","text":"We can generate shot records for the true and smoothed initial velocity models, since the difference between them will again form the basis of our imaging procedure. # Compute synthetic data with forward operator from examples.seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT from examples.seismic import plot_shotrecord # Plot shot record for true and smooth velocity model and the difference plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn )","title":"True and smooth data"},{"location":"tutorials/03_fwi/#full-waveform-inversion","text":"","title":"Full-Waveform Inversion"},{"location":"tutorials/03_fwi/#formulation","text":"Full-waveform inversion (FWI) aims to invert an accurate model of the discrete wave velocity, \\mathbf{c} \\mathbf{c} , or equivalently the square slowness of the wave, \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} , from a given set of measurements of the pressure wavefield \\mathbf{u} \\mathbf{u} . This can be expressed as the following optimization problem [1, 2]: \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} where \\mathbf{P}_r \\mathbf{P}_r is the sampling operator at the receiver locations, \\mathbf{P}_s^T \\mathbf{P}_s^T is the injection operator at the source locations, \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the operator representing the discretized wave equation matrix, \\mathbf{u} \\mathbf{u} is the discrete synthetic pressure wavefield, \\mathbf{q}_s \\mathbf{q}_s is the corresponding pressure source and \\mathbf{d} \\mathbf{d} is the measured data. It is worth noting that \\mathbf{m} \\mathbf{m} is the unknown in this formulation and that multiple implementations of the wave equation operator \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) are possible. We have already defined a concrete solver scheme for \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) in the first tutorial, including appropriate implementations of the sampling operator \\mathbf{P}_r \\mathbf{P}_r and source term \\mathbf{q}_s \\mathbf{q}_s . To solve this optimization problem using a gradient-based method, we use the adjoint-state method to evaluate the gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) : \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} where n_t n_t is the number of computational time steps, \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) is the data residual (difference between the measured data and the modelled data), \\mathbf{J} \\mathbf{J} is the Jacobian operator and \\mathbf{v}_{tt} \\mathbf{v}_{tt} is the second-order time derivative of the adjoint wavefield solving: \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} We see that the gradient of the FWI function is the previously defined imaging condition with an extra second-order time derivative. We will therefore reuse the operators defined previously inside a Devito wrapper.","title":"Formulation"},{"location":"tutorials/03_fwi/#fwi-gradient-operator","text":"To compute a single gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) in our optimization workflow we again use solver.forward to compute the entire forward wavefield \\mathbf{u} \\mathbf{u} and a similar pre-defined gradient operator to compute the adjoint wavefield v . The gradient operator provided by our solver utility also computes the correlation between the wavefields, allowing us to encode a similar procedure to the previous imaging tutorial as our gradient calculation: Simulate the forward wavefield with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the gradient contribution at each time step. This procedure is applied to multiple source positions and summed to obtain a gradient image of the subsurface. We again prepare the source locations for each shot and visualize them, before defining a single gradient computation over a number of shots as a single function. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations sources source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = 30. source_locations [:, 1 ] = np . linspace ( 0. , 1000 , num = nshots ) plot_velocity ( model , source = source_locations ) from devito import Eq , Operator # Computes the residual between observed and synthetic data into the residual def compute_residual ( residual , dobs , dsyn ): if residual . grid . distributor . is_parallel : # If we run with MPI, we have to compute the residual via an operator # First make sure we can take the difference and that receivers are at the # same position assert np . allclose ( dobs . coordinates . data [:], dsyn . coordinates . data ) assert np . allclose ( residual . coordinates . data [:], dsyn . coordinates . data ) # Create a difference operator diff_eq = Eq ( residual , dsyn . subs ({ dsyn . dimensions [ - 1 ]: residual . dimensions [ - 1 ]}) - dobs . subs ({ dobs . dimensions [ - 1 ]: residual . dimensions [ - 1 ]})) Operator ( diff_eq )() else : # A simple data difference is enough in serial residual . data [:] = dsyn . data [:] - dobs . data [:] return residual # Create FWI gradient kernel from devito import Function , TimeFunction , norm from examples.seismic import Receiver import scipy def fwi_gradient ( vp_in ): # Create symbols to hold the gradient grad = Function ( name = \"grad\" , grid = model . grid ) # Create placeholders for the data residual and data residual = Receiver ( name = 'residual' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) d_obs = Receiver ( name = 'd_obs' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) d_syn = Receiver ( name = 'd_syn' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) objective = 0. for i in range ( nshots ): # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model _ , _ , _ = solver . forward ( vp = model . vp , rec = d_obs ) # Compute smooth data and full forward wavefield u0 _ , u0 , _ = solver . forward ( vp = vp_in , save = True , rec = d_syn ) # Compute gradient from data residual and update objective function compute_residual ( residual , d_obs , d_syn ) objective += . 5 * norm ( residual ) ** 2 solver . gradient ( rec = residual , u = u0 , vp = vp_in , grad = grad ) return objective , grad Having defined our FWI gradient procedure we can compute the initial iteration from our starting model. This allows us to visualize the gradient alongside the model perturbation and the effect of the gradient update on the model. # Compute gradient of initial model ff , update = fwi_gradient ( model0 . vp ) assert np . isclose ( ff , 57283 , rtol = 1e0 ) #NBVAL_IGNORE_OUTPUT from devito import mmax from examples.seismic import plot_image # Plot the FWI gradient plot_image ( - update . data , vmin =- 1e4 , vmax = 1e4 , cmap = \"jet\" ) # Plot the difference between the true and initial model. # This is not known in practice as only the initial model is provided. plot_image ( model0 . vp . data - model . vp . data , vmin =- 1e-1 , vmax = 1e-1 , cmap = \"jet\" ) # Show what the update does to the model alpha = . 5 / mmax ( update ) plot_image ( model0 . vp . data + alpha * update . data , vmin = 2.5 , vmax = 3.0 , cmap = \"jet\" ) We see that the gradient and the true perturbation have the same sign, therefore, with an appropriate scaling factor, we will update the model in the correct direction. from sympy import Min , Max # Define bounding box constraints on the solution. def update_with_box ( vp , alpha , dm , vmin = 2.0 , vmax = 3.5 ): \"\"\" Apply gradient update in-place to vp with box constraint Notes: ------ For more advanced algorithm, one will need to gather the non-distributed velocity array to apply constrains and such. \"\"\" update = vp + alpha * dm update_eq = Eq ( vp , Max ( Min ( update , vmax ), vmin )) Operator ( update_eq )() #NBVAL_SKIP from devito import mmax # Run FWI with gradient descent history = np . zeros (( fwi_iterations , 1 )) for i in range ( 0 , fwi_iterations ): # Compute the functional value and gradient for the current # model estimate phi , direction = fwi_gradient ( model0 . vp ) # Store the history of the functional values history [ i ] = phi # Artificial Step length for gradient descent # In practice this would be replaced by a Linesearch (Wolfe, ...) # that would guarantee functional decrease Phi(m-alpha g) <= epsilon Phi(m) # where epsilon is a minimum decrease constant alpha = . 05 / mmax ( direction ) # Update the model estimate and enforce minimum/maximum values update_with_box ( model0 . vp , alpha , direction ) # Log the progress made print ( 'Objective value is %f at iteration %d ' % ( phi , i + 1 )) Objective value is 57285.103209 at iteration 1 Objective value is 35766.902505 at iteration 2 Objective value is 21002.932951 at iteration 3 Objective value is 11548.234192 at iteration 4 Objective value is 5786.186187 at iteration 5 #NBVAL_IGNORE_OUTPUT # Plot inverted velocity model plot_velocity ( model0 ) #NBVAL_SKIP import matplotlib.pyplot as plt # Plot objective function decrease plt . figure () plt . loglog ( history ) plt . xlabel ( 'Iteration number' ) plt . ylabel ( 'Misift value Phi' ) plt . title ( 'Convergence' ) plt . show ()","title":"FWI gradient operator"},{"location":"tutorials/03_fwi/#references","text":"[1] Virieux, J. and Operto, S.: An overview of full-waveform inversion in exploration geophysics, GEOPHYSICS, 74, WCC1\u2013WCC26, doi:10.1190/1.3238367, http://library.seg.org/doi/abs/10.1190/1.3238367 , 2009. [2] Haber, E., Chung, M., and Herrmann, F. J.: An effective method for parameter estimation with PDE constraints with multiple right hand sides, SIAM Journal on Optimization, 22, http://dx.doi.org/10.1137/11081126X , 2012. This notebook is part of the tutorial \"Optimised Symbolic Finite Difference Computation with Devito\" presented at the Intel\u00ae HPC Developer Conference 2017.","title":"References"},{"location":"tutorials/04_dask/","text":"04 - Full Waveform Inversion with Devito and Dask Introduction In this tutorial, we will build on the previous FWI tutorial and implement parallel versions of both forward modeling and FWI objective functions. Furthermore, we will show how our parallel FWI function can be passed to black-box third party optimization libraries, such as SciPy's optimize package, to access sophisticated optimization algorithms without having to implement them from scratch! To implement parallel versions of forward modeling and FWI, we will use Dask , a Python library for distributed computing based on parallel data structures and task-based programming. As computing multiple seismic shot records or gradients for subsequent source locations is an embarassingly parallel process, we will use Dask to dynamically distribute our workload to a pool of available workers and afterwards collect the results. The first part of this tutorial closely follows tutorial 3 and consists of reading the velocity model and setting up the acquisition geometry. Subsequently, we will implement serial versions of forward modeling and FWI objective functions and then show how we can use Dask to implement parallel versions of these functions. Finally, we will show how to write a wrapper that lets us pass our objective function to scipy's optimize package and how to run a small 2D FWI example using a limited-memory Quasi-Newton method. GPU Aware Dask The default method to start a Dask Cluster is LocalCluster(...). This method enables CPU worker threads, but it shares one GPU for all workers. To enable Dask to use multi-GPU, or a GPU per Dask worker, the method to start a Dask Cluster needs to be changed to LocalCUDACluster. This Dask modification is pulled from the Rapids.ai open source project. Reference: https://github.com/rapidsai/dask-cuda USE_GPU_AWARE_DASK = False Set up velocity models As before, we start by reading the true (i.e. unknown) velocity model, as well as the starting model for FWI. For our example, we once again use the 2D Camembert model with a transmission acquisition set up, which involves having sources on one side of the model and receivers on the other side. In reality, we obvisouly cannot know what the true velocity is, but here we use the true model to generate our own data (inverse crime alert!) and to compare it to our FWI result. from examples.seismic import demo_model # Set up velocity model shape = ( 101 , 101 ) # Number of grid points (nx, nz). spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km. origin = ( 0 , 0 ) # Need origin to define relative source and receiver locations. nbl = 40 # True model model1 = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = nbl ) # Initial model model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = nbl , grid = model1 . grid ) Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s Acquisition geometry For the acquisition geometry, we use the same setup as in tutorial 3 and position 5 source position on one side of the model, and an array of 101 receivers on the other side. Note that now our source coordinate array ( src_coordinates ) is a 5 x 2 array, containing the shot locations of all 5 source experiments. After defining the source/receiver coordinates, we set up individual geometry objects for both the observed data (using model ) and the predicted data (using model0 ). from examples.seismic import AcquisitionGeometry import numpy as np # Set up acquisiton geometry t0 = 0. tn = 1000. f0 = 0.010 # Set up source geometry, but define 5 sources instead of just one. nsources = 5 src_coordinates = np . empty (( nsources , 2 )) src_coordinates [:, 1 ] = np . linspace ( 0 , model1 . domain_size [ 0 ], num = nsources ) src_coordinates [:, 0 ] = 20. # Source depth is 20m # Initialize receivers for synthetic and imaging data nreceivers = 101 rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( spacing [ 0 ], model1 . domain_size [ 0 ] - spacing [ 0 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Receiver depth # Set up geometry objects for observed and predicted data geometry1 = AcquisitionGeometry ( model1 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) geometry0 = AcquisitionGeometry ( model0 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) Forward modeling Before diving into FWI, we will start with forward modeling and show how we can use Dask to implement a parallel wrapper around a serial modeling function to compute seismic shot records for multiple source locations in parallel. First, we implement a forward modeling function for a single shot, which takes a geometry data structure as the only mandatory input argument. This function assumes that the geometry structure only contains a single source location. To solve the wave equation for the current shot location and model as specified in geometry , we use the AcousticSolver from previous tutorials, which is an abstract layer built on top of (generic) Devito objects. AcousticSolver contains Devito implementations of forward and adjoint wave equations, as well as Jacobians as specified in tutorials 1 and 2, so we don't have to re-implement these PDEs here. from examples.seismic.acoustic import AcousticWaveSolver # Serial modeling function def forward_modeling_single_shot ( geometry , save = False , dt = 4.0 ): solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) d_obs , u0 = solver . forward ( vp = geometry . model . vp , save = save )[ 0 : 2 ] return d_obs . resample ( dt ), u0 With our modeling function for a single shot record in place, we now implement our parallel version of our modeling function, which consists of a loop over all source locations. As the geometry object in forward_modeling_single_shot expects only a single source location, we set up a new geometry structure for the i-th source location to pass to our modeling function. However, rather than simpling calling the modeling function for single shots, we tell Dask to create a task for each source location and to distribute them to the available parallel workers. Dask returns a remote reference to the result on each worker called future . The wait statement tells our function to wait for all tasks to finish their computations, after which we collect the modeled shot records from the workers. # Parallel modeling function def forward_modeling_multi_shots ( geometry , save = False , dt = 4.0 ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i ,:], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial modeling function for each index futures . append ( client . submit ( forward_modeling_single_shot , geometry_i , save = save , dt = dt )) # Wait for all workers to finish and collect shots wait ( futures ) shots = [] for i in range ( geometry . nsrc ): shots . append ( futures [ i ] . result ()[ 0 ]) return shots We can use this parallel modeling function to generate our own observed data set, which we will subsequently use for our FWI example. In reality, we would instead read our observed data from a SEG-Y file. To compute the data in parallel, we launch a pool of workers on our local machine and then call the parallel modeling function: from distributed import Client , wait # Start Dask cluster if USE_GPU_AWARE_DASK : from dask_cuda import LocalCUDACluster cluster = LocalCUDACluster ( threads_per_worker = 1 , death_timeout = 600 ) else : from distributed import LocalCluster cluster = LocalCluster ( n_workers = nsources , death_timeout = 600 ) client = Client ( cluster ) # Compute observed data in parallel (inverse crime). In real life we would read the SEG-Y data here. d_obs = forward_modeling_multi_shots ( geometry1 , save = False ) The variable d_obs is a list of the 5 shots records and we can plot one of the shot records as follows: from examples.seismic import plot_shotrecord # Plot shot no. 3 of 5 plot_shotrecord ( d_obs [ 2 ] . data , model1 , t0 , tn ) Parallel Full-Waveform Inversion Now that we know how to use Dask to implement a parallel loop around a (serial) modeling function for a single shot, we can apply the same concept to an FWI objective function, which computes the FWI function value and gradient for a given geometry and observed shot record. This function follows largely the structure in tutorial 3 and involves computing the predicted data and backpropagating the residual to compute the gradient. As we do not want to update the velocity in the area of the absorbing boundaries, we only return the gradient on the (original) physical grid. from devito import Function from examples.seismic import Receiver # Serial FWI objective function def fwi_objective_single_shot ( geometry , d_obs ): # Devito objects for gradient and data residual grad = Function ( name = \"grad\" , grid = geometry . model . grid ) residual = Receiver ( name = 'rec' , grid = geometry . model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) # Predicted data and residual d_pred , u0 = solver . forward ( vp = geometry . model . vp , save = True )[ 0 : 2 ] residual . data [:] = d_pred . data [:] - d_obs . resample ( geometry . dt ) . data [:][ 0 : d_pred . data . shape [ 0 ], :] # Function value and gradient fval = . 5 * np . linalg . norm ( residual . data . flatten ()) ** 2 solver . gradient ( rec = residual , u = u0 , vp = geometry . model . vp , grad = grad ) # Convert to numpy array and remove absorbing boundaries grad_crop = np . array ( grad . data [:])[ geometry . model . nbl : - geometry . model . nbl , geometry . model . nbl : - geometry . model . nbl ] return fval , grad_crop As for the serial modeling function, we can call fwi_objective_single_shot with a geometry structure containing a single source location and a single observed shot record. Since we are interested in evaluating this function for multiple sources in parallel, we follow the strategy from our forward modeling example and implement a parallel loop over all shots, in which we create a task for each shot location. As before, we use Dask to create one task per shot location and evaluate the single-shot FWI objective function for each source. We wait for all computations to finish via wait(futures) and then we sum the function values and gradients from all workers. # Parallel FWI objective function def fwi_objective_multi_shots ( geometry , d_obs ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i ,:], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial FWI objective function for each shot location futures . append ( client . submit ( fwi_objective_single_shot , geometry_i , d_obs [ i ])) # Wait for all workers to finish and collect function values and gradients wait ( futures ) fval = 0.0 grad = np . zeros ( geometry . model . shape ) for i in range ( geometry . nsrc ): fval += futures [ i ] . result ()[ 0 ] grad += futures [ i ] . result ()[ 1 ] return fval , grad We can compute a single gradient of the FWI objective function for all shots by passing the geometry structure with the initial model to the objective function, as well as the observed data we generated earlier. # Compute FWI gradient for 5 shots f , g = fwi_objective_multi_shots ( geometry0 , d_obs ) The physical units of the gradient are s^2/km^2 s^2/km^2 , which means our gradient is an update of the squared slowness, rather than of the velocity. from examples.seismic import plot_image # Plot g plot_image ( g . reshape ( model1 . shape ), vmin =- 6e3 , vmax = 6e3 , cmap = \"cividis\" ) FWI with SciPy's L-BFGS With our parallel FWI objective function in place, we can in principle implement a wide range of gradient-based optimization algorithms for FWI, such as (stochastic) gradient descent or the nonlinear conjugate gradient method. However, many optimization algorithms, especially second order methods or algorithms for constrained optimization, are far from trivial to implement correctly from scratch. Luckily, many optimization libraries exist that we can adapt for our purposes. Here, we demonstrate how we can interface the scipy optimize package to run FWI with a limited-memory Quasi-Newton method. The scipy optimize package was not specifically designed for FWI, but this does not matter, as the library accepts any Python function that can be evaluated for a current model iterate x and returns the function value and gradient: f, g = objective_function(x, args) where f is function value and g is a one-dimensional numpy array of type float64 . Our parallel FWI function does not take the current model as an input argument, but instead expects a geometry structure and the observed data. Therefore, we have to write a little wrapper function called loss , which provides the input argument structure that is expected by scipy.optimize . The function takes the current model iteratve x (in squared slowness) as the first input argument and overwrites the current velocity in geometry with x . The gradient that is returned to scipy.optimize is converted to a numpy array of the required type ( float64 ). # Wrapper for scipy optimizer: x is current model in squared slowness [s^2/km^2] def loss ( x , geometry , d_obs ): # Convert x to velocity v_curr = 1.0 / np . sqrt ( x . reshape ( geometry . model . shape )) # Overwrite current velocity in geometry (don't update boundary region) geometry . model . update ( 'vp' , v_curr . reshape ( geometry . model . shape )) # Evaluate objective function fval , grad = fwi_objective_multi_shots ( geometry , d_obs ) return fval , grad . flatten () . astype ( np . float64 ) # scipy expects double precision vector The scipy.optimize function also takes an optional callback function as an input argument, which can be used to keep track of the model error as a function of the iteration number. The callback function takes the current model iterate xk as the only input argument and computes the \\ell_2 \\ell_2 -misfit with the true model m : # Callback to track model error model_error = [] def fwi_callback ( xk ): vp = model1 . vp . data [ model1 . nbl : - model1 . nbl , model1 . nbl : - model1 . nbl ] m = 1.0 / ( vp . reshape ( - 1 ) . astype ( np . float64 )) ** 2 model_error . append ( np . linalg . norm (( xk - m ) / m )) The final preparation step before we can run our example, is the definition of box constraints for the velocity. At each iteration, the optimizer will project the current model iterate onto a feasible set of velocites as defined by the lower and upper bounds vmin and vmax . Box contraints allow us to prevent velocities from taking negative values or values that are too small or large for the stability criteria of our modeling stepping scheme. We define the box constraints for the velocity in km/s km/s and then convert them to squared slownesses. Furthermore, we define our initial guess m0 : # Box contraints vmin = 1.4 # do not allow velocities slower than water vmax = 4.0 bounds = [( 1.0 / vmax ** 2 , 1.0 / vmin ** 2 ) for _ in range ( np . prod ( model0 . shape ))] # in [s^2/km^2] # Initial guess v0 = model0 . vp . data [ model0 . nbl : - model0 . nbl , model0 . nbl : - model0 . nbl ] m0 = 1.0 / ( v0 . reshape ( - 1 ) . astype ( np . float64 )) ** 2 Finally, we run our 2D FWI example by calling the optimize.minimize function. The first input argument is the function to be minimized, which is our loss function. The second input argument is the starting value, which in our case is our initial model in squared slowness. The third input argument ( args ) are the arguments that are passed to the loss function other than x . For this example we use the L-BFGS algorithm, a limited-memory Quasi-Newton algorithm which builds up an approximation of the (inverse) hessian as we iterate. As our loss function returns the analytically computed gradient (as opposed to a numerically approximated gradient), we set the argument jac=True . Furthermore, we pass our callback function, box constraints and the maximum number of iterations (in this case 5) to the optimizer. from scipy import optimize # FWI with L-BFGS ftol = 0.1 maxiter = 5 result = optimize . minimize ( loss , m0 , args = ( geometry0 , d_obs ), method = 'L-BFGS-B' , jac = True , callback = fwi_callback , bounds = bounds , options = { 'ftol' : ftol , 'maxiter' : maxiter , 'disp' : True }) Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s # Check termination criteria assert np . isclose ( result [ 'fun' ], ftol ) or result [ 'nit' ] == maxiter After either the maximum iteration number is reached or we find the minimum of the objective function within some tolerance level ftol , the optimizer returns a dictionary with the results and some additional information. We convert the result back to the velocity in km/s km/s and compare it to the true model: # Plot FWI result vp = 1.0 / np . sqrt ( result [ 'x' ] . reshape ( model1 . shape )) plot_image ( model1 . vp . data [ model1 . nbl : - model1 . nbl , model1 . nbl : - model1 . nbl ], vmin = 2.4 , vmax = 2.8 , cmap = \"cividis\" ) plot_image ( vp , vmin = 2.4 , vmax = 2.8 , cmap = \"cividis\" ) Looking at the model error as a function of the iteration number, we find that the error decays monotonically, as we would expect. import matplotlib.pyplot as plt # Plot model error plt . plot ( range ( 1 , maxiter + 1 ), model_error ); plt . xlabel ( 'Iteration number' ); plt . ylabel ( 'L2-model error' ) plt . show () Next steps In our current example, the master process keeps all shot records in memory and distributes the data to the workers in the parallel pool. This works perfectly fine for 2D and even small 3D examples, but quickly becomes infeasible for large-scale data sets. Therefore, an extension of our current code should include the following steps if we want to scale things up in the future: Write shot records directly to disk on each worker and return a file pointer back to the master process. Avoid sending the velocity model to the workers and read the model directly onto each worker. Include optimal checkpointing or domain-decomposition to address the memory bottleneck in the gradient computations. For scaling Devito to industry-scale problems and being able to work on data sets in the range of multiple terabytes, it is furthermore necessary to have a fast SEG-Y reader that is able to scan through large data volumes and efficiently access blocks of data such as single shot records. Furthermore, we need the SEG-Y reader to be able to interact with Devito and automatically set up geometry objects from the SEG-Y headers. For this purpose, please check out the Julia Devito Inversion framework (JUDI) , an extension built on top of Devito in the Julia programming language. JUDI consists on an abstract linear algebra framework and an interface to a fast and parallel SEG-Y reader called SEGYIO.jl , making it possible to: Scan large-scale data sets and create look-up tables from which shot records can be directly accessed through their byte locations (no need to loop over traces or read full files). Use look-up tables to automatically set up Devito objects with source and receiver coordinates. Work with out-of-core data containers that only read the data into memory when it is used for computations. You can find a full FWI example of the 3D Overthrust model using a 1.1 TB large data set on JUDI's Github page .","title":"Parallel acoustic FWI with Dask"},{"location":"tutorials/04_dask/#04-full-waveform-inversion-with-devito-and-dask","text":"","title":"04 - Full Waveform Inversion with Devito and Dask"},{"location":"tutorials/04_dask/#introduction","text":"In this tutorial, we will build on the previous FWI tutorial and implement parallel versions of both forward modeling and FWI objective functions. Furthermore, we will show how our parallel FWI function can be passed to black-box third party optimization libraries, such as SciPy's optimize package, to access sophisticated optimization algorithms without having to implement them from scratch! To implement parallel versions of forward modeling and FWI, we will use Dask , a Python library for distributed computing based on parallel data structures and task-based programming. As computing multiple seismic shot records or gradients for subsequent source locations is an embarassingly parallel process, we will use Dask to dynamically distribute our workload to a pool of available workers and afterwards collect the results. The first part of this tutorial closely follows tutorial 3 and consists of reading the velocity model and setting up the acquisition geometry. Subsequently, we will implement serial versions of forward modeling and FWI objective functions and then show how we can use Dask to implement parallel versions of these functions. Finally, we will show how to write a wrapper that lets us pass our objective function to scipy's optimize package and how to run a small 2D FWI example using a limited-memory Quasi-Newton method.","title":"Introduction"},{"location":"tutorials/04_dask/#gpu-aware-dask","text":"The default method to start a Dask Cluster is LocalCluster(...). This method enables CPU worker threads, but it shares one GPU for all workers. To enable Dask to use multi-GPU, or a GPU per Dask worker, the method to start a Dask Cluster needs to be changed to LocalCUDACluster. This Dask modification is pulled from the Rapids.ai open source project. Reference: https://github.com/rapidsai/dask-cuda USE_GPU_AWARE_DASK = False","title":"GPU Aware Dask"},{"location":"tutorials/04_dask/#set-up-velocity-models","text":"As before, we start by reading the true (i.e. unknown) velocity model, as well as the starting model for FWI. For our example, we once again use the 2D Camembert model with a transmission acquisition set up, which involves having sources on one side of the model and receivers on the other side. In reality, we obvisouly cannot know what the true velocity is, but here we use the true model to generate our own data (inverse crime alert!) and to compare it to our FWI result. from examples.seismic import demo_model # Set up velocity model shape = ( 101 , 101 ) # Number of grid points (nx, nz). spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km. origin = ( 0 , 0 ) # Need origin to define relative source and receiver locations. nbl = 40 # True model model1 = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = nbl ) # Initial model model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = nbl , grid = model1 . grid ) Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s","title":"Set up velocity models"},{"location":"tutorials/04_dask/#acquisition-geometry","text":"For the acquisition geometry, we use the same setup as in tutorial 3 and position 5 source position on one side of the model, and an array of 101 receivers on the other side. Note that now our source coordinate array ( src_coordinates ) is a 5 x 2 array, containing the shot locations of all 5 source experiments. After defining the source/receiver coordinates, we set up individual geometry objects for both the observed data (using model ) and the predicted data (using model0 ). from examples.seismic import AcquisitionGeometry import numpy as np # Set up acquisiton geometry t0 = 0. tn = 1000. f0 = 0.010 # Set up source geometry, but define 5 sources instead of just one. nsources = 5 src_coordinates = np . empty (( nsources , 2 )) src_coordinates [:, 1 ] = np . linspace ( 0 , model1 . domain_size [ 0 ], num = nsources ) src_coordinates [:, 0 ] = 20. # Source depth is 20m # Initialize receivers for synthetic and imaging data nreceivers = 101 rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( spacing [ 0 ], model1 . domain_size [ 0 ] - spacing [ 0 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Receiver depth # Set up geometry objects for observed and predicted data geometry1 = AcquisitionGeometry ( model1 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) geometry0 = AcquisitionGeometry ( model0 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' )","title":"Acquisition geometry"},{"location":"tutorials/04_dask/#forward-modeling","text":"Before diving into FWI, we will start with forward modeling and show how we can use Dask to implement a parallel wrapper around a serial modeling function to compute seismic shot records for multiple source locations in parallel. First, we implement a forward modeling function for a single shot, which takes a geometry data structure as the only mandatory input argument. This function assumes that the geometry structure only contains a single source location. To solve the wave equation for the current shot location and model as specified in geometry , we use the AcousticSolver from previous tutorials, which is an abstract layer built on top of (generic) Devito objects. AcousticSolver contains Devito implementations of forward and adjoint wave equations, as well as Jacobians as specified in tutorials 1 and 2, so we don't have to re-implement these PDEs here. from examples.seismic.acoustic import AcousticWaveSolver # Serial modeling function def forward_modeling_single_shot ( geometry , save = False , dt = 4.0 ): solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) d_obs , u0 = solver . forward ( vp = geometry . model . vp , save = save )[ 0 : 2 ] return d_obs . resample ( dt ), u0 With our modeling function for a single shot record in place, we now implement our parallel version of our modeling function, which consists of a loop over all source locations. As the geometry object in forward_modeling_single_shot expects only a single source location, we set up a new geometry structure for the i-th source location to pass to our modeling function. However, rather than simpling calling the modeling function for single shots, we tell Dask to create a task for each source location and to distribute them to the available parallel workers. Dask returns a remote reference to the result on each worker called future . The wait statement tells our function to wait for all tasks to finish their computations, after which we collect the modeled shot records from the workers. # Parallel modeling function def forward_modeling_multi_shots ( geometry , save = False , dt = 4.0 ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i ,:], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial modeling function for each index futures . append ( client . submit ( forward_modeling_single_shot , geometry_i , save = save , dt = dt )) # Wait for all workers to finish and collect shots wait ( futures ) shots = [] for i in range ( geometry . nsrc ): shots . append ( futures [ i ] . result ()[ 0 ]) return shots We can use this parallel modeling function to generate our own observed data set, which we will subsequently use for our FWI example. In reality, we would instead read our observed data from a SEG-Y file. To compute the data in parallel, we launch a pool of workers on our local machine and then call the parallel modeling function: from distributed import Client , wait # Start Dask cluster if USE_GPU_AWARE_DASK : from dask_cuda import LocalCUDACluster cluster = LocalCUDACluster ( threads_per_worker = 1 , death_timeout = 600 ) else : from distributed import LocalCluster cluster = LocalCluster ( n_workers = nsources , death_timeout = 600 ) client = Client ( cluster ) # Compute observed data in parallel (inverse crime). In real life we would read the SEG-Y data here. d_obs = forward_modeling_multi_shots ( geometry1 , save = False ) The variable d_obs is a list of the 5 shots records and we can plot one of the shot records as follows: from examples.seismic import plot_shotrecord # Plot shot no. 3 of 5 plot_shotrecord ( d_obs [ 2 ] . data , model1 , t0 , tn )","title":"Forward modeling"},{"location":"tutorials/04_dask/#parallel-full-waveform-inversion","text":"Now that we know how to use Dask to implement a parallel loop around a (serial) modeling function for a single shot, we can apply the same concept to an FWI objective function, which computes the FWI function value and gradient for a given geometry and observed shot record. This function follows largely the structure in tutorial 3 and involves computing the predicted data and backpropagating the residual to compute the gradient. As we do not want to update the velocity in the area of the absorbing boundaries, we only return the gradient on the (original) physical grid. from devito import Function from examples.seismic import Receiver # Serial FWI objective function def fwi_objective_single_shot ( geometry , d_obs ): # Devito objects for gradient and data residual grad = Function ( name = \"grad\" , grid = geometry . model . grid ) residual = Receiver ( name = 'rec' , grid = geometry . model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) # Predicted data and residual d_pred , u0 = solver . forward ( vp = geometry . model . vp , save = True )[ 0 : 2 ] residual . data [:] = d_pred . data [:] - d_obs . resample ( geometry . dt ) . data [:][ 0 : d_pred . data . shape [ 0 ], :] # Function value and gradient fval = . 5 * np . linalg . norm ( residual . data . flatten ()) ** 2 solver . gradient ( rec = residual , u = u0 , vp = geometry . model . vp , grad = grad ) # Convert to numpy array and remove absorbing boundaries grad_crop = np . array ( grad . data [:])[ geometry . model . nbl : - geometry . model . nbl , geometry . model . nbl : - geometry . model . nbl ] return fval , grad_crop As for the serial modeling function, we can call fwi_objective_single_shot with a geometry structure containing a single source location and a single observed shot record. Since we are interested in evaluating this function for multiple sources in parallel, we follow the strategy from our forward modeling example and implement a parallel loop over all shots, in which we create a task for each shot location. As before, we use Dask to create one task per shot location and evaluate the single-shot FWI objective function for each source. We wait for all computations to finish via wait(futures) and then we sum the function values and gradients from all workers. # Parallel FWI objective function def fwi_objective_multi_shots ( geometry , d_obs ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i ,:], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial FWI objective function for each shot location futures . append ( client . submit ( fwi_objective_single_shot , geometry_i , d_obs [ i ])) # Wait for all workers to finish and collect function values and gradients wait ( futures ) fval = 0.0 grad = np . zeros ( geometry . model . shape ) for i in range ( geometry . nsrc ): fval += futures [ i ] . result ()[ 0 ] grad += futures [ i ] . result ()[ 1 ] return fval , grad We can compute a single gradient of the FWI objective function for all shots by passing the geometry structure with the initial model to the objective function, as well as the observed data we generated earlier. # Compute FWI gradient for 5 shots f , g = fwi_objective_multi_shots ( geometry0 , d_obs ) The physical units of the gradient are s^2/km^2 s^2/km^2 , which means our gradient is an update of the squared slowness, rather than of the velocity. from examples.seismic import plot_image # Plot g plot_image ( g . reshape ( model1 . shape ), vmin =- 6e3 , vmax = 6e3 , cmap = \"cividis\" )","title":"Parallel Full-Waveform Inversion"},{"location":"tutorials/04_dask/#fwi-with-scipys-l-bfgs","text":"With our parallel FWI objective function in place, we can in principle implement a wide range of gradient-based optimization algorithms for FWI, such as (stochastic) gradient descent or the nonlinear conjugate gradient method. However, many optimization algorithms, especially second order methods or algorithms for constrained optimization, are far from trivial to implement correctly from scratch. Luckily, many optimization libraries exist that we can adapt for our purposes. Here, we demonstrate how we can interface the scipy optimize package to run FWI with a limited-memory Quasi-Newton method. The scipy optimize package was not specifically designed for FWI, but this does not matter, as the library accepts any Python function that can be evaluated for a current model iterate x and returns the function value and gradient: f, g = objective_function(x, args) where f is function value and g is a one-dimensional numpy array of type float64 . Our parallel FWI function does not take the current model as an input argument, but instead expects a geometry structure and the observed data. Therefore, we have to write a little wrapper function called loss , which provides the input argument structure that is expected by scipy.optimize . The function takes the current model iteratve x (in squared slowness) as the first input argument and overwrites the current velocity in geometry with x . The gradient that is returned to scipy.optimize is converted to a numpy array of the required type ( float64 ). # Wrapper for scipy optimizer: x is current model in squared slowness [s^2/km^2] def loss ( x , geometry , d_obs ): # Convert x to velocity v_curr = 1.0 / np . sqrt ( x . reshape ( geometry . model . shape )) # Overwrite current velocity in geometry (don't update boundary region) geometry . model . update ( 'vp' , v_curr . reshape ( geometry . model . shape )) # Evaluate objective function fval , grad = fwi_objective_multi_shots ( geometry , d_obs ) return fval , grad . flatten () . astype ( np . float64 ) # scipy expects double precision vector The scipy.optimize function also takes an optional callback function as an input argument, which can be used to keep track of the model error as a function of the iteration number. The callback function takes the current model iterate xk as the only input argument and computes the \\ell_2 \\ell_2 -misfit with the true model m : # Callback to track model error model_error = [] def fwi_callback ( xk ): vp = model1 . vp . data [ model1 . nbl : - model1 . nbl , model1 . nbl : - model1 . nbl ] m = 1.0 / ( vp . reshape ( - 1 ) . astype ( np . float64 )) ** 2 model_error . append ( np . linalg . norm (( xk - m ) / m )) The final preparation step before we can run our example, is the definition of box constraints for the velocity. At each iteration, the optimizer will project the current model iterate onto a feasible set of velocites as defined by the lower and upper bounds vmin and vmax . Box contraints allow us to prevent velocities from taking negative values or values that are too small or large for the stability criteria of our modeling stepping scheme. We define the box constraints for the velocity in km/s km/s and then convert them to squared slownesses. Furthermore, we define our initial guess m0 : # Box contraints vmin = 1.4 # do not allow velocities slower than water vmax = 4.0 bounds = [( 1.0 / vmax ** 2 , 1.0 / vmin ** 2 ) for _ in range ( np . prod ( model0 . shape ))] # in [s^2/km^2] # Initial guess v0 = model0 . vp . data [ model0 . nbl : - model0 . nbl , model0 . nbl : - model0 . nbl ] m0 = 1.0 / ( v0 . reshape ( - 1 ) . astype ( np . float64 )) ** 2 Finally, we run our 2D FWI example by calling the optimize.minimize function. The first input argument is the function to be minimized, which is our loss function. The second input argument is the starting value, which in our case is our initial model in squared slowness. The third input argument ( args ) are the arguments that are passed to the loss function other than x . For this example we use the L-BFGS algorithm, a limited-memory Quasi-Newton algorithm which builds up an approximation of the (inverse) hessian as we iterate. As our loss function returns the analytically computed gradient (as opposed to a numerically approximated gradient), we set the argument jac=True . Furthermore, we pass our callback function, box constraints and the maximum number of iterations (in this case 5) to the optimizer. from scipy import optimize # FWI with L-BFGS ftol = 0.1 maxiter = 5 result = optimize . minimize ( loss , m0 , args = ( geometry0 , d_obs ), method = 'L-BFGS-B' , jac = True , callback = fwi_callback , bounds = bounds , options = { 'ftol' : ftol , 'maxiter' : maxiter , 'disp' : True }) Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s # Check termination criteria assert np . isclose ( result [ 'fun' ], ftol ) or result [ 'nit' ] == maxiter After either the maximum iteration number is reached or we find the minimum of the objective function within some tolerance level ftol , the optimizer returns a dictionary with the results and some additional information. We convert the result back to the velocity in km/s km/s and compare it to the true model: # Plot FWI result vp = 1.0 / np . sqrt ( result [ 'x' ] . reshape ( model1 . shape )) plot_image ( model1 . vp . data [ model1 . nbl : - model1 . nbl , model1 . nbl : - model1 . nbl ], vmin = 2.4 , vmax = 2.8 , cmap = \"cividis\" ) plot_image ( vp , vmin = 2.4 , vmax = 2.8 , cmap = \"cividis\" ) Looking at the model error as a function of the iteration number, we find that the error decays monotonically, as we would expect. import matplotlib.pyplot as plt # Plot model error plt . plot ( range ( 1 , maxiter + 1 ), model_error ); plt . xlabel ( 'Iteration number' ); plt . ylabel ( 'L2-model error' ) plt . show ()","title":"FWI with SciPy's L-BFGS"},{"location":"tutorials/04_dask/#next-steps","text":"In our current example, the master process keeps all shot records in memory and distributes the data to the workers in the parallel pool. This works perfectly fine for 2D and even small 3D examples, but quickly becomes infeasible for large-scale data sets. Therefore, an extension of our current code should include the following steps if we want to scale things up in the future: Write shot records directly to disk on each worker and return a file pointer back to the master process. Avoid sending the velocity model to the workers and read the model directly onto each worker. Include optimal checkpointing or domain-decomposition to address the memory bottleneck in the gradient computations. For scaling Devito to industry-scale problems and being able to work on data sets in the range of multiple terabytes, it is furthermore necessary to have a fast SEG-Y reader that is able to scan through large data volumes and efficiently access blocks of data such as single shot records. Furthermore, we need the SEG-Y reader to be able to interact with Devito and automatically set up geometry objects from the SEG-Y headers. For this purpose, please check out the Julia Devito Inversion framework (JUDI) , an extension built on top of Devito in the Julia programming language. JUDI consists on an abstract linear algebra framework and an interface to a fast and parallel SEG-Y reader called SEGYIO.jl , making it possible to: Scan large-scale data sets and create look-up tables from which shot records can be directly accessed through their byte locations (no need to loop over traces or read full files). Use look-up tables to automatically set up Devito objects with source and receiver coordinates. Work with out-of-core data containers that only read the data into memory when it is used for computations. You can find a full FWI example of the 3D Overthrust model using a 1.1 TB large data set on JUDI's Github page .","title":"Next steps"},{"location":"tutorials/05_staggered_acoustic/","text":"from devito import * from examples.seismic.source import DGaussSource , TimeAxis from examples.seismic import plot_image import numpy as np from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Initial grid: 1km x 1km, with spacing 100m extent = ( 2000. , 2000. ) shape = ( 81 , 81 ) x = SpaceDimension ( name = 'x' , spacing = Constant ( name = 'h_x' , value = extent [ 0 ] / ( shape [ 0 ] - 1 ))) z = SpaceDimension ( name = 'z' , spacing = Constant ( name = 'h_z' , value = extent [ 1 ] / ( shape [ 1 ] - 1 ))) grid = Grid ( extent = extent , shape = shape , dimensions = ( x , z )) # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 200. dt = 1e2 * ( 1. / np . sqrt ( 2. )) / 60. time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = DGaussSource ( name = 'src' , grid = grid , f0 = 0.01 , time_range = time_range , a = 0.004 ) src . coordinates . data [:] = [ 1000. , 1000. ] #NBVAL_SKIP src . show () # Now we create the velocity and pressure fields p = TimeFunction ( name = 'p' , grid = grid , staggered = NODE , space_order = 2 , time_order = 1 ) v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = 2 , time_order = 1 ) from devito.finite_differences.operators import div , grad t = grid . stepping_dim time = grid . time_dim # We need some initial conditions V_p = 4.0 density = 1. ro = 1 / density * dt l2m = V_p * V_p * density * dt # The source injection term src_p = src . inject ( field = p . forward , expr = src ) # 2nd order acoustic according to fdelmoc u_v_2 = Eq ( v . forward , v + ro * grad ( p )) u_p_2 = Eq ( p . forward , p + l2m * div ( v . forward )) u_v_2 \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial x} p{\\left(t,x,z \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial z} p{\\left(t,x,z \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial x} p{\\left(t,x,z \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial z} p{\\left(t,x,z \\right)}\\end{matrix}\\right] u_p_2 \\displaystyle p{\\left(t + dt,x,z \\right)} = p{\\left(t,x,z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial z} \\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)} \\displaystyle p{\\left(t + dt,x,z \\right)} = p{\\left(t,x,z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial z} \\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)} op_2 = Operator ([ u_v_2 , u_p_2 ] + src_p ) #NBVAL_IGNORE_OUTPUT # Propagate the source op_2 ( time = src . time_range . num - 1 ) Operator `Kernel` run in 0.04 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ]) plot_image ( v [ 1 ] . data [ 0 ]) plot_image ( p . data [ 0 ]) norm_p = norm ( p ) assert np . isclose ( norm_p , . 35098 , atol = 1e-4 , rtol = 0 ) # # 4th order acoustic according to fdelmoc # # Now we create the velocity and pressure fields p4 = TimeFunction ( name = 'p' , grid = grid , staggered = NODE , space_order = 4 , time_order = 1 ) v4 = VectorTimeFunction ( name = 'v' , grid = grid , space_order = 4 , time_order = 1 ) u_v_4 = Eq ( v4 . forward , v4 + ro * grad ( p4 )) u_p_4 = Eq ( p4 . forward , p4 + l2m * div ( v4 . forward )) #NBVAL_IGNORE_OUTPUT op_4 = Operator ([ u_v_4 , u_p_4 ] + src_p ) # Propagate the source op_4 ( time = src . time_range . num - 1 ) Operator `Kernel` run in 0.01 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v4 [ 0 ] . data [ - 1 ]) plot_image ( v4 [ 1 ] . data [ - 1 ]) plot_image ( p4 . data [ - 1 ]) norm_p = norm ( p ) assert np . isclose ( norm_p , . 35098 , atol = 1e-4 , rtol = 0 )","title":"First order acoustic modeling"},{"location":"tutorials/06_elastic/","text":"Elastic wave equation implementation on a staggered grid This is a first attempt at implemenenting the elastic wave equation as described in: [1] Jean Virieux (1986). \u201dP-SV wave propagation in heterogeneous media: Velocity\u2010stress finite\u2010difference method.\u201d GEOPHYSICS, 51(4), 889-901. https://doi.org/10.1190/1.1442147 The current version actually attempts to mirror the FDELMODC implementation by Jan Thorbecke: [2] https://janth.home.xs4all.nl/Software/fdelmodcManual.pdf Explosive source We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from examples.seismic.source import WaveletSource , RickerSource , GaborSource , TimeAxis from examples.seismic import plot_image import numpy as np from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Initial grid: 1km x 1km, with spacing 100m extent = ( 1500. , 1500. ) shape = ( 201 , 201 ) x = SpaceDimension ( name = 'x' , spacing = Constant ( name = 'h_x' , value = extent [ 0 ] / ( shape [ 0 ] - 1 ))) z = SpaceDimension ( name = 'z' , spacing = Constant ( name = 'h_z' , value = extent [ 1 ] / ( shape [ 1 ] - 1 ))) grid = Grid ( extent = extent , shape = shape , dimensions = ( x , z )) class DGaussSource ( WaveletSource ): def wavelet ( self , f0 , t ): a = 0.004 return - 2. * a * ( t - 1 / f0 ) * np . exp ( - a * ( t - 1 / f0 ) ** 2 ) # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 300. dt = ( 10. / np . sqrt ( 2. )) / 6. time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = grid , f0 = 0.01 , time_range = time_range ) src . coordinates . data [:] = [ 750. , 750. ] #NBVAL_SKIP src . show () # Now we create the velocity and pressure fields so = 2 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # Now let's try and create the staggered updates t = grid . stepping_dim time = grid . time_dim # We need some initial conditions V_p = 2.0 V_s = 1.0 density = 1.8 # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # Thorbecke's parameter notation cp2 = V_p * V_p cs2 = V_s * V_s ro = 1 / density mu = cs2 * density l = ( cp2 * density - 2 * mu ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + dt * l * diag ( div ( v . forward )) + dt * mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT op () Operator `Kernel` run in 1.09 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], vmin =-. 5 * 1e-1 , vmax =. 5 * 1e-1 , cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.6285093 , atol = 1e-4 , rtol = 0 ) # Now that looks pretty! But let's do it again with a higher order... so = 12 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) #NBVAL_IGNORE_OUTPUT v [ 0 ] . data . fill ( 0. ) v [ 1 ] . data . fill ( 0. ) tau [ 0 , 0 ] . data . fill ( 0. ) tau [ 0 , 1 ] . data . fill ( 0. ) tau [ 1 , 1 ] . data . fill ( 0. ) op () Operator `Kernel` run in 0.50 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.736816932 , atol = 1e-4 , rtol = 0 )","title":"Elastic modeling with constant parameters"},{"location":"tutorials/06_elastic/#elastic-wave-equation-implementation-on-a-staggered-grid","text":"This is a first attempt at implemenenting the elastic wave equation as described in: [1] Jean Virieux (1986). \u201dP-SV wave propagation in heterogeneous media: Velocity\u2010stress finite\u2010difference method.\u201d GEOPHYSICS, 51(4), 889-901. https://doi.org/10.1190/1.1442147 The current version actually attempts to mirror the FDELMODC implementation by Jan Thorbecke: [2] https://janth.home.xs4all.nl/Software/fdelmodcManual.pdf","title":"Elastic wave equation implementation on a staggered grid"},{"location":"tutorials/06_elastic/#explosive-source","text":"We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from examples.seismic.source import WaveletSource , RickerSource , GaborSource , TimeAxis from examples.seismic import plot_image import numpy as np from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Initial grid: 1km x 1km, with spacing 100m extent = ( 1500. , 1500. ) shape = ( 201 , 201 ) x = SpaceDimension ( name = 'x' , spacing = Constant ( name = 'h_x' , value = extent [ 0 ] / ( shape [ 0 ] - 1 ))) z = SpaceDimension ( name = 'z' , spacing = Constant ( name = 'h_z' , value = extent [ 1 ] / ( shape [ 1 ] - 1 ))) grid = Grid ( extent = extent , shape = shape , dimensions = ( x , z )) class DGaussSource ( WaveletSource ): def wavelet ( self , f0 , t ): a = 0.004 return - 2. * a * ( t - 1 / f0 ) * np . exp ( - a * ( t - 1 / f0 ) ** 2 ) # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 300. dt = ( 10. / np . sqrt ( 2. )) / 6. time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = grid , f0 = 0.01 , time_range = time_range ) src . coordinates . data [:] = [ 750. , 750. ] #NBVAL_SKIP src . show () # Now we create the velocity and pressure fields so = 2 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # Now let's try and create the staggered updates t = grid . stepping_dim time = grid . time_dim # We need some initial conditions V_p = 2.0 V_s = 1.0 density = 1.8 # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # Thorbecke's parameter notation cp2 = V_p * V_p cs2 = V_s * V_s ro = 1 / density mu = cs2 * density l = ( cp2 * density - 2 * mu ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + dt * l * diag ( div ( v . forward )) + dt * mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT op () Operator `Kernel` run in 1.09 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], vmin =-. 5 * 1e-1 , vmax =. 5 * 1e-1 , cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.6285093 , atol = 1e-4 , rtol = 0 ) # Now that looks pretty! But let's do it again with a higher order... so = 12 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) #NBVAL_IGNORE_OUTPUT v [ 0 ] . data . fill ( 0. ) v [ 1 ] . data . fill ( 0. ) tau [ 0 , 0 ] . data . fill ( 0. ) tau [ 0 , 1 ] . data . fill ( 0. ) tau [ 1 , 1 ] . data . fill ( 0. ) op () Operator `Kernel` run in 0.50 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], vmin =-. 5 * 1e-2 , vmax =. 5 * 1e-2 , cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.736816932 , atol = 1e-4 , rtol = 0 )","title":"Explosive source"},{"location":"tutorials/07_elastic_varying_parameters/","text":"Elastic wave equation implementation on a staggered grid This second elastic tutorial extends the previous constant parameter implementation to varying parameters (Lame parameters) and takes advantage of the Tensorial capabilities of Devito to write the elastic wave equation following its mathematical definition. The staggering is automated via the TensorFunction API. Explosive source We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from examples.seismic.source import RickerSource , Receiver , TimeAxis from examples.seismic import plot_image , demo_model import numpy as np import matplotlib.pyplot as plt from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Some ploting setup plt . rc ( 'text' , usetex = True ) plt . rc ( 'font' , family = 'serif' ) plt . rc ( 'xtick' , labelsize = 20 ) plt . rc ( 'ytick' , labelsize = 20 ) #NBVAL_IGNORE_OUTPUT # Initial grid: 3km x 3km, with spacing 10m nlayers = 5 so = 8 model = demo_model ( preset = 'layers-elastic' , nlayers = nlayers , shape = ( 301 , 301 ), spacing = ( 10. , 10. ), space_order = so ) Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s #NBVAL_SKIP aspect_ratio = model . shape [ 0 ] / model . shape [ 1 ] plt_options_model = { 'cmap' : 'jet' , 'extent' : [ model . origin [ 0 ], model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 3 , ncols = 1 , figsize = ( 15 , 15 )) slices = [ slice ( model . nbl , - model . nbl ), slice ( model . nbl , - model . nbl )] img1 = ax [ 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 1.5 ** 2 , vmax = 4.0 ** 2 , ** plt_options_model ) fig . colorbar ( img1 , ax = ax [ 0 ]) ax [ 0 ] . set_title ( r \"First Lam\\'e parameter $\\lambda$\" , fontsize = 20 ) ax [ 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 ] . set_aspect ( 'auto' ) img2 = ax [ 1 ] . imshow ( np . transpose ( model . mu . data [ slices ]), vmin = 0 , vmax = 15 , ** plt_options_model ) fig . colorbar ( img2 , ax = ax [ 1 ]) ax [ 1 ] . set_title ( r \"Shear modulus $\\mu$\" , fontsize = 20 ) ax [ 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 ] . set_aspect ( 'auto' ) img3 = ax [ 2 ] . imshow ( 1 / np . transpose ( model . b . data [ slices ]), vmin = 1.0 , vmax = 3.0 , ** plt_options_model ) fig . colorbar ( img3 , ax = ax [ 2 ]) ax [ 2 ] . set_title ( r \"Density $\\rho$\" , fontsize = 20 ) ax [ 2 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 2 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 2 ] . set_aspect ( 'auto' ) plt . tight_layout () # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 2000. dt = model . critical_dt time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = model . grid , f0 = 0.015 , time_range = time_range ) src . coordinates . data [:] = [ 1500. , 10. ] #NBVAL_SKIP src . show () Vectorial form While conventional litterature writes the elastic wave-equation as a set of scalar PDEs, the higher level representation comes from Hooke's law and the equation of motion and writes as: \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} and as tr(\\nabla v) tr(\\nabla v) is the divergence of v v we can reqrite it as \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} where v v is a vector valued function: v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) and the stress \\tau \\tau is a symmetric tensor valued function: \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} We show in the following how to setup the elastic wave-equation form Devito's high-level tensorial types. # Now we create the velocity and pressure fields x , z = model . grid . dimensions t = model . grid . stepping_dim time = model . grid . time_dim s = time . spacing v = VectorTimeFunction ( name = 'v' , grid = model . grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = model . grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = s * src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = s * src ) # The receiver nrec = 301 rec = Receiver ( name = \"rec\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec . coordinates . data [:, - 1 ] = 5. rec2 = Receiver ( name = \"rec2\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec2 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec2 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec3 = Receiver ( name = \"rec3\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec3 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec3 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec_term = rec . interpolate ( expr = tau [ 0 , 0 ] + tau [ 1 , 1 ]) rec_term += rec2 . interpolate ( expr = v [ 1 ]) rec_term += rec3 . interpolate ( expr = v [ 0 ]) #NBVAL_SKIP from examples.seismic import plot_velocity plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 10 , :]) plot_velocity ( model , source = src . coordinates . data , receiver = rec2 . coordinates . data [:: 10 , :]) # Now let's try and create the staggered updates # Lame parameters l , mu , ro = model . lam , model . mu , model . b # fdelmodc reference implementation u_v = Eq ( v . forward , model . damp * ( v + s * ro * div ( tau ))) u_t = Eq ( tau . forward , model . damp * ( tau + s * ( l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )))) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) v . _time_order \\displaystyle 1 \\displaystyle 1 ro . _eval_at ( v [ 0 ]) . evaluate \\displaystyle 0.5 b{\\left(x,y \\right)} + 0.5 b{\\left(x + h_{x},y \\right)} \\displaystyle 0.5 b{\\left(x,y \\right)} + 0.5 b{\\left(x + h_{x},y \\right)} We can now see that both the particle velocities and stress equations are vectorial and tensorial equations. Devito takes care of the discretization and staggered grids automatically for these types of object. u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) b{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) b{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) b{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) b{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] u_t \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.75 s PerformanceSummary([(PerfKey(name='section0', rank=None), PerfEntry(time=0.6419339999999998, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section1', rank=None), PerfEntry(time=0.02470599999999997, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section2', rank=None), PerfEntry(time=0.029838999999999952, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section3', rank=None), PerfEntry(time=0.026982999999999972, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section4', rank=None), PerfEntry(time=0.018986000000000017, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))]) #NBVAL_SKIP scale = . 5 * 1e-3 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau [ 0 , 0 ] . data [ 0 ][ slices ] + tau [ 1 , 1 ] . data [ 0 ][ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau [ 0 , 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () model . _physical_parameters ['damp', 'lam', 'mu', 'b'] #NBVAL_IGNORE_OUTPUT # Full run for the data op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.89 s PerformanceSummary([(PerfKey(name='section0', rank=None), PerfEntry(time=0.7226290000000001, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section1', rank=None), PerfEntry(time=0.048404, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section2', rank=None), PerfEntry(time=0.038736, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section3', rank=None), PerfEntry(time=0.05278400000000011, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section4', rank=None), PerfEntry(time=0.02340000000000003, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))]) # Data on a standard 2ms tim axis rec_plot = rec . resample ( num = 1001 ) rec2_plot = rec2 . resample ( num = 1001 ) rec3_plot = rec3 . resample ( num = 1001 ) scale_for_plot = np . diag ( np . linspace ( 1.0 , 2.5 , 1001 ) ** 2.0 ) #NBVAL_SKIP # Pressure (txx + tzz) data at sea surface extent = [ rec_plot . coordinates . data [ 0 , 0 ], rec_plot . coordinates . data [ - 1 , 0 ], 1e-3 * tn , t0 ] aspect = rec_plot . coordinates . data [ - 1 , 0 ] / ( 1e-3 * tn ) /. 5 plt . figure ( figsize = ( 15 , 15 )) plt . imshow ( np . dot ( scale_for_plot , rec_plot . data ), vmin =-. 01 , vmax =. 01 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') assert np . isclose ( norm ( rec ), 22.68 , atol = 0 , rtol = 1e-3 ) assert np . isclose ( norm ( rec2 ), 1.8299 , atol = 0 , rtol = 1e-3 ) assert np . isclose ( norm ( rec3 ), 3.8671 , atol = 0 , rtol = 1e-3 ) # Now that looks pretty! But let's do it again with a 2nd order in time so = 8 v2 = VectorTimeFunction ( name = 'v2' , grid = model . grid , space_order = so , time_order = 2 ) tau0 = TensorFunction ( name = 't0' , grid = model . grid , space_order = so ) # The source injection term src_xx = src . inject ( field = tau0 [ 0 , 0 ], expr = src . dt ) src_zz = src . inject ( field = tau0 [ 1 , 1 ], expr = src . dt ) s = model . grid . time_dim . spacing # fdelmodc reference implementation u_v = Eq ( v2 . forward , model . damp * ( 2 * v2 - model . damp * v2 . backward + s ** 2 * ro * div ( tau0 ))) u_t = Eq ( tau0 , model . damp * ( l * diag ( div ( v2 . forward )) + mu * ( grad ( v2 . forward ) + grad ( v2 . forward ) . T ))) # rec_term = rec.interpolate(expr=tau[0, 0] + tau[1, 1]) rec_term = rec2 . interpolate ( expr = v2 [ 0 ]) rec_term += rec3 . interpolate ( expr = v2 [ 1 ]) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.69 s PerformanceSummary([(PerfKey(name='section0', rank=None), PerfEntry(time=0.6159669999999996, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section1', rank=None), PerfEntry(time=0.0222800000000001, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section2', rank=None), PerfEntry(time=0.02982499999999997, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section3', rank=None), PerfEntry(time=0.018444000000000012, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))]) #NBVAL_SKIP scale = 1e-4 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v2 [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v2 [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau0 [ 0 , 0 ] . data [ slices ] + tau0 [ 1 , 1 ] . data [ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau0 [ 0 , 1 ] . data [ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () #NBVAL_IGNORE_OUTPUT op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.65 s PerformanceSummary([(PerfKey(name='section0', rank=None), PerfEntry(time=0.5681579999999993, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section1', rank=None), PerfEntry(time=0.02465800000000001, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section2', rank=None), PerfEntry(time=0.028956999999999948, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section3', rank=None), PerfEntry(time=0.018367000000000026, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))]) rec2_plot2 = rec2 . resample ( num = 1001 ) rec3_plot2 = rec3 . resample ( num = 1001 ) #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') assert np . isclose ( norm ( rec2 ), . 410652 , atol = 0 , rtol = 1e-3 ) assert np . isclose ( norm ( rec3 ), . 210861 , atol = 0 , rtol = 1e-3 )","title":"Elastic modeling with varying parameters"},{"location":"tutorials/07_elastic_varying_parameters/#elastic-wave-equation-implementation-on-a-staggered-grid","text":"This second elastic tutorial extends the previous constant parameter implementation to varying parameters (Lame parameters) and takes advantage of the Tensorial capabilities of Devito to write the elastic wave equation following its mathematical definition. The staggering is automated via the TensorFunction API.","title":"Elastic wave equation implementation on a staggered grid"},{"location":"tutorials/07_elastic_varying_parameters/#explosive-source","text":"We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from examples.seismic.source import RickerSource , Receiver , TimeAxis from examples.seismic import plot_image , demo_model import numpy as np import matplotlib.pyplot as plt from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Some ploting setup plt . rc ( 'text' , usetex = True ) plt . rc ( 'font' , family = 'serif' ) plt . rc ( 'xtick' , labelsize = 20 ) plt . rc ( 'ytick' , labelsize = 20 ) #NBVAL_IGNORE_OUTPUT # Initial grid: 3km x 3km, with spacing 10m nlayers = 5 so = 8 model = demo_model ( preset = 'layers-elastic' , nlayers = nlayers , shape = ( 301 , 301 ), spacing = ( 10. , 10. ), space_order = so ) Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s #NBVAL_SKIP aspect_ratio = model . shape [ 0 ] / model . shape [ 1 ] plt_options_model = { 'cmap' : 'jet' , 'extent' : [ model . origin [ 0 ], model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 3 , ncols = 1 , figsize = ( 15 , 15 )) slices = [ slice ( model . nbl , - model . nbl ), slice ( model . nbl , - model . nbl )] img1 = ax [ 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 1.5 ** 2 , vmax = 4.0 ** 2 , ** plt_options_model ) fig . colorbar ( img1 , ax = ax [ 0 ]) ax [ 0 ] . set_title ( r \"First Lam\\'e parameter $\\lambda$\" , fontsize = 20 ) ax [ 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 ] . set_aspect ( 'auto' ) img2 = ax [ 1 ] . imshow ( np . transpose ( model . mu . data [ slices ]), vmin = 0 , vmax = 15 , ** plt_options_model ) fig . colorbar ( img2 , ax = ax [ 1 ]) ax [ 1 ] . set_title ( r \"Shear modulus $\\mu$\" , fontsize = 20 ) ax [ 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 ] . set_aspect ( 'auto' ) img3 = ax [ 2 ] . imshow ( 1 / np . transpose ( model . b . data [ slices ]), vmin = 1.0 , vmax = 3.0 , ** plt_options_model ) fig . colorbar ( img3 , ax = ax [ 2 ]) ax [ 2 ] . set_title ( r \"Density $\\rho$\" , fontsize = 20 ) ax [ 2 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 2 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 2 ] . set_aspect ( 'auto' ) plt . tight_layout () # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 2000. dt = model . critical_dt time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = model . grid , f0 = 0.015 , time_range = time_range ) src . coordinates . data [:] = [ 1500. , 10. ] #NBVAL_SKIP src . show ()","title":"Explosive source"},{"location":"tutorials/07_elastic_varying_parameters/#vectorial-form","text":"While conventional litterature writes the elastic wave-equation as a set of scalar PDEs, the higher level representation comes from Hooke's law and the equation of motion and writes as: \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} and as tr(\\nabla v) tr(\\nabla v) is the divergence of v v we can reqrite it as \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} where v v is a vector valued function: v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) and the stress \\tau \\tau is a symmetric tensor valued function: \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} We show in the following how to setup the elastic wave-equation form Devito's high-level tensorial types. # Now we create the velocity and pressure fields x , z = model . grid . dimensions t = model . grid . stepping_dim time = model . grid . time_dim s = time . spacing v = VectorTimeFunction ( name = 'v' , grid = model . grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = model . grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = s * src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = s * src ) # The receiver nrec = 301 rec = Receiver ( name = \"rec\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec . coordinates . data [:, - 1 ] = 5. rec2 = Receiver ( name = \"rec2\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec2 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec2 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec3 = Receiver ( name = \"rec3\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec3 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec3 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec_term = rec . interpolate ( expr = tau [ 0 , 0 ] + tau [ 1 , 1 ]) rec_term += rec2 . interpolate ( expr = v [ 1 ]) rec_term += rec3 . interpolate ( expr = v [ 0 ]) #NBVAL_SKIP from examples.seismic import plot_velocity plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 10 , :]) plot_velocity ( model , source = src . coordinates . data , receiver = rec2 . coordinates . data [:: 10 , :]) # Now let's try and create the staggered updates # Lame parameters l , mu , ro = model . lam , model . mu , model . b # fdelmodc reference implementation u_v = Eq ( v . forward , model . damp * ( v + s * ro * div ( tau ))) u_t = Eq ( tau . forward , model . damp * ( tau + s * ( l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )))) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) v . _time_order \\displaystyle 1 \\displaystyle 1 ro . _eval_at ( v [ 0 ]) . evaluate \\displaystyle 0.5 b{\\left(x,y \\right)} + 0.5 b{\\left(x + h_{x},y \\right)} \\displaystyle 0.5 b{\\left(x,y \\right)} + 0.5 b{\\left(x + h_{x},y \\right)} We can now see that both the particle velocities and stress equations are vectorial and tensorial equations. Devito takes care of the discretization and staggered grids automatically for these types of object. u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) b{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) b{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) b{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) b{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] u_t \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.75 s PerformanceSummary([(PerfKey(name='section0', rank=None), PerfEntry(time=0.6419339999999998, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section1', rank=None), PerfEntry(time=0.02470599999999997, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section2', rank=None), PerfEntry(time=0.029838999999999952, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section3', rank=None), PerfEntry(time=0.026982999999999972, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section4', rank=None), PerfEntry(time=0.018986000000000017, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))]) #NBVAL_SKIP scale = . 5 * 1e-3 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau [ 0 , 0 ] . data [ 0 ][ slices ] + tau [ 1 , 1 ] . data [ 0 ][ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau [ 0 , 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () model . _physical_parameters ['damp', 'lam', 'mu', 'b'] #NBVAL_IGNORE_OUTPUT # Full run for the data op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.89 s PerformanceSummary([(PerfKey(name='section0', rank=None), PerfEntry(time=0.7226290000000001, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section1', rank=None), PerfEntry(time=0.048404, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section2', rank=None), PerfEntry(time=0.038736, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section3', rank=None), PerfEntry(time=0.05278400000000011, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section4', rank=None), PerfEntry(time=0.02340000000000003, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))]) # Data on a standard 2ms tim axis rec_plot = rec . resample ( num = 1001 ) rec2_plot = rec2 . resample ( num = 1001 ) rec3_plot = rec3 . resample ( num = 1001 ) scale_for_plot = np . diag ( np . linspace ( 1.0 , 2.5 , 1001 ) ** 2.0 ) #NBVAL_SKIP # Pressure (txx + tzz) data at sea surface extent = [ rec_plot . coordinates . data [ 0 , 0 ], rec_plot . coordinates . data [ - 1 , 0 ], 1e-3 * tn , t0 ] aspect = rec_plot . coordinates . data [ - 1 , 0 ] / ( 1e-3 * tn ) /. 5 plt . figure ( figsize = ( 15 , 15 )) plt . imshow ( np . dot ( scale_for_plot , rec_plot . data ), vmin =-. 01 , vmax =. 01 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') assert np . isclose ( norm ( rec ), 22.68 , atol = 0 , rtol = 1e-3 ) assert np . isclose ( norm ( rec2 ), 1.8299 , atol = 0 , rtol = 1e-3 ) assert np . isclose ( norm ( rec3 ), 3.8671 , atol = 0 , rtol = 1e-3 ) # Now that looks pretty! But let's do it again with a 2nd order in time so = 8 v2 = VectorTimeFunction ( name = 'v2' , grid = model . grid , space_order = so , time_order = 2 ) tau0 = TensorFunction ( name = 't0' , grid = model . grid , space_order = so ) # The source injection term src_xx = src . inject ( field = tau0 [ 0 , 0 ], expr = src . dt ) src_zz = src . inject ( field = tau0 [ 1 , 1 ], expr = src . dt ) s = model . grid . time_dim . spacing # fdelmodc reference implementation u_v = Eq ( v2 . forward , model . damp * ( 2 * v2 - model . damp * v2 . backward + s ** 2 * ro * div ( tau0 ))) u_t = Eq ( tau0 , model . damp * ( l * diag ( div ( v2 . forward )) + mu * ( grad ( v2 . forward ) + grad ( v2 . forward ) . T ))) # rec_term = rec.interpolate(expr=tau[0, 0] + tau[1, 1]) rec_term = rec2 . interpolate ( expr = v2 [ 0 ]) rec_term += rec3 . interpolate ( expr = v2 [ 1 ]) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.69 s PerformanceSummary([(PerfKey(name='section0', rank=None), PerfEntry(time=0.6159669999999996, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section1', rank=None), PerfEntry(time=0.0222800000000001, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section2', rank=None), PerfEntry(time=0.02982499999999997, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section3', rank=None), PerfEntry(time=0.018444000000000012, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))]) #NBVAL_SKIP scale = 1e-4 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v2 [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v2 [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau0 [ 0 , 0 ] . data [ slices ] + tau0 [ 1 , 1 ] . data [ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau0 [ 0 , 1 ] . data [ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () #NBVAL_IGNORE_OUTPUT op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.65 s PerformanceSummary([(PerfKey(name='section0', rank=None), PerfEntry(time=0.5681579999999993, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section1', rank=None), PerfEntry(time=0.02465800000000001, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section2', rank=None), PerfEntry(time=0.028956999999999948, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[])), (PerfKey(name='section3', rank=None), PerfEntry(time=0.018367000000000026, gflopss=0.0, gpointss=0.0, oi=0.0, ops=0, itershapes=[]))]) rec2_plot2 = rec2 . resample ( num = 1001 ) rec3_plot2 = rec3 . resample ( num = 1001 ) #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') assert np . isclose ( norm ( rec2 ), . 410652 , atol = 0 , rtol = 1e-3 ) assert np . isclose ( norm ( rec3 ), . 210861 , atol = 0 , rtol = 1e-3 )","title":"Vectorial form"},{"location":"tutorials/TLE_Adjoint/","text":"import numpy as np import matplotlib.pyplot as plt % matplotlib inline Preface: Installing Devito (do not include in manuscipt) This tutorial and the coming second part are based on Devito version 3.1.0. It requires the installation of the full software with examples, not only the code generation API. To install: git clone -b v3.1.0 https://github.com/opesci/devito cd devito conda env create -f environment.yml source activate devito pip install -e . That final dot is important, don't miss it out! Useful links Devito documentation Devito source code and examples Tutorial notebooks with latest Devito/master Geophysics tutorial Full-waveform inversion 2: adjoint modeling Mathias Louboutin 1 *, Philipp Witte 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: mloubout@eoas.ubc.ca Introduction This tutorial is the second part of a three part tutorial series on full-waveform inversion (FWI), in which we provide a step by step walk through of setting up forward and adjoint wave equation solvers and an optimization framework for inversion. In Part 1 (Louboutin et al., 2017), we showed how to use Devito to set up and solve acoustic wave equations with (impulsive) seismic sources and sample wavefields at the receiver locations to forward model shot records. In the second part of this tutorial series, we will discuss how to set up and solve adjoint wave equations with Devito and from that, how we can calculate gradients and function values of the FWI objective function. The gradient of FWI is most commonly computed via the adjoint state method, by cross-correlating forward and adjoint wavefields and summing the contributions over all time steps (Plessix, 2006). Calculating the gradient for one source location consists of three steps: Solve the forward wave equation to create a shot record. The time varying wavefield must be stored for use in step 3; techniques such as subsampling can be used to reduce the storage requirements. Compute the data residual (or misfit) between the predicted and observed data. Solve the corresponding discrete adjoint model using the data residual as the source. Within the adjoint (reverse) time loop, cross correlate the second time derivative of the adjoint wavefield with the forward wavefield. These cross correlations are summed to form the gradient. We start with the definition and derivation of the adjoint wave equation and its Devito stencil and then show how to compute the gradient of the conventional least squares FWI misfit function. As usual, this tutorial is accompanied by all the code you need to reproduce the figures. Go to github.com/seg/tutorials-2018 and follow the links. A simple experiment To demonstrate the gradient computation in the simplest possible way, we perform a small seismic transmission experiment with a circular imaging phantom, i.e. a constant velocity model with a circular high velocity inclusion in its centre, as shown in Figure 1. For a transmission experiment, we place 21 seismic sources on the left-hand side of the model and 101 receivers on the right-hand side. We will use the forward propagator from part 1 to independently model the 21 \"observed\" shot records using the true model. As the initial model for our gradient calculation, we use a constant velocity model with the same velocity as the true model, but without the circular velocity perturbation. We will then model the 21 predicted shot records for the initial model, calculate the data residual and gradient for each shot, and sum them to obtain the full gradient. ++ Figure 1 is generated later in the manuscript ++ Figure 1: (a) The velocity model, with sources and receivers arranged vertically. (b) The initial estimate. \u00a9 The difference between the model and the initial estimate. The adjoint wave equation Adjoint wave equations are a main component in seismic inversion algorithms and are required for computing gradients of both linear and non-linear objective functions. To ensure stability of the adjoint modeling scheme and the expected convergence of inversion algorithms, it is very important that the adjoint wave equation is in fact the adjoint (transpose) of the forward wave equation. The derivation of the adjoint wave equation in the acoustic case is simple, as it is self-adjoint if we ignore the absorbing boundaries for the moment. However, in the general case, discrete wave equations do not have this property (such as the coupled anisotropic TTI wave equation (Zhang et al., 2011)) and require correct derivations of their adjoints. We concentrate here, as in part 1, on the acoustic case and follow an optimize-discretize approach, which means we write out the adjoint wave equation for the continuous case first and then discretize it, using finite difference operators of the same order as for the forward equation. With the variables defined as in part 1 and the data residual \\delta d(x,y,t; x_r, y_r) \\delta d(x,y,t; x_r, y_r) , located at x_r, y_r x_r, y_r (receiver locations) as the adjoint source, the continuous adjoint wave equation is given by: m(x,y) \\frac{\\mathrm{d}^2 v(t,x,y)}{\\mathrm{d}t^2}\\ -\\ \\Delta v(t,x,y)\\ -\\ \\eta(x,y) \\frac{\\mathrm{d} v(t,x,y)}{\\mathrm{d}t}\\ \\ =\\ \\ \\delta d(t,x,y;x_r, y_r) m(x,y) \\frac{\\mathrm{d}^2 v(t,x,y)}{\\mathrm{d}t^2}\\ -\\ \\Delta v(t,x,y)\\ -\\ \\eta(x,y) \\frac{\\mathrm{d} v(t,x,y)}{\\mathrm{d}t}\\ \\ =\\ \\ \\delta d(t,x,y;x_r, y_r) The adjoint acoustic wave equation is equivalent to the forward equation with the exception of the damping term \\eta(x,y) \\mathrm{d}v(t,x,y)/\\mathrm{d}t \\eta(x,y) \\mathrm{d}v(t,x,y)/\\mathrm{d}t , which contains a first time derivative and therefore has a change of sign in its adjoint. (A second derivative matrix is the same as its transpose, whereas a first derivative matrix is equal to its negative transpose and vice versa.) Following the pattern of part 1, we first define the discrete adjoint wavefield \\mathbf{v} \\mathbf{v} as a Devito TimeFunction object. For reasons we'll explain later, we do not need to save the adjoint wavefield: # NOT FOR MANUSCRIPT from examples.seismic import Model , demo_model , plot_velocity , plot_perturbation shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # Need origin to define relative source and receiver locations model = demo_model ( 'circle-isotropic' , vp = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbpml = 40 ) # For the manuscript, we'll re-form the model using the Vp field from # this newly created model. vp = model . vp model0 = demo_model ( 'circle-isotropic' , vp = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbpml = 40 ) t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing nt = int ( 1 + ( tn - t0 ) / dt ) # Discrete time axis length time = np . linspace ( t0 , tn , nt ) # Discrete modelling time # NOT FOR MANUSCRIPT from devito import TimeFunction v = TimeFunction ( name = \"v\" , grid = model . grid , time_order = 2 , space_order = 4 , save = False ) Now symbolically set up the PDE: pde = model . m * v . dt2 - v . laplace - model . damp * v . dt As before, we then define a stencil: # NOT FOR MANUSCRIPT from devito import Eq from sympy import solve stencil_v = Eq ( v . backward , solve ( pde , v . backward )[ 0 ]) Just as for the forward wave equation, stencil_v defines the update for the adjoint wavefield of a single time step. The only difference is that, while the forward modeling propagator goes forward in time, the adjoint propagator goes backwards in time, since the initial time conditions for the forward propagator turn into final time conditions for the adjoint propagator. As for the forward stencil, we can write out the corresponding discrete expression for the update of the adjoint wavefield: \\mathbf{v}[\\text{time}-\\text{dt}] = 2\\mathbf{v}[\\text{time}] - \\mathbf{v}[\\text{time}+\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}}\\Delta \\mathbf{v}[\\text{time}], \\quad \\text{time} = n_{t-1} \\cdots 1 \\mathbf{v}[\\text{time}-\\text{dt}] = 2\\mathbf{v}[\\text{time}] - \\mathbf{v}[\\text{time}+\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}}\\Delta \\mathbf{v}[\\text{time}], \\quad \\text{time} = n_{t-1} \\cdots 1 with \\text{dt} \\text{dt} being the time stepping interval. Once again, this expression does not contain any (adjoint) source terms so far, which will be defined as a separate SparseFunction object. Since the source term for the adjoint wave equation is the difference between an observed and modeled shot record, we first define an (empty) shot record residual with 101 receivers and coordinates defined in rec_coords . We then set the data field rec.data of our shot record to be the data residual between the observed data d_obs and the predicted data d_pred . The symbolic residual source expression res_term for our adjoint wave equation is then obtained by injecting the data residual into the modeling scheme ( residual.inject ). Since we solve the time-stepping loop backwards in time, the res_term is used to update the previous adjoint wavefield v.backward , rather than the next wavefield. As in the forward modeling example, the source is scaled by \\mathrm{dt}^2/\\mathbf{m} \\mathrm{dt}^2/\\mathbf{m} . In Python, we have: # NOT FOR MANUSCRIPT from examples.seismic import Receiver nshots = 21 # Number of shots to create gradient from nreceivers = 101 # Number of receiver locations per shot # Recs are distributed across model, at depth of 20 m. z_extent , _ = model . domain_size z_locations = np . linspace ( 0 , z_extent , num = nreceivers ) rec_coords = np . array ([( 980 , z ) for z in z_locations ]) # NOT FOR MANUSCRIPT from examples.seismic import PointSource residual = PointSource ( name = 'residual' , ntime = nt , grid = model . grid , coordinates = rec_coords ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m , offset = model . nbpml ) # NOT FOR MANUSCRIPT rec = Receiver ( name = 'rec' , npoint = nreceivers , ntime = nt , grid = model . grid , coordinates = rec_coords ) # NOT FOR MANUSCRIPT from examples.seismic import RickerSource # At first, we want only a single shot. # Src is 5% across model, at depth of 500 m. z_locations = np . linspace ( 0 , z_extent , num = nshots ) src_coords = np . array ([( z_extent / 50 , z ) for z in z_locations ]) # NOT FOR MANUSCRIPT f0 = 0.010 # kHz, peak frequency. src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , time = time , coordinates = src_coords [ nshots // 2 ]) # NOT FOR MANUSCRIPT plt . plot ( src . time , src . data ) plt . xlabel ( \"Time (ms)\" ) plt . ylabel ( \"Amplitude\" ) plt . show () # NOT FOR MANUSCRIPT # Generates Figure 1 from matplotlib.gridspec import GridSpec # Set up figure, grid, and parameters. fig = plt . figure ( figsize = ( 8 , 12 )) gs = GridSpec ( 3 , 2 ) ax0 = fig . add_subplot ( gs [: 2 , : 2 ]) ax1 = fig . add_subplot ( gs [ 2 , 0 ]) ax2 = fig . add_subplot ( gs [ 2 , 1 ]) extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] model_param = dict ( vmin = 2.5 , vmax = 3.0 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) diff_param = dict ( vmin =- 1 , vmax = 0 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) # Part (a) im = ax0 . imshow ( np . transpose ( model . vp ), ** model_param ) ax0 . scatter ( * rec_coords . T / 1000 , lw = 0 , c = 'green' , s = 8 ) ax0 . scatter ( * src_coords . T / 1000 , lw = 0 , c = 'red' , s = 24 ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 14 ) ax0 . text ( 0.5 , 0.08 , \"model.vp\" , ha = \"center\" , color = 'k' , size = 18 ) ax0 . text ( 0.5 , 0.5 , \"3000 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 14 ) ax0 . text ( 0.8 , 0.5 , \"2500 m/s\" , ha = \"center\" , va = 'center' , color = 'navy' , size = 14 ) ax0 . text ( 0.04 , 0.04 , \"sources\" , ha = \"left\" , color = 'r' , size = 12 ) ax0 . text ( 0.96 , 0.04 , \"receivers\" , ha = \"right\" , color = 'green' , size = 12 ) ax0 . set_ylim ( 1 , 0 ) plt . setp ( ax0 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax0 . get_yticklabels (), fontsize = 12 ) # Part (b) im = ax1 . imshow ( np . transpose ( model0 . vp ), ** model_param ) ax1 . set_xlabel ( 'X position (km)' , fontsize = 14 ) ax1 . set_yticklabels ([ 0 , '' , 0.5 , '' , 1 ]) ax1 . text ( 0.5 , 0.08 , \"model0.vp\" , ha = \"center\" , color = 'k' , size = 14 ) ax1 . set_ylabel ( 'Depth (km)' , fontsize = 14 ) plt . setp ( ax1 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax1 . get_yticklabels (), fontsize = 12 ) # Part (c) im = ax2 . imshow ( np . transpose ( model0 . vp - model . vp ), ** diff_param ) ax2 . set_xlabel ( 'X position (km)' , fontsize = 14 ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"model0.vp \u2013 model.vp\" , ha = \"center\" , color = 'w' , size = 14 ) ax2 . text ( 0.5 , 0.5 , \"\u2013500 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 12 ) ax2 . text ( 0.85 , 0.5 , \"0 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 12 ) plt . setp ( ax2 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax2 . get_yticklabels (), fontsize = 12 ) plt . savefig ( \"../Figures/Figure_1.pdf\" ) plt . savefig ( \"../Figures/Figure_1.png\" , dpi = 400 ) plt . show () In this demonstration, there is no real data. Instead we will generate the 'observed' data via forward modeling with the true model model . The synthetic data is generated from the initial model model0 . The resulting data, and their difference, are shown in Figure 2. # NOT FOR MANUSCRIPT from examples.seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , src , rec , space_order = 4 ) # Compute 'real' data with forward operator. obs , _ , _ = solver . forward ( src = src , m = model . m ) CustomCompiler: compiled /tmp/devito-gx10ovxj/7a282d6885f4ad3a7b16fd67992b9457900f0291.c [0.62 s] ========================================================================================= Section section_1<714,1> with OI=0.73 computed in 0.000 s [0.52 GFlops/s] Section section_2<714,101> with OI=1.37 computed in 0.001 s [2.20 GFlops/s] Section main<714,179,179> with OI=1.95 computed in 0.090 s [8.15 GFlops/s, 0.25 GPts/s] ========================================================================================= # NOT FOR MANUSCRIPT # Compute initial data with forward operator. pred , u0 , _ = solver . forward ( src = src , m = model0 . m , save = True ) CustomCompiler: compiled /tmp/devito-gx10ovxj/460b72ec62af10f5fed261f3a591dc9679cffa88.c [0.25 s] ========================================================================================= Section section_1<714,1> with OI=0.73 computed in 0.000 s [0.26 GFlops/s] Section section_2<714,101> with OI=1.37 computed in 0.001 s [1.86 GFlops/s] Section main<714,179,179> with OI=1.95 computed in 0.113 s [6.49 GFlops/s, 0.20 GPts/s] ========================================================================================= # NOT FOR MANUSCRIPT fig = plt . figure ( figsize = ( 15 , 5 )) extent = [ model . origin [ 0 ], # Horizontal min model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], tn / 1000 , # Vertical min (bottom) t0 / 1000 ] # Vertical max (top) ma = np . percentile ( obs . data , 99.5 ) params = dict ( vmin =- ma , vmax = ma , cmap = \"Greys\" , aspect = 1 , extent = extent ) text_params = dict ( ha = \"center\" , color = 'w' , size = 16 ) ax0 = fig . add_subplot ( 131 ) im = plt . imshow ( obs . data , ** params ) ax0 . set_ylabel ( 'Time (s)' , fontsize = 16 ) ax0 . text ( 0.5 , 0.08 , \"obs\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) ax1 = fig . add_subplot ( 132 ) im = plt . imshow ( pred . data , ** params ) ax1 . set_xlabel ( 'Z position (km)' , fontsize = 16 ) ax1 . set_yticklabels ([]) ax1 . text ( 0.5 , 0.08 , \"pred\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) ax2 = fig . add_subplot ( 133 ) im = plt . imshow ( pred . data - obs . data , ** params ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"pred \u2013 obs\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) plt . savefig ( \"../Figures/Figure2.pdf\" ) plt . savefig ( \"../Figures/Figure2.png\" , dpi = 400 ) plt . show () Figure 2. Shot records for a shot at a Z position of 0.5 km. (a) The observed data, using the known model with the high velocity disc, contains a perturbation not present in (b) the 'predicted' data, using the initial estimate of the model, which contais no disc. \u00a9 The residual. Finally, we create the full propagator by adding the residual source expression to our previously defined stencil and set the flag time_axis=Backward , to specify that the propagator runs in backwards in time: # NOT FOR MANUSCRIPT from devito import Operator , Backward op_adj = Operator ([ stencil_v ] + res_term , time_axis = Backward ) In contrast to forward modeling, we do not record any measurements at the surface since we are only interested in the adjoint wavefield itself. The full script for setting up the adjoint wave equation, including an animation of the adjoint wavefield is available in adjoint_modeling.ipynb . Computing the FWI gradient The goal of FWI is to estimate a discrete parametrization of the subsurface by minimizing the misfit between the observed shot records of a seismic survey and numerically modeled shot records. The predicted shot records are obtained by solving an individual wave equation per shot location and depend on the parametrization \\mathbf{m} \\mathbf{m} of our wave propagator. The most common function for measuring the data misfit between the observed and modeled data is the \\ell_2 \\ell_2 norm, which leads to the following objective function (Lions (1971), Tarantola (1984)): \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_\\mathrm{s}} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_\\mathrm{s}} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, where the index i i runs over the total number of shots n_\\mathrm{s} n_\\mathrm{s} and the model parameters are the squared slowness. Optimization problems of this form are called nonlinear least-squares problems, since the predicted data modeled with the forward modeling propagator ( op_fwd() in part 1) depends nonlinearly on the unknown parameters \\mathbf{m} \\mathbf{m} . The full derivation of the FWI gradient using the adjoint state method is outside the scope of this tutorial, but conceptually we obtain the gradient by applying the chain rule and taking the partial derivative of the inverse wave equation \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{A}(\\mathbf{m})^{-1} with respect to \\mathbf{m} \\mathbf{m} , which yields the following expression (Plessix, 2006, Virieux and Operto, 2009): \\nabla f (\\mathbf{m})= - \\sum_{i=1}^{n_\\mathrm{s}} \\sum_{\\text{time}=1}^{n_t} \\mathbf{u}[\\text{time}]\\odot \\ddot{\\mathbf{v}}[\\text{time}]. \\nabla f (\\mathbf{m})= - \\sum_{i=1}^{n_\\mathrm{s}} \\sum_{\\text{time}=1}^{n_t} \\mathbf{u}[\\text{time}]\\odot \\ddot{\\mathbf{v}}[\\text{time}]. The inner sum \\text{time}=1,...,n_t \\text{time}=1,...,n_t runs over the number of computational time steps n_t n_t and \\ddot{\\mathbf{v}} \\ddot{\\mathbf{v}} denotes the second temporal derivative of the adjoint wavefield \\mathbf{v} \\mathbf{v} . Computing the gradient of Equation 3, therefore corresponds to performing the point-wise multiplication (denoted by the symbol \\odot \\odot ) of the forward wavefields with the second time derivative of the adjoint wavefield and summing over all time steps. To avoid the need to store the adjoint wavefield, the FWI gradient is calculated in the reverse time-loop while solving the adjoint wave equation. To compute the gradient \\mathbf{g} \\mathbf{g} for the current time step \\mathbf{v}[\\text{time}] \\mathbf{v}[\\text{time}] : \\mathbf{g} = \\mathbf{g} - \\frac{\\mathbf{v}[\\text{time-dt}] - 2\\mathbf{v}[\\text{time}] + \\mathbf{v}[\\text{time+dt}]}{\\mathrm{dt}^2} \\odot \\mathbf{u}[\\text{time}], \\quad \\text{time}=1 \\cdots n_{t-1} \\mathbf{g} = \\mathbf{g} - \\frac{\\mathbf{v}[\\text{time-dt}] - 2\\mathbf{v}[\\text{time}] + \\mathbf{v}[\\text{time+dt}]}{\\mathrm{dt}^2} \\odot \\mathbf{u}[\\text{time}], \\quad \\text{time}=1 \\cdots n_{t-1} The second time derivative of the adjoint wavefield is computed with a second order finite-difference stencil and uses the three adjoint wavefields that are kept in memory during the adjoint time loop (Equation 2). In Devito we define the gradient as a Function since the gradient is computed as the sum over all time steps and therefore has no time dependence: # NOT FOR MANUSCRIPT from devito import TimeFunction , Function # NOT FOR MANUSCRIPT # This is the same u as in Part 1. u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) grad = Function ( name = \"grad\" , grid = model . grid ) The update for the gradient as defined in Equations 4 and 5 is then: grad_update = Eq ( grad , grad - u * v . dt2 ) Now we must add the gradient update expression to the adjoint propagator op_grad . This yields a single symbolic expression with update instructions for both the adjoint wavefield and the gradient: op_grad = Operator ([ stencil_v ] + res_term + [ grad_update ], time_axis = Backward ) Solving the adjoint wave equation by running the following now computes the FWI gradient for a single source. Its value is stored in grad.data . op_grad ( u = u0 , v = v , m = model0 . m , residual = pred . data - obs . data , time = nt , dt = dt ) CustomCompiler: compiled /tmp/devito-gx10ovxj/ec66845144ec0c1fb8e1bb5f532cda21c551712e.c [0.28 s] ========================================================================================= Section section_1<714,101> with OI=0.80 computed in 0.003 s [1.18 GFlops/s] Section main<714,179,179> with OI=2.83 computed in 0.303 s [6.11 GFlops/s, 0.08 GPts/s] ========================================================================================= # NOT FOR MANUSCIPT plt . figure ( figsize = ( 8 , 8 )) plt . imshow ( np . transpose ( grad . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- 1e3 , vmax = 1e3 ) plt . colorbar ( shrink = 0.75 ) plt . show () # NOT FOR MANUSCRIPT tmp = grad . copy () Now we can iterate over all the shot locations, running the same sequence of commands each time. # NOT FOR MANUSCRIPT from devito import configuration configuration [ 'log_level' ] = 'WARNING' # Create the symbols. u0 = TimeFunction ( name = 'u0' , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) u = TimeFunction ( name = 'u' , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 , save = False ) # Define the wave equation, but with a negated damping term eqn = model . m * v . dt2 - v . laplace - model . damp * v . dt # Use SymPy to rearrange the equation into a stencil expression. stencil = Eq ( v . backward , solve ( eqn , v . backward )[ 0 ]) # Define the residual injection. residual = PointSource ( name = 'residual' , ntime = nt , coordinates = rec_coords , grid = model . grid ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m , offset = model . nbpml ) # Correlate u and v for the current time step and add it to the gradient. grad = Function ( name = 'grad' , grid = model . grid , dtype = model . m . dtype ) grad_update = Eq ( grad , grad - u * v . dt2 ) # Compose the operator. op_grad2 = Operator ([ stencil ] + res_term + [ grad_update ], time_axis = Backward ) # Iterate over the shots. for i in range ( nshots ): print ( \"Source {} of {} \" . format ( i , nshots )) # Opdate source location. src . coordinates . data [ 0 , :] = src_coords [ i ] # Generate data from true model and current model estimate. obs , _ , _ = solver . forward ( src = src , m = model . m ) pred , _ , _ = solver . forward ( src = src , m = model0 . m , u = u0 , save = True ) # Compute the gradient from the residual. v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) residual . data [:] = pred . data - obs . data op_grad2 ( u = u0 , v = v , m = model0 . m , residual = residual , grad = grad , dt = dt ) configuration [ 'log_level' ] = 'INFO' Source 0 of 21 Source 1 of 21 Source 2 of 21 Source 3 of 21 Source 4 of 21 Source 5 of 21 Source 6 of 21 Source 7 of 21 Source 8 of 21 Source 9 of 21 Source 10 of 21 Source 11 of 21 Source 12 of 21 Source 13 of 21 Source 14 of 21 Source 15 of 21 Source 16 of 21 Source 17 of 21 Source 18 of 21 Source 19 of 21 Source 20 of 21 # NOT FOR MANUSCRIPT plt . figure ( figsize = ( 8 , 8 )) plt . imshow ( np . transpose ( grad . data )[ 40 : - 40 , 40 : - 40 ], extent = extent , vmin =- 1e4 , vmax = 1e4 , cmap = 'RdBu' ) plt . colorbar ( shrink = 0.75 ) plt . show () # NOT FOR MANUSCRIPT # Generates Figure 3 from plot_utils import add_subplot_axes fig = plt . figure ( figsize = ( 12 , 6 )) ax0 = fig . add_subplot ( 121 ) ma = 1e3 im = ax0 . imshow ( np . transpose ( tmp . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- ma , vmax = ma ) cax = add_subplot_axes ( ax0 , [ 0.3 , 0.075 , 0.4 , 0.02 ]) fig . colorbar ( im , cax = cax , orientation = 'horizontal' ) cax . text ( 0 , 1 , \" {:.0f} \" . format ( - ma ), ha = 'right' , va = 'top' , size = 10 ) cax . text ( 1 , 1 , \" {:.0f} \" . format ( ma ), ha = 'left' , va = 'top' , size = 10 ) cax . set_axis_off () ax0 . text ( 0.5 , 0.05 , \"Shot @ 500 m\" , ha = 'center' , va = 'center' , size = 16 ) ax0 . set_xlabel ( 'X position (m)' , fontsize = 16 ) ax0 . set_ylabel ( 'Z position (m)' , fontsize = 16 ) plt . setp ( ax0 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax0 . get_yticklabels (), fontsize = 12 ) ax1 = fig . add_subplot ( 122 ) ma = 1e4 im = ax1 . imshow ( np . transpose ( grad . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- ma , vmax = ma ) cax = add_subplot_axes ( ax1 , [ 0.3 , 0.075 , 0.4 , 0.02 ]) fig . colorbar ( im , cax = cax , orientation = 'horizontal' ) cax . text ( 0 , 1 , \" {:.0f} \" . format ( - ma ), ha = 'right' , va = 'top' , size = 10 ) cax . text ( 1 , 1 , \" {:.0f} \" . format ( ma ), ha = 'left' , va = 'top' , size = 10 ) cax . set_axis_off () ax1 . text ( 0.5 , 0.05 , \"All {} shots\" . format ( nshots ), ha = 'center' , va = 'center' , size = 16 ) ax1 . set_xlabel ( 'X position (m)' , fontsize = 16 ) ax1 . set_yticklabels ([]) plt . setp ( ax1 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax1 . get_yticklabels (), fontsize = 12 ) plt . savefig ( \"../Figures/Figure3.pdf\" ) plt . savefig ( \"../Figures/Figure3.png\" , dpi = 400 ) plt . show () Figure 3. Gradient plots for (a) a single shot at 0.5 km and (b) the sum of all shots. This gradient can then be used for a simple gradient descent optimization loop, as illustrated at the end of the notebook adjoint_modeling.ipynb . After each update, a new gradient is computed for the new velocity model until sufficient decrease of the objective or chosen number of iteration is reached. A detailed treatment of optimization and more advanced algorithms will be described in the third and final part of this tutorial series. Verification (do not include in manuscipt) The next step of the adjoint modeling and gradient part is verification with unit testing, i.e. we ensure that the adjoints and gradients are implemented correctly. Incorrect adjoints can lead to unpredictable behaviour during and inversion and in the worst case cause slower convergence or convergence to wrong solutions. Since our forward-adjoint wave equation solvers correspond to forward-adjoint pairs, we need to ensure that the adjoint defined dot test holds within machine precision (see **`tests/test_adjointA.py`** for the dot test). Furthermore, we verify the correct implementation of the FWI gradient by ensuring that using the gradient leads to first order convergence. The gradient test can be found in **`tests/test_gradient.py`**. Conclusions We need the gradient of the FWI objective function in order to find the optimal solution. It is computed by solving adjoint wave equations and summing the point-wise product of forward and adjoint wavefields over all time steps. Using Devito, the adjoint wave equation is set up in a similar fashion as the forward wave equation, with the main difference being the (adjoint) source, which is the residual between the observed and predicted shot records. With the ability to model shot records and compute gradients of the FWI objective function, we are ready to demonstrate how to set up more gradient-based algorithms for FWI in Part 3 next month. Acknowledgments This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre. References [1] Michael Lange, Navjot Kukreja, Mathias Louboutin, Fabio Luporini, Felippe Vieira Zacarias, Vincenzo Pandolfo, Paulius Velesko, Paulius Kazakas, and Gerard Gorman. Devito: Towards a generic finite difference DSL using symbolic python. In 6 th Workshop on Python for High-Performance and Scientific Computing, pages 67\u201375, 11 2016. doi: 10.1109/PyHPC.2016.9. [2] J. L. Lions. Optimal control of systems governed by partial differential equations. Springer-Verlag Berlin Heidelberg, 1 st edition, 1971. ISBN 978-3-642-65026-0. [3] Mathias Louboutin, Philipp A. Witte, Michael Lange, Navjot Kukreja, Fabio Luporini, Gerard Gorman, and Felix J. Herrmann. Full-waveform inversion - part 1: forward modeling. Submitted to The Leading Edge for the tutorial section on October 30, 2017., 2017. [4] Aaron Meurer, Christopher P. Smith, Mateusz Paprocki, Ondr\u030cej C\u030certi\u0301k, Sergey B. Kirpichev, Matthew Rocklin, AMiT Kumar, Sergiu Ivanov, Jason K. Moore, Sartaj Singh, Thilina Rathnayake, Sean Vig, Brian E. Granger, Richard P. Muller, Francesco Bonazzi, Harsh Gupta, Shivam Vats, Fredrik Johansson, Fabian Pedregosa, Matthew J. Curry, Andy R. Terrel, S\u030cte\u030cpa\u0301n Rouc\u030cka, Ashutosh Saboo, Isuru Fernando, Sumith Kulal, Robert Cimrman, and Anthony Scopatz. Sympy: symbolic computing in python. Peer J Computer Science, 3:e103, January 2017. ISSN 2376-5992. doi: 10.7717/peerj-cs.103. URL https: //doi.org/10.7717/peerj-cs.103. [5] R.-E. Plessix. A review of the adjoint-state method for computing the gradient of a functional with geophysical applications. Geophysical Journal International, 167(2):495, 2006. doi: 10.1111/j.1365-246X.2006.02978.x. URL + http://dx.doi.org/10.1111/j.1365-246X.2006.02978.x [6] Albert Tarantola. Inversion of seismic reflection data in the acoustic approximation. GEOPHYSICS, 49(8): 1259\u20131266, 1984. doi: 10.1190/1.1441754. URL https://doi.org/10.1190/1.1441754 [7] J. Virieux and S. Operto. An overview of full-waveform inversion in exploration geophysics. GEOPHYSICS, 74 (5):WCC1\u2013WCC26, 2009. doi: 10.1190/1.3238367. URL http://library.seg.org/doi/abs/10.1190/1.3238367 [8] Yu Zhang, Houzhu Zhang, and Guanquan Zhang. A stable tti reverse time migration and its implementation. GEOPHYSICS, 76(3):WA3\u2013WA11, 2011. doi: 10.1190/1.3554411. URL https://doi.org/10.1190/1.3554411 . \u00a9 2017 The authors \u2014 licensed CC-BY-SA","title":"Adjoint Modeling"},{"location":"tutorials/TLE_Adjoint/#geophysics-tutorial","text":"","title":"Geophysics tutorial"},{"location":"tutorials/TLE_Adjoint/#full-waveform-inversion-2-adjoint-modeling","text":"Mathias Louboutin 1 *, Philipp Witte 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: mloubout@eoas.ubc.ca","title":"Full-waveform inversion 2: adjoint modeling"},{"location":"tutorials/TLE_Adjoint/#introduction","text":"This tutorial is the second part of a three part tutorial series on full-waveform inversion (FWI), in which we provide a step by step walk through of setting up forward and adjoint wave equation solvers and an optimization framework for inversion. In Part 1 (Louboutin et al., 2017), we showed how to use Devito to set up and solve acoustic wave equations with (impulsive) seismic sources and sample wavefields at the receiver locations to forward model shot records. In the second part of this tutorial series, we will discuss how to set up and solve adjoint wave equations with Devito and from that, how we can calculate gradients and function values of the FWI objective function. The gradient of FWI is most commonly computed via the adjoint state method, by cross-correlating forward and adjoint wavefields and summing the contributions over all time steps (Plessix, 2006). Calculating the gradient for one source location consists of three steps: Solve the forward wave equation to create a shot record. The time varying wavefield must be stored for use in step 3; techniques such as subsampling can be used to reduce the storage requirements. Compute the data residual (or misfit) between the predicted and observed data. Solve the corresponding discrete adjoint model using the data residual as the source. Within the adjoint (reverse) time loop, cross correlate the second time derivative of the adjoint wavefield with the forward wavefield. These cross correlations are summed to form the gradient. We start with the definition and derivation of the adjoint wave equation and its Devito stencil and then show how to compute the gradient of the conventional least squares FWI misfit function. As usual, this tutorial is accompanied by all the code you need to reproduce the figures. Go to github.com/seg/tutorials-2018 and follow the links.","title":"Introduction"},{"location":"tutorials/TLE_Adjoint/#a-simple-experiment","text":"To demonstrate the gradient computation in the simplest possible way, we perform a small seismic transmission experiment with a circular imaging phantom, i.e. a constant velocity model with a circular high velocity inclusion in its centre, as shown in Figure 1. For a transmission experiment, we place 21 seismic sources on the left-hand side of the model and 101 receivers on the right-hand side. We will use the forward propagator from part 1 to independently model the 21 \"observed\" shot records using the true model. As the initial model for our gradient calculation, we use a constant velocity model with the same velocity as the true model, but without the circular velocity perturbation. We will then model the 21 predicted shot records for the initial model, calculate the data residual and gradient for each shot, and sum them to obtain the full gradient. ++ Figure 1 is generated later in the manuscript ++ Figure 1: (a) The velocity model, with sources and receivers arranged vertically. (b) The initial estimate. \u00a9 The difference between the model and the initial estimate.","title":"A simple experiment"},{"location":"tutorials/TLE_Adjoint/#the-adjoint-wave-equation","text":"Adjoint wave equations are a main component in seismic inversion algorithms and are required for computing gradients of both linear and non-linear objective functions. To ensure stability of the adjoint modeling scheme and the expected convergence of inversion algorithms, it is very important that the adjoint wave equation is in fact the adjoint (transpose) of the forward wave equation. The derivation of the adjoint wave equation in the acoustic case is simple, as it is self-adjoint if we ignore the absorbing boundaries for the moment. However, in the general case, discrete wave equations do not have this property (such as the coupled anisotropic TTI wave equation (Zhang et al., 2011)) and require correct derivations of their adjoints. We concentrate here, as in part 1, on the acoustic case and follow an optimize-discretize approach, which means we write out the adjoint wave equation for the continuous case first and then discretize it, using finite difference operators of the same order as for the forward equation. With the variables defined as in part 1 and the data residual \\delta d(x,y,t; x_r, y_r) \\delta d(x,y,t; x_r, y_r) , located at x_r, y_r x_r, y_r (receiver locations) as the adjoint source, the continuous adjoint wave equation is given by: m(x,y) \\frac{\\mathrm{d}^2 v(t,x,y)}{\\mathrm{d}t^2}\\ -\\ \\Delta v(t,x,y)\\ -\\ \\eta(x,y) \\frac{\\mathrm{d} v(t,x,y)}{\\mathrm{d}t}\\ \\ =\\ \\ \\delta d(t,x,y;x_r, y_r) m(x,y) \\frac{\\mathrm{d}^2 v(t,x,y)}{\\mathrm{d}t^2}\\ -\\ \\Delta v(t,x,y)\\ -\\ \\eta(x,y) \\frac{\\mathrm{d} v(t,x,y)}{\\mathrm{d}t}\\ \\ =\\ \\ \\delta d(t,x,y;x_r, y_r) The adjoint acoustic wave equation is equivalent to the forward equation with the exception of the damping term \\eta(x,y) \\mathrm{d}v(t,x,y)/\\mathrm{d}t \\eta(x,y) \\mathrm{d}v(t,x,y)/\\mathrm{d}t , which contains a first time derivative and therefore has a change of sign in its adjoint. (A second derivative matrix is the same as its transpose, whereas a first derivative matrix is equal to its negative transpose and vice versa.) Following the pattern of part 1, we first define the discrete adjoint wavefield \\mathbf{v} \\mathbf{v} as a Devito TimeFunction object. For reasons we'll explain later, we do not need to save the adjoint wavefield: # NOT FOR MANUSCRIPT from examples.seismic import Model , demo_model , plot_velocity , plot_perturbation shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # Need origin to define relative source and receiver locations model = demo_model ( 'circle-isotropic' , vp = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbpml = 40 ) # For the manuscript, we'll re-form the model using the Vp field from # this newly created model. vp = model . vp model0 = demo_model ( 'circle-isotropic' , vp = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbpml = 40 ) t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing nt = int ( 1 + ( tn - t0 ) / dt ) # Discrete time axis length time = np . linspace ( t0 , tn , nt ) # Discrete modelling time # NOT FOR MANUSCRIPT from devito import TimeFunction v = TimeFunction ( name = \"v\" , grid = model . grid , time_order = 2 , space_order = 4 , save = False ) Now symbolically set up the PDE: pde = model . m * v . dt2 - v . laplace - model . damp * v . dt As before, we then define a stencil: # NOT FOR MANUSCRIPT from devito import Eq from sympy import solve stencil_v = Eq ( v . backward , solve ( pde , v . backward )[ 0 ]) Just as for the forward wave equation, stencil_v defines the update for the adjoint wavefield of a single time step. The only difference is that, while the forward modeling propagator goes forward in time, the adjoint propagator goes backwards in time, since the initial time conditions for the forward propagator turn into final time conditions for the adjoint propagator. As for the forward stencil, we can write out the corresponding discrete expression for the update of the adjoint wavefield: \\mathbf{v}[\\text{time}-\\text{dt}] = 2\\mathbf{v}[\\text{time}] - \\mathbf{v}[\\text{time}+\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}}\\Delta \\mathbf{v}[\\text{time}], \\quad \\text{time} = n_{t-1} \\cdots 1 \\mathbf{v}[\\text{time}-\\text{dt}] = 2\\mathbf{v}[\\text{time}] - \\mathbf{v}[\\text{time}+\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}}\\Delta \\mathbf{v}[\\text{time}], \\quad \\text{time} = n_{t-1} \\cdots 1 with \\text{dt} \\text{dt} being the time stepping interval. Once again, this expression does not contain any (adjoint) source terms so far, which will be defined as a separate SparseFunction object. Since the source term for the adjoint wave equation is the difference between an observed and modeled shot record, we first define an (empty) shot record residual with 101 receivers and coordinates defined in rec_coords . We then set the data field rec.data of our shot record to be the data residual between the observed data d_obs and the predicted data d_pred . The symbolic residual source expression res_term for our adjoint wave equation is then obtained by injecting the data residual into the modeling scheme ( residual.inject ). Since we solve the time-stepping loop backwards in time, the res_term is used to update the previous adjoint wavefield v.backward , rather than the next wavefield. As in the forward modeling example, the source is scaled by \\mathrm{dt}^2/\\mathbf{m} \\mathrm{dt}^2/\\mathbf{m} . In Python, we have: # NOT FOR MANUSCRIPT from examples.seismic import Receiver nshots = 21 # Number of shots to create gradient from nreceivers = 101 # Number of receiver locations per shot # Recs are distributed across model, at depth of 20 m. z_extent , _ = model . domain_size z_locations = np . linspace ( 0 , z_extent , num = nreceivers ) rec_coords = np . array ([( 980 , z ) for z in z_locations ]) # NOT FOR MANUSCRIPT from examples.seismic import PointSource residual = PointSource ( name = 'residual' , ntime = nt , grid = model . grid , coordinates = rec_coords ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m , offset = model . nbpml ) # NOT FOR MANUSCRIPT rec = Receiver ( name = 'rec' , npoint = nreceivers , ntime = nt , grid = model . grid , coordinates = rec_coords ) # NOT FOR MANUSCRIPT from examples.seismic import RickerSource # At first, we want only a single shot. # Src is 5% across model, at depth of 500 m. z_locations = np . linspace ( 0 , z_extent , num = nshots ) src_coords = np . array ([( z_extent / 50 , z ) for z in z_locations ]) # NOT FOR MANUSCRIPT f0 = 0.010 # kHz, peak frequency. src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , time = time , coordinates = src_coords [ nshots // 2 ]) # NOT FOR MANUSCRIPT plt . plot ( src . time , src . data ) plt . xlabel ( \"Time (ms)\" ) plt . ylabel ( \"Amplitude\" ) plt . show () # NOT FOR MANUSCRIPT # Generates Figure 1 from matplotlib.gridspec import GridSpec # Set up figure, grid, and parameters. fig = plt . figure ( figsize = ( 8 , 12 )) gs = GridSpec ( 3 , 2 ) ax0 = fig . add_subplot ( gs [: 2 , : 2 ]) ax1 = fig . add_subplot ( gs [ 2 , 0 ]) ax2 = fig . add_subplot ( gs [ 2 , 1 ]) extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] model_param = dict ( vmin = 2.5 , vmax = 3.0 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) diff_param = dict ( vmin =- 1 , vmax = 0 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) # Part (a) im = ax0 . imshow ( np . transpose ( model . vp ), ** model_param ) ax0 . scatter ( * rec_coords . T / 1000 , lw = 0 , c = 'green' , s = 8 ) ax0 . scatter ( * src_coords . T / 1000 , lw = 0 , c = 'red' , s = 24 ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 14 ) ax0 . text ( 0.5 , 0.08 , \"model.vp\" , ha = \"center\" , color = 'k' , size = 18 ) ax0 . text ( 0.5 , 0.5 , \"3000 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 14 ) ax0 . text ( 0.8 , 0.5 , \"2500 m/s\" , ha = \"center\" , va = 'center' , color = 'navy' , size = 14 ) ax0 . text ( 0.04 , 0.04 , \"sources\" , ha = \"left\" , color = 'r' , size = 12 ) ax0 . text ( 0.96 , 0.04 , \"receivers\" , ha = \"right\" , color = 'green' , size = 12 ) ax0 . set_ylim ( 1 , 0 ) plt . setp ( ax0 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax0 . get_yticklabels (), fontsize = 12 ) # Part (b) im = ax1 . imshow ( np . transpose ( model0 . vp ), ** model_param ) ax1 . set_xlabel ( 'X position (km)' , fontsize = 14 ) ax1 . set_yticklabels ([ 0 , '' , 0.5 , '' , 1 ]) ax1 . text ( 0.5 , 0.08 , \"model0.vp\" , ha = \"center\" , color = 'k' , size = 14 ) ax1 . set_ylabel ( 'Depth (km)' , fontsize = 14 ) plt . setp ( ax1 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax1 . get_yticklabels (), fontsize = 12 ) # Part (c) im = ax2 . imshow ( np . transpose ( model0 . vp - model . vp ), ** diff_param ) ax2 . set_xlabel ( 'X position (km)' , fontsize = 14 ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"model0.vp \u2013 model.vp\" , ha = \"center\" , color = 'w' , size = 14 ) ax2 . text ( 0.5 , 0.5 , \"\u2013500 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 12 ) ax2 . text ( 0.85 , 0.5 , \"0 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 12 ) plt . setp ( ax2 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax2 . get_yticklabels (), fontsize = 12 ) plt . savefig ( \"../Figures/Figure_1.pdf\" ) plt . savefig ( \"../Figures/Figure_1.png\" , dpi = 400 ) plt . show () In this demonstration, there is no real data. Instead we will generate the 'observed' data via forward modeling with the true model model . The synthetic data is generated from the initial model model0 . The resulting data, and their difference, are shown in Figure 2. # NOT FOR MANUSCRIPT from examples.seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , src , rec , space_order = 4 ) # Compute 'real' data with forward operator. obs , _ , _ = solver . forward ( src = src , m = model . m ) CustomCompiler: compiled /tmp/devito-gx10ovxj/7a282d6885f4ad3a7b16fd67992b9457900f0291.c [0.62 s] ========================================================================================= Section section_1<714,1> with OI=0.73 computed in 0.000 s [0.52 GFlops/s] Section section_2<714,101> with OI=1.37 computed in 0.001 s [2.20 GFlops/s] Section main<714,179,179> with OI=1.95 computed in 0.090 s [8.15 GFlops/s, 0.25 GPts/s] ========================================================================================= # NOT FOR MANUSCRIPT # Compute initial data with forward operator. pred , u0 , _ = solver . forward ( src = src , m = model0 . m , save = True ) CustomCompiler: compiled /tmp/devito-gx10ovxj/460b72ec62af10f5fed261f3a591dc9679cffa88.c [0.25 s] ========================================================================================= Section section_1<714,1> with OI=0.73 computed in 0.000 s [0.26 GFlops/s] Section section_2<714,101> with OI=1.37 computed in 0.001 s [1.86 GFlops/s] Section main<714,179,179> with OI=1.95 computed in 0.113 s [6.49 GFlops/s, 0.20 GPts/s] ========================================================================================= # NOT FOR MANUSCRIPT fig = plt . figure ( figsize = ( 15 , 5 )) extent = [ model . origin [ 0 ], # Horizontal min model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], tn / 1000 , # Vertical min (bottom) t0 / 1000 ] # Vertical max (top) ma = np . percentile ( obs . data , 99.5 ) params = dict ( vmin =- ma , vmax = ma , cmap = \"Greys\" , aspect = 1 , extent = extent ) text_params = dict ( ha = \"center\" , color = 'w' , size = 16 ) ax0 = fig . add_subplot ( 131 ) im = plt . imshow ( obs . data , ** params ) ax0 . set_ylabel ( 'Time (s)' , fontsize = 16 ) ax0 . text ( 0.5 , 0.08 , \"obs\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) ax1 = fig . add_subplot ( 132 ) im = plt . imshow ( pred . data , ** params ) ax1 . set_xlabel ( 'Z position (km)' , fontsize = 16 ) ax1 . set_yticklabels ([]) ax1 . text ( 0.5 , 0.08 , \"pred\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) ax2 = fig . add_subplot ( 133 ) im = plt . imshow ( pred . data - obs . data , ** params ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"pred \u2013 obs\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) plt . savefig ( \"../Figures/Figure2.pdf\" ) plt . savefig ( \"../Figures/Figure2.png\" , dpi = 400 ) plt . show () Figure 2. Shot records for a shot at a Z position of 0.5 km. (a) The observed data, using the known model with the high velocity disc, contains a perturbation not present in (b) the 'predicted' data, using the initial estimate of the model, which contais no disc. \u00a9 The residual. Finally, we create the full propagator by adding the residual source expression to our previously defined stencil and set the flag time_axis=Backward , to specify that the propagator runs in backwards in time: # NOT FOR MANUSCRIPT from devito import Operator , Backward op_adj = Operator ([ stencil_v ] + res_term , time_axis = Backward ) In contrast to forward modeling, we do not record any measurements at the surface since we are only interested in the adjoint wavefield itself. The full script for setting up the adjoint wave equation, including an animation of the adjoint wavefield is available in adjoint_modeling.ipynb .","title":"The adjoint wave equation"},{"location":"tutorials/TLE_Adjoint/#computing-the-fwi-gradient","text":"The goal of FWI is to estimate a discrete parametrization of the subsurface by minimizing the misfit between the observed shot records of a seismic survey and numerically modeled shot records. The predicted shot records are obtained by solving an individual wave equation per shot location and depend on the parametrization \\mathbf{m} \\mathbf{m} of our wave propagator. The most common function for measuring the data misfit between the observed and modeled data is the \\ell_2 \\ell_2 norm, which leads to the following objective function (Lions (1971), Tarantola (1984)): \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_\\mathrm{s}} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_\\mathrm{s}} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, where the index i i runs over the total number of shots n_\\mathrm{s} n_\\mathrm{s} and the model parameters are the squared slowness. Optimization problems of this form are called nonlinear least-squares problems, since the predicted data modeled with the forward modeling propagator ( op_fwd() in part 1) depends nonlinearly on the unknown parameters \\mathbf{m} \\mathbf{m} . The full derivation of the FWI gradient using the adjoint state method is outside the scope of this tutorial, but conceptually we obtain the gradient by applying the chain rule and taking the partial derivative of the inverse wave equation \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{A}(\\mathbf{m})^{-1} with respect to \\mathbf{m} \\mathbf{m} , which yields the following expression (Plessix, 2006, Virieux and Operto, 2009): \\nabla f (\\mathbf{m})= - \\sum_{i=1}^{n_\\mathrm{s}} \\sum_{\\text{time}=1}^{n_t} \\mathbf{u}[\\text{time}]\\odot \\ddot{\\mathbf{v}}[\\text{time}]. \\nabla f (\\mathbf{m})= - \\sum_{i=1}^{n_\\mathrm{s}} \\sum_{\\text{time}=1}^{n_t} \\mathbf{u}[\\text{time}]\\odot \\ddot{\\mathbf{v}}[\\text{time}]. The inner sum \\text{time}=1,...,n_t \\text{time}=1,...,n_t runs over the number of computational time steps n_t n_t and \\ddot{\\mathbf{v}} \\ddot{\\mathbf{v}} denotes the second temporal derivative of the adjoint wavefield \\mathbf{v} \\mathbf{v} . Computing the gradient of Equation 3, therefore corresponds to performing the point-wise multiplication (denoted by the symbol \\odot \\odot ) of the forward wavefields with the second time derivative of the adjoint wavefield and summing over all time steps. To avoid the need to store the adjoint wavefield, the FWI gradient is calculated in the reverse time-loop while solving the adjoint wave equation. To compute the gradient \\mathbf{g} \\mathbf{g} for the current time step \\mathbf{v}[\\text{time}] \\mathbf{v}[\\text{time}] : \\mathbf{g} = \\mathbf{g} - \\frac{\\mathbf{v}[\\text{time-dt}] - 2\\mathbf{v}[\\text{time}] + \\mathbf{v}[\\text{time+dt}]}{\\mathrm{dt}^2} \\odot \\mathbf{u}[\\text{time}], \\quad \\text{time}=1 \\cdots n_{t-1} \\mathbf{g} = \\mathbf{g} - \\frac{\\mathbf{v}[\\text{time-dt}] - 2\\mathbf{v}[\\text{time}] + \\mathbf{v}[\\text{time+dt}]}{\\mathrm{dt}^2} \\odot \\mathbf{u}[\\text{time}], \\quad \\text{time}=1 \\cdots n_{t-1} The second time derivative of the adjoint wavefield is computed with a second order finite-difference stencil and uses the three adjoint wavefields that are kept in memory during the adjoint time loop (Equation 2). In Devito we define the gradient as a Function since the gradient is computed as the sum over all time steps and therefore has no time dependence: # NOT FOR MANUSCRIPT from devito import TimeFunction , Function # NOT FOR MANUSCRIPT # This is the same u as in Part 1. u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) grad = Function ( name = \"grad\" , grid = model . grid ) The update for the gradient as defined in Equations 4 and 5 is then: grad_update = Eq ( grad , grad - u * v . dt2 ) Now we must add the gradient update expression to the adjoint propagator op_grad . This yields a single symbolic expression with update instructions for both the adjoint wavefield and the gradient: op_grad = Operator ([ stencil_v ] + res_term + [ grad_update ], time_axis = Backward ) Solving the adjoint wave equation by running the following now computes the FWI gradient for a single source. Its value is stored in grad.data . op_grad ( u = u0 , v = v , m = model0 . m , residual = pred . data - obs . data , time = nt , dt = dt ) CustomCompiler: compiled /tmp/devito-gx10ovxj/ec66845144ec0c1fb8e1bb5f532cda21c551712e.c [0.28 s] ========================================================================================= Section section_1<714,101> with OI=0.80 computed in 0.003 s [1.18 GFlops/s] Section main<714,179,179> with OI=2.83 computed in 0.303 s [6.11 GFlops/s, 0.08 GPts/s] ========================================================================================= # NOT FOR MANUSCIPT plt . figure ( figsize = ( 8 , 8 )) plt . imshow ( np . transpose ( grad . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- 1e3 , vmax = 1e3 ) plt . colorbar ( shrink = 0.75 ) plt . show () # NOT FOR MANUSCRIPT tmp = grad . copy () Now we can iterate over all the shot locations, running the same sequence of commands each time. # NOT FOR MANUSCRIPT from devito import configuration configuration [ 'log_level' ] = 'WARNING' # Create the symbols. u0 = TimeFunction ( name = 'u0' , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) u = TimeFunction ( name = 'u' , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 , save = False ) # Define the wave equation, but with a negated damping term eqn = model . m * v . dt2 - v . laplace - model . damp * v . dt # Use SymPy to rearrange the equation into a stencil expression. stencil = Eq ( v . backward , solve ( eqn , v . backward )[ 0 ]) # Define the residual injection. residual = PointSource ( name = 'residual' , ntime = nt , coordinates = rec_coords , grid = model . grid ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m , offset = model . nbpml ) # Correlate u and v for the current time step and add it to the gradient. grad = Function ( name = 'grad' , grid = model . grid , dtype = model . m . dtype ) grad_update = Eq ( grad , grad - u * v . dt2 ) # Compose the operator. op_grad2 = Operator ([ stencil ] + res_term + [ grad_update ], time_axis = Backward ) # Iterate over the shots. for i in range ( nshots ): print ( \"Source {} of {} \" . format ( i , nshots )) # Opdate source location. src . coordinates . data [ 0 , :] = src_coords [ i ] # Generate data from true model and current model estimate. obs , _ , _ = solver . forward ( src = src , m = model . m ) pred , _ , _ = solver . forward ( src = src , m = model0 . m , u = u0 , save = True ) # Compute the gradient from the residual. v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) residual . data [:] = pred . data - obs . data op_grad2 ( u = u0 , v = v , m = model0 . m , residual = residual , grad = grad , dt = dt ) configuration [ 'log_level' ] = 'INFO' Source 0 of 21 Source 1 of 21 Source 2 of 21 Source 3 of 21 Source 4 of 21 Source 5 of 21 Source 6 of 21 Source 7 of 21 Source 8 of 21 Source 9 of 21 Source 10 of 21 Source 11 of 21 Source 12 of 21 Source 13 of 21 Source 14 of 21 Source 15 of 21 Source 16 of 21 Source 17 of 21 Source 18 of 21 Source 19 of 21 Source 20 of 21 # NOT FOR MANUSCRIPT plt . figure ( figsize = ( 8 , 8 )) plt . imshow ( np . transpose ( grad . data )[ 40 : - 40 , 40 : - 40 ], extent = extent , vmin =- 1e4 , vmax = 1e4 , cmap = 'RdBu' ) plt . colorbar ( shrink = 0.75 ) plt . show () # NOT FOR MANUSCRIPT # Generates Figure 3 from plot_utils import add_subplot_axes fig = plt . figure ( figsize = ( 12 , 6 )) ax0 = fig . add_subplot ( 121 ) ma = 1e3 im = ax0 . imshow ( np . transpose ( tmp . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- ma , vmax = ma ) cax = add_subplot_axes ( ax0 , [ 0.3 , 0.075 , 0.4 , 0.02 ]) fig . colorbar ( im , cax = cax , orientation = 'horizontal' ) cax . text ( 0 , 1 , \" {:.0f} \" . format ( - ma ), ha = 'right' , va = 'top' , size = 10 ) cax . text ( 1 , 1 , \" {:.0f} \" . format ( ma ), ha = 'left' , va = 'top' , size = 10 ) cax . set_axis_off () ax0 . text ( 0.5 , 0.05 , \"Shot @ 500 m\" , ha = 'center' , va = 'center' , size = 16 ) ax0 . set_xlabel ( 'X position (m)' , fontsize = 16 ) ax0 . set_ylabel ( 'Z position (m)' , fontsize = 16 ) plt . setp ( ax0 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax0 . get_yticklabels (), fontsize = 12 ) ax1 = fig . add_subplot ( 122 ) ma = 1e4 im = ax1 . imshow ( np . transpose ( grad . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- ma , vmax = ma ) cax = add_subplot_axes ( ax1 , [ 0.3 , 0.075 , 0.4 , 0.02 ]) fig . colorbar ( im , cax = cax , orientation = 'horizontal' ) cax . text ( 0 , 1 , \" {:.0f} \" . format ( - ma ), ha = 'right' , va = 'top' , size = 10 ) cax . text ( 1 , 1 , \" {:.0f} \" . format ( ma ), ha = 'left' , va = 'top' , size = 10 ) cax . set_axis_off () ax1 . text ( 0.5 , 0.05 , \"All {} shots\" . format ( nshots ), ha = 'center' , va = 'center' , size = 16 ) ax1 . set_xlabel ( 'X position (m)' , fontsize = 16 ) ax1 . set_yticklabels ([]) plt . setp ( ax1 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax1 . get_yticklabels (), fontsize = 12 ) plt . savefig ( \"../Figures/Figure3.pdf\" ) plt . savefig ( \"../Figures/Figure3.png\" , dpi = 400 ) plt . show () Figure 3. Gradient plots for (a) a single shot at 0.5 km and (b) the sum of all shots. This gradient can then be used for a simple gradient descent optimization loop, as illustrated at the end of the notebook adjoint_modeling.ipynb . After each update, a new gradient is computed for the new velocity model until sufficient decrease of the objective or chosen number of iteration is reached. A detailed treatment of optimization and more advanced algorithms will be described in the third and final part of this tutorial series.","title":"Computing the FWI gradient"},{"location":"tutorials/TLE_Adjoint/#conclusions","text":"We need the gradient of the FWI objective function in order to find the optimal solution. It is computed by solving adjoint wave equations and summing the point-wise product of forward and adjoint wavefields over all time steps. Using Devito, the adjoint wave equation is set up in a similar fashion as the forward wave equation, with the main difference being the (adjoint) source, which is the residual between the observed and predicted shot records. With the ability to model shot records and compute gradients of the FWI objective function, we are ready to demonstrate how to set up more gradient-based algorithms for FWI in Part 3 next month.","title":"Conclusions"},{"location":"tutorials/TLE_Adjoint/#acknowledgments","text":"This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre.","title":"Acknowledgments"},{"location":"tutorials/TLE_Adjoint/#references","text":"[1] Michael Lange, Navjot Kukreja, Mathias Louboutin, Fabio Luporini, Felippe Vieira Zacarias, Vincenzo Pandolfo, Paulius Velesko, Paulius Kazakas, and Gerard Gorman. Devito: Towards a generic finite difference DSL using symbolic python. In 6 th Workshop on Python for High-Performance and Scientific Computing, pages 67\u201375, 11 2016. doi: 10.1109/PyHPC.2016.9. [2] J. L. Lions. Optimal control of systems governed by partial differential equations. Springer-Verlag Berlin Heidelberg, 1 st edition, 1971. ISBN 978-3-642-65026-0. [3] Mathias Louboutin, Philipp A. Witte, Michael Lange, Navjot Kukreja, Fabio Luporini, Gerard Gorman, and Felix J. Herrmann. Full-waveform inversion - part 1: forward modeling. Submitted to The Leading Edge for the tutorial section on October 30, 2017., 2017. [4] Aaron Meurer, Christopher P. Smith, Mateusz Paprocki, Ondr\u030cej C\u030certi\u0301k, Sergey B. Kirpichev, Matthew Rocklin, AMiT Kumar, Sergiu Ivanov, Jason K. Moore, Sartaj Singh, Thilina Rathnayake, Sean Vig, Brian E. Granger, Richard P. Muller, Francesco Bonazzi, Harsh Gupta, Shivam Vats, Fredrik Johansson, Fabian Pedregosa, Matthew J. Curry, Andy R. Terrel, S\u030cte\u030cpa\u0301n Rouc\u030cka, Ashutosh Saboo, Isuru Fernando, Sumith Kulal, Robert Cimrman, and Anthony Scopatz. Sympy: symbolic computing in python. Peer J Computer Science, 3:e103, January 2017. ISSN 2376-5992. doi: 10.7717/peerj-cs.103. URL https: //doi.org/10.7717/peerj-cs.103. [5] R.-E. Plessix. A review of the adjoint-state method for computing the gradient of a functional with geophysical applications. Geophysical Journal International, 167(2):495, 2006. doi: 10.1111/j.1365-246X.2006.02978.x. URL + http://dx.doi.org/10.1111/j.1365-246X.2006.02978.x [6] Albert Tarantola. Inversion of seismic reflection data in the acoustic approximation. GEOPHYSICS, 49(8): 1259\u20131266, 1984. doi: 10.1190/1.1441754. URL https://doi.org/10.1190/1.1441754 [7] J. Virieux and S. Operto. An overview of full-waveform inversion in exploration geophysics. GEOPHYSICS, 74 (5):WCC1\u2013WCC26, 2009. doi: 10.1190/1.3238367. URL http://library.seg.org/doi/abs/10.1190/1.3238367 [8] Yu Zhang, Houzhu Zhang, and Guanquan Zhang. A stable tti reverse time migration and its implementation. GEOPHYSICS, 76(3):WA3\u2013WA11, 2011. doi: 10.1190/1.3554411. URL https://doi.org/10.1190/1.3554411 . \u00a9 2017 The authors \u2014 licensed CC-BY-SA","title":"References"},{"location":"tutorials/TLE_Forward/","text":"import numpy as np import matplotlib.pyplot as plt % matplotlib inline Preface: Installing Devito (do not include in manuscipt) This tutorial and the coming second part are based on Devito version 3.1.0. It requires the installation of the full software with examples, not only the code generation API. To install: git clone -b v3.1.0 https://github.com/opesci/devito cd devito conda env create -f environment.yml source activate devito pip install -e . That final dot is important, don't miss it out! Useful links Devito documentation Devito source code and examples Tutorial notebooks with latest Devito/master Geophysics tutorial Full-waveform inversion 1: forward modeling Mathias Louboutin 1 *, Philipp Witte 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: mloubout@eoas.ubc.ca Since its re-introduction by Pratt (1999), full-waveform inversion (FWI) has gained a lot of attention in geophysical exploration because of its ability to build high resolution velocity models more or less automatically in areas of complex geology. While there is an extensive and growing literature on the topic, publications focus mostly on technical aspects, making this topic inaccessible for a broader audience due to the lack of simple introductory resources for newcomers to geophysics. We will accomplish this by providing a hands-on walkthrough of FWI using Devito (Lange et al. 2016), a system based on domain-specific languages that automatically generates code for time-domain finite-differences. As usual, this tutorial is accompanied by all the code you need to reproduce the figures. Go to github.com/seg/tutorials-2017 and follow the links. In the Notebook, we describe how to simulate synthetic data for a specified source and receiver setup and how to save the corresponding wavefields and shot records. In part two of this series, we will address how to calculate model updates, i.e. gradients of the FWI objective function, via adjoint modeling. Finally, in part three we will demonstrate how to use this gradient as part of an optimization framework for inverting an unknown velocity model. Introduction Devito provides a concise and straightforward computational framework for discretizing wave equations, which underlie all FWI frameworks. We will show that it generates verifiable executable code at run time for wave propagators associated with forward and (in part 2) adjoint wave equations. Devito frees the user from the recurrent and time-consuming development of performant time-stepping codes and allows the user to concentrate on the geophysics of the problem rather than on low-level implementation details of wave-equation simulators. This tutorial covers the conventional adjoint-state formulation of full-waveform tomography (Tarantola 1984) that underlies most of the current methods referred to as full-waveform inversion (Virieux and Operto 2009). While other formulations have been developed to improve the convergence of FWI for poor starting models, in these tutorials we will concentrate on the standard formulation that relies on the combination of a forward/adjoint pair of propagators and a correlation-based gradient. In part one of this tutorial, we discuss how to set up wave simulations for inversion, including how to express the wave equation in Devito symbolically and how to deal with the acquisition geometry. What is FWI? FWI tries to iteratively minimize the difference between data that was acquired in a seismic survey and synthetic data that is generated from a wave simulator with an estimated (velocity) model of the subsurface. As such, each FWI framework essentially consists of a wave simulator for forward modeling the predicted data and an adjoint simulator for calculating a model update from the data misfit. This first part of this tutorial is dedicated to the forward modeling part and demonstrates how to discretize and implement the acoustic wave equation using Devito. Wave simulations for inversion The acoustic wave equation with the squared slowness m m , defined as m(x,y)=c^{-2}(x,y) m(x,y)=c^{-2}(x,y) with c(x,y) c(x,y) being the unknown spatially varying wavespeed, is given by: m(x, y) \\frac{\\mathrm{d}^2 u(t, x, y)}{\\mathrm{d}t^2}\\ -\\ \\Delta u(t, x, y)\\ +\\ \\eta(x, y) \\frac{\\mathrm{d} u(t, x, y)}{\\mathrm{d}t}\\ \\ =\\ \\ q(t, x, y; x_\\mathrm{s}, y_\\mathrm{s}),\\ \\ \\ \\ \\ \\ \\ \\ (1) m(x, y) \\frac{\\mathrm{d}^2 u(t, x, y)}{\\mathrm{d}t^2}\\ -\\ \\Delta u(t, x, y)\\ +\\ \\eta(x, y) \\frac{\\mathrm{d} u(t, x, y)}{\\mathrm{d}t}\\ \\ =\\ \\ q(t, x, y; x_\\mathrm{s}, y_\\mathrm{s}),\\ \\ \\ \\ \\ \\ \\ \\ (1) where \\Delta \\Delta is the Laplace operator, q(t, x, y;x_\\mathrm{s}, y_\\mathrm{s}) q(t, x, y;x_\\mathrm{s}, y_\\mathrm{s}) is the seismic source, located at (x_\\mathrm{s}, y_\\mathrm{s}) (x_\\mathrm{s}, y_\\mathrm{s}) and \\eta(x, y) \\eta(x, y) is a space-dependent dampening parameter for the absorbing boundary layer (Cerjan et al. 1985). As shown in Figure 1, the physical model is extended in every direction by nbpml grid points to mimic an infinite domain. The dampening term \\eta\\, \\mathrm{d}u/\\mathrm{d}t \\eta\\, \\mathrm{d}u/\\mathrm{d}t attenuates the waves in the dampening layer and prevents waves from reflecting at the model boundaries. In Devito, the discrete representations of m m and \\eta \\eta are contained in a model object that contains a grid object with all relevant information such as the origin of the coordinate system, grid spacing, size of the model and dimensions time, x, y : # FIGURE 1 from IPython.display import HTML HTML ( \"../Figures/Figure1_composed.svg\" ) image/svg+xml 0.0 0.2 0.4 0.6 0.8 1.0 X position (km) 0.0 0.2 0.4 0.6 0.8 1.0 Depth (km) receivers source Origin v = 1.5 km/s v = 2.5 km/s Example velocity model 1.6 1.8 2.0 2.2 2.4 Velocity (km/s) offset = nbpml absorbing layer x y origin source physical domain receiver Figure 1: (a) Diagram showing the model domain, with the perfectly matched layer (PML) as an absorbing layer to attenuate the wavefield at the model boundary. (b) The example model used in this tutorial, with the source and receivers indicated. The grid lines show the cell boundaries. # NOT FOR MANUSCRIPT from examples.seismic import Model , plot_velocity # Define a velocity model. The velocity is in km/s vp = np . empty (( 101 , 101 ), dtype = np . float32 ) vp [:, : 51 ] = 1.5 vp [:, 51 :] = 2.5 model = Model ( vp = vp , # A velocity model. origin = ( 0 , 0 ), # Top left corner. shape = ( 101 , 101 ), # Number of grid points. spacing = ( 10 , 10 ), # Grid spacing in m. nbpml = 40 ) # boundary layer. # NOT FOR MANUSCRIPT # Quick plot of model. plot_velocity ( model ) In the Model instantiation, vp is the velocity in \\text{km}/\\text{s} \\text{km}/\\text{s} , origin is the origin of the physical model in meters, spacing is the discrete grid spacing in meters, shape is the number of grid points in each dimension and nbpml is the number of grid points in the absorbing boundary layer. Is is important to note that shape is the size of the physical domain only, while the total number of grid points, including the absorbing boundary layer, will be automatically derived from shape and nbpml . Symbolic definition of the wave propagator To model seismic data by solving the acoustic wave equation, the first necessary step is to discretize this partial differential equation (PDE), which includes discrete representations of the velocity model and wavefields, as well as approximations of the spatial and temporal derivatives using finite-differences (FD). Unfortunately, implementing these finite-difference schemes in low-level code by hand is error prone, especially when we want performant and reliable code. The primary design objective of Devito is to allow users to define complex matrix-free finite-difference approximations from high-level symbolic definitions, while employing automated code generation to create highly optimized low-level C code. Using the symbolic algebra package SymPy (Meurer et al. 2017) to facilitate the automatic creation of derivative expressions, Devito generates computationally efficient wave propagators. At the core of Devito's symbolic API are symbolic types that behave like SymPy function objects, while also managing data: Function objects represent a spatially varying function discretized on a regular Cartesian grid. For example, a function symbol f = Function(name='f', grid=model.grid, space_order=2) is denoted symbolically as f(x, y) . The objects provide auto-generated symbolic expressions for finite-difference derivatives through shorthand expressions like f.dx and f.dx2 for the first and second derivative in x . TimeFunction objects represent a time-dependent function that has \\text{time} \\text{time} as the leading dimension, for example g(time, x, y) . In addition to spatial derivatives TimeFunction symbols also provide time derivatives g.dt and g.dt2 . SparseFunction objects represent sparse components, such as sources and receivers, which are usually distributed sparsely and often located off the computational grid \u2014 these objects also therefore handle interpolation onto the model grid. To demonstrate Devito's symbolic capabilities, let us consider a time-dependent function \\mathbf{u}(\\text{time}, x, y) \\mathbf{u}(\\text{time}, x, y) representing the discrete forward wavefield: # NOT FOR MANUSCRIPT from devito import TimeFunction t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing nt = int ( 1 + ( tn - t0 ) / dt ) # Discrete time axis length time = np . linspace ( t0 , tn , nt ) # Discrete modelling time u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 2 , save = True , time_dim = nt ) where the grid object provided by the model defines the size of the allocated memory region, time_order and space_order define the default discretization order of the derived derivative expressions. We can now use this symbolic representation of our wavefield to generate simple discretized expressions for finite-difference derivative approximations using shorthand expressions, such as u.dt and u.dt2 to denote \\frac{\\text{d} u}{\\text{d} t} \\frac{\\text{d} u}{\\text{d} t} and \\frac{\\text{d}^2 u}{\\text{d} t^2} \\frac{\\text{d}^2 u}{\\text{d} t^2} respectively: # NOT FOR MANUSCRIPT u u(time, x, y) u . dt -u(time - dt, x, y)/(2*dt) + u(time + dt, x, y)/(2*dt) u . dt2 -2*u(time, x, y)/dt**2 + u(time - dt, x, y)/dt**2 + u(time + dt, x, y)/dt**2 Using the automatic derivation of derivative expressions, we can now implement a discretized expression for Equation 1 without the source term q(x,y,t;x_s, y_s) q(x,y,t;x_s, y_s) . The model object, which we created earlier, already contains the squared slowness \\mathbf{m} \\mathbf{m} and damping term \\mathbf{\\eta} \\mathbf{\\eta} as Function objects: pde = model . m * u . dt2 - u . laplace + model . damp * u . dt If we write out the (second order) second time derivative u.dt2 as shown earlier and ignore the damping term for the moment, our pde expression translates to the following discrete the wave equation: \\frac{\\mathbf{m}}{\\text{dt}^2} \\Big( \\mathbf{u}[\\text{time}-\\text{dt}] - 2\\mathbf{u}[\\text{time}] + \\mathbf{u}[\\text{time}+\\text{dt}]\\Big) - \\Delta \\mathbf{u}[\\text{time}] = 0, \\quad \\text{time}=1 \\cdots n_{t-1} \\ \\ \\ \\ \\ \\ \\ (2) \\frac{\\mathbf{m}}{\\text{dt}^2} \\Big( \\mathbf{u}[\\text{time}-\\text{dt}] - 2\\mathbf{u}[\\text{time}] + \\mathbf{u}[\\text{time}+\\text{dt}]\\Big) - \\Delta \\mathbf{u}[\\text{time}] = 0, \\quad \\text{time}=1 \\cdots n_{t-1} \\ \\ \\ \\ \\ \\ \\ (2) with \\text{time} \\text{time} being the current time step and \\text{dt} \\text{dt} being the time stepping interval. To propagate the wavefield, we rearrange to obtain an expression for the wavefield \\mathbf{u}(\\text{time}+\\text{dt}) \\mathbf{u}(\\text{time}+\\text{dt}) at the next time step. Ignoring the damping term once again, this yields: \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Delta \\mathbf{u}[\\text{time}] \\ \\ \\ \\ \\ \\ \\ (3) \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Delta \\mathbf{u}[\\text{time}] \\ \\ \\ \\ \\ \\ \\ (3) We can rearrange our pde expression automatically using the SymPy utility function solve , then create an expression which defines the update of the wavefield for the new time step \\mathbf{u}(\\text{time}+\\text{dt}) \\mathbf{u}(\\text{time}+\\text{dt}) , with the command u.forward : # NOT FOR MANUSCRIPT from devito import Eq from sympy import solve stencil = Eq ( u . forward , solve ( pde , u . forward )[ 0 ]) stencil represents the finite-difference approximation derived from Equation 3, including the finite-difference approximation of the Laplacian and the damping term. Although it defines the update for a single time step only, Devito knows that we will be solving a time-dependent problem over a number of time steps because the wavefield u is a TimeFunction object. Setting up the acquisition geometry The expression for time stepping we derived in the previous section does not contain a seismic source function yet, so the update for the wavefield at a new time step is solely defined by the two previous wavefields. However as indicated in Equation 1, wavefields for seismic experiments are often excited by an active (impulsive) source q(x,y,t;x_\\text{s}) q(x,y,t;x_\\text{s}) , which is a function of space and time (just like the wavefield u ). To include such a source term in our modeling scheme, we simply add the the source wavefield as an additional term to Equation 3: \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Big(\\Delta \\mathbf{u}[\\text{time}] + \\mathbf{q}[\\text{time}]\\Big). \\ \\ \\ \\ \\ \\ \\ (4) \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Big(\\Delta \\mathbf{u}[\\text{time}] + \\mathbf{q}[\\text{time}]\\Big). \\ \\ \\ \\ \\ \\ \\ (4) Since the source appears on the right-hand side in the original equation (Equation 1), the term also needs to be multiplied with \\frac{\\text{dt}^2}{\\mathbf{m}} \\frac{\\text{dt}^2}{\\mathbf{m}} (this follows from rearranging Equation 2, with the source on the right-hand side in place of 0). Unlike the discrete wavefield u however, the source q is typically localized in space and only a function of time, which means the time-dependent source wavelet is injected into the propagating wavefield at a specified source location. The same applies when we sample the wavefield at receiver locations to simulate a shot record, i.e. the simulated wavefield needs to be sampled at specified receiver locations only. Source and receiver both do not necessarily coincide with the modeling grid. Here, RickerSource acts as a wrapper around SparseFunction and models a Ricker wavelet with a peak frequency f0 and source coordinates src_coords : # NOT FOR MANUSCRIPT from examples.seismic import RickerSource # Src is halfway across model, at depth of 20 m. x_extent , _ = model . domain_size src_coords = [ x_extent / 2 , 20 ] f0 = 0.010 # kHz, peak frequency. src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , time = time , coordinates = src_coords ) The src.inject function now injects the current time sample of the Ricker wavelet (weighted with \\frac{\\text{dt}^2}{\\mathbf{m}} \\frac{\\text{dt}^2}{\\mathbf{m}} as shown in Equation 4) into the updated wavefield u.forward at the specified coordinates. src_term = src . inject ( field = u . forward , expr = src * dt ** 2 / model . m , offset = model . nbpml ) To extract the wavefield at a predetermined set of receiver locations, there is a corresponding wrapper function for receivers as well, which creates a SparseFunction object for a given number npoint of receivers, number nt of time samples, and specified receiver coordinates rec_coords : # NOT FOR MANUSCRIPT from examples.seismic import Receiver # Recs are distributed across model, at depth of 20 m. x_locs = np . linspace ( 0 , x_extent , 101 ) rec_coords = [( x , 20 ) for x in x_locs ] rec = Receiver ( name = 'rec' , npoint = 101 , ntime = nt , grid = model . grid , coordinates = rec_coords ) Rather than injecting a function into the model as we did for the source, we now simply save the wavefield at the grid points that correspond to receiver positions and interpolate the data to their exact possibly of the computatational grid location: rec_term = rec . interpolate ( u , offset = model . nbpml ) # NOT FOR MANUSCRIPT # PLOTS HALF OF FIGURE 1. import matplotlib.patches as patches from matplotlib.ticker import MultipleLocator fig = plt . figure ( figsize = ( 9 , 9 )) extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] model_param = dict ( vmin = 1.5 , vmax = 2.5 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) ax0 = fig . add_subplot ( 111 ) im = plt . imshow ( np . transpose ( vp ), ** model_param ) cb = plt . colorbar ( shrink = 0.8 ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 20 ) ax0 . set_xlabel ( 'X position (km)' , fontsize = 20 ) cb . set_label ( 'Velocity (km/s)' , fontsize = 20 ) plt . xticks ( fontsize = 14 ) plt . yticks ( fontsize = 14 ) cb . ax . tick_params ( labelsize = 14 ) plt . scatter ( * ( rec . coordinates . data [:: 4 , :] . T / 1000 ), c = 'green' , clip_on = False , zorder = 100 ) plt . text ( * rec . coordinates . data [ 0 ] . T / 1000 + [ 0.02 , 0.05 ], \"receivers\" , color = 'green' , size = 14 ) plt . scatter ( * ( src . coordinates . data . squeeze () / 1000 ), c = 'red' , s = 60 ) plt . text ( * src . coordinates . data [ 0 ] / 1000 + [ 0 , 0.05 ], \"source\" , color = 'red' , size = 14 ) plt . scatter ( 0 , 0 , c = 'black' , s = 160 , clip_on = False , zorder = 101 ) plt . text ( - 0.01 , - 0.03 , \"Origin\" , color = 'k' , size = 16 , ha = \"right\" ) plt . text ( 0.02 , 0.5 - 0.03 , \"v = 1.5 km/s\" , color = 'k' , size = 16 , ha = \"left\" , va = 'center' ) plt . text ( 0.02 , 0.5 + 0.05 , \"v = 2.5 km/s\" , color = 'w' , size = 16 , ha = \"left\" , va = 'center' ) plt . title ( \"Example velocity model\" , color = 'k' , size = 24 ) plt . xlim (( 0 , 1 )) plt . ylim (( 1 , 0 )) minorLocator = MultipleLocator ( 1 / 100 ) ax0 . xaxis . set_minor_locator ( minorLocator ) ax0 . yaxis . set_minor_locator ( minorLocator ) plt . grid ( which = 'minor' , alpha = 0.3 ) plt . savefig ( \"../Figures/model.pdf\" , dpi = 400 ) plt . savefig ( \"../Figures/model.png\" ) plt . show () Forward simulation We can now define our forward propagator by adding the source and receiver terms to our stencil object: # NOT FOR MANUSCRIPT from devito import Operator op_fwd = Operator ([ stencil ] + src_term + rec_term ) The symbolic expressions used to create Operator contain sufficient meta-information for Devito to create a fully functional computational kernel. The dimension symbols contained in the symbolic function object ( time, x, y ) define the loop structure of the created code,while allowing Devito to automatically optimize the underlying loop structure to increase execution speed. The size of the loops and spacing between grid points is inferred from the symbolic Function objects and associated model.grid object at run-time. As a result, we can invoke the generated kernel through a simple Python function call by supplying the number of timesteps time and the timestep size dt . The user data associated with each Function is updated in-place during operator execution, allowing us to extract the final wavefield and shot record directly from the symbolic function objects without unwanted memory duplication: op_fwd ( time = nt , dt = model . critical_dt ) CustomCompiler: compiled /var/folders/8x/2cdqc7_57plfk5txbsszysbc0000gn/T/devito-nbfsni25/3d06ca83c7f841ceea604b9788ecda3d3e36bfef.c [1.99 s] ========================================================================================= Section section_1<595,1> with OI=0.80 computed in 0.000 s [0.45 GFlops/s] Section section_2<595,101> with OI=1.50 computed in 0.001 s [2.11 GFlops/s] Section main<595,180,180> with OI=3.27 computed in 0.072 s [14.15 GFlops/s, 0.27 GPts/s] ========================================================================================= When this has finished running, the resulting wavefield is stored in u.data and the shot record is in rec.data . We can easily plot this 2D array as an image, as shown in Figure 2. # NOT FOR MANUSCRIPT # GENERATES FIGURE 2 from matplotlib import cm fig1 = plt . figure ( figsize = ( 10 , 10 )) l = plt . imshow ( rec . data , vmin =- 1 , vmax = 1 , cmap = cm . gray , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], 1e-3 * tn , t0 ]) plt . xlabel ( 'X position (km)' , fontsize = 20 ) plt . ylabel ( 'Time (s)' , fontsize = 20 ) plt . tick_params ( labelsize = 20 ) plt . savefig ( \"../Figures/Figure2.png\" , dpi = 400 ) plt . savefig ( \"../Figures/Figure2.pdf\" ) plt . show () Figure 2. The shot record generated by Devito for the example velocity model. As demonstrated in the notebook, a movie of snapshots of the forward wavefield can also be generated by capturing the wavefield at discrete time steps. Figure 3 shows three timesteps from the movie. # NOT FOR MANUSCRIPT # GENERATES FIGURE 3 fig = plt . figure ( figsize = ( 15 , 5 )) times = [ 200 , 300 , 400 ] extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] data_param = dict ( vmin =- 1e0 , vmax = 1e0 , cmap = cm . Greys , aspect = 1 , extent = extent , interpolation = 'none' ) model_param = dict ( vmin = 1.5 , vmax = 2.5 , cmap = cm . GnBu , aspect = 1 , extent = extent , alpha =. 3 ) ax0 = fig . add_subplot ( 131 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 0 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 20 ) ax0 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 0 ]]), ha = \"center\" , color = 'k' ) ax1 = fig . add_subplot ( 132 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 1 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax1 . set_xlabel ( 'X position (km)' , fontsize = 20 ) ax1 . set_yticklabels ([]) ax1 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 1 ]]), ha = \"center\" , color = 'k' ) ax2 = fig . add_subplot ( 133 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 2 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 2 ]]), ha = \"center\" , color = 'k' ) plt . savefig ( \"../Figures/Figure3.pdf\" ) plt . savefig ( \"../Figures/Figure3.png\" , dpi = 400 ) plt . show () Figure 3. Three time steps from the wavefield simulation that resulted in the shot record in Figure 2. You can generate an animated version in the Notebook at github.com/seg. # NOT FOR MANUSCRIPT import matplotlib.animation as animation from IPython.display import HTML fig = plt . figure () im = plt . imshow ( np . transpose ( u . data [ 0 , 40 : - 40 , 40 : - 40 ]), cmap = \"Greys\" , animated = True , vmin =- 1e0 , vmax = 1e0 , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]]) plt . xlabel ( 'X position (km)' , fontsize = 20 ) plt . ylabel ( 'Depth (km)' , fontsize = 20 ) plt . tick_params ( labelsize = 20 ) im2 = plt . imshow ( np . transpose ( vp ), vmin = 1.5 , vmax = 2.5 , cmap = cm . GnBu , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]], alpha =. 4 ) def updatefig ( i ): im . set_array ( np . transpose ( u . data [ i * 5 , 40 : - 40 , 40 : - 40 ])) return im , im2 ani = animation . FuncAnimation ( fig , updatefig , frames = np . linspace ( 0 , nt / 5 - 1 , nt // 5 , dtype = np . int64 ), blit = True , interval = 50 ) plt . close ( ani . _fig ) HTML ( ani . to_html5_video ()) Your browser does not support the video tag. # ani.save('../figures/animation.gif', writer='imagemagick', fps=30) # from IPython.display import Image # Image(url='../figures/animation.gif') Conclusions In this first part of the tutorial, we have demonstrated how to set up the discretized forward acoustic wave equations and its associated wave propagator with runtime code generation. While we limited our discussion to the constant density acoustic wave equation, Devito is capable of handling more general wave equations but this is a topic beyond this tutorial on simulating waves for inversion. In part two of our tutorial, we will show how to calculate a valid gradient of the FWI objective using the adjoint state method. In part three, we will demonstrate how to set up a complete matrix-free and scalable optimization framework for acoustic FWI. Acknowledgments This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre. References Cerjan, C., Kosloff, D., Kosloff, R., and Reshef, M., 1985, A nonreflecting boundary condition for discrete acoustic and elastic wave equations: GEOPHYSICS, 50, 705\u2013708. doi:10.1190/1.1441945 Lange, M., Kukreja, N., Louboutin, M., Luporini, F., Zacarias, F. V., Pandolfo, V., Gorman, G., 2016, Devito: Towards a generic finite difference DSL using symbolic python: 6 th workshop on python for high-performance and scientific computing. doi:10.1109/PyHPC.2016.9 Meurer A, Smith CP, Paprocki M, et al., 2017, SymPy: symbolic computing in Python. PeerJ Computer Science 3:e103 https://doi.org/10.7717/peerj-cs.103 Pratt, R. G., 1999, Seismic waveform inversion in the frequency domain, part 1: Theory and verification in a physical scale model: GEOPHYSICS, 64, 888\u2013901. doi:10.1190/1.1444597 Tarantola, A., 1984, Inversion of seismic reflection data in the acoustic approximation: GEOPHYSICS, 49, 1259\u20131266. doi:10.1190/1.1441754 Virieux, J., and Operto, S., 2009, An overview of full-waveform inversion in exploration geophysics: GEOPHYSICS, 74, WCC1\u2013WCC26. doi:10.1190/1.3238367 Supplemental material Devito documentation Devito source code and examples Tutorial notebooks with latest Devito/master \u00a9 2017 The authors \u2014 licensed CC-BY-SA","title":"Forward modeling"},{"location":"tutorials/TLE_Forward/#geophysics-tutorial","text":"","title":"Geophysics tutorial"},{"location":"tutorials/TLE_Forward/#full-waveform-inversion-1-forward-modeling","text":"Mathias Louboutin 1 *, Philipp Witte 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: mloubout@eoas.ubc.ca Since its re-introduction by Pratt (1999), full-waveform inversion (FWI) has gained a lot of attention in geophysical exploration because of its ability to build high resolution velocity models more or less automatically in areas of complex geology. While there is an extensive and growing literature on the topic, publications focus mostly on technical aspects, making this topic inaccessible for a broader audience due to the lack of simple introductory resources for newcomers to geophysics. We will accomplish this by providing a hands-on walkthrough of FWI using Devito (Lange et al. 2016), a system based on domain-specific languages that automatically generates code for time-domain finite-differences. As usual, this tutorial is accompanied by all the code you need to reproduce the figures. Go to github.com/seg/tutorials-2017 and follow the links. In the Notebook, we describe how to simulate synthetic data for a specified source and receiver setup and how to save the corresponding wavefields and shot records. In part two of this series, we will address how to calculate model updates, i.e. gradients of the FWI objective function, via adjoint modeling. Finally, in part three we will demonstrate how to use this gradient as part of an optimization framework for inverting an unknown velocity model.","title":"Full-waveform inversion 1: forward modeling"},{"location":"tutorials/TLE_Forward/#introduction","text":"Devito provides a concise and straightforward computational framework for discretizing wave equations, which underlie all FWI frameworks. We will show that it generates verifiable executable code at run time for wave propagators associated with forward and (in part 2) adjoint wave equations. Devito frees the user from the recurrent and time-consuming development of performant time-stepping codes and allows the user to concentrate on the geophysics of the problem rather than on low-level implementation details of wave-equation simulators. This tutorial covers the conventional adjoint-state formulation of full-waveform tomography (Tarantola 1984) that underlies most of the current methods referred to as full-waveform inversion (Virieux and Operto 2009). While other formulations have been developed to improve the convergence of FWI for poor starting models, in these tutorials we will concentrate on the standard formulation that relies on the combination of a forward/adjoint pair of propagators and a correlation-based gradient. In part one of this tutorial, we discuss how to set up wave simulations for inversion, including how to express the wave equation in Devito symbolically and how to deal with the acquisition geometry.","title":"Introduction"},{"location":"tutorials/TLE_Forward/#wave-simulations-for-inversion","text":"The acoustic wave equation with the squared slowness m m , defined as m(x,y)=c^{-2}(x,y) m(x,y)=c^{-2}(x,y) with c(x,y) c(x,y) being the unknown spatially varying wavespeed, is given by: m(x, y) \\frac{\\mathrm{d}^2 u(t, x, y)}{\\mathrm{d}t^2}\\ -\\ \\Delta u(t, x, y)\\ +\\ \\eta(x, y) \\frac{\\mathrm{d} u(t, x, y)}{\\mathrm{d}t}\\ \\ =\\ \\ q(t, x, y; x_\\mathrm{s}, y_\\mathrm{s}),\\ \\ \\ \\ \\ \\ \\ \\ (1) m(x, y) \\frac{\\mathrm{d}^2 u(t, x, y)}{\\mathrm{d}t^2}\\ -\\ \\Delta u(t, x, y)\\ +\\ \\eta(x, y) \\frac{\\mathrm{d} u(t, x, y)}{\\mathrm{d}t}\\ \\ =\\ \\ q(t, x, y; x_\\mathrm{s}, y_\\mathrm{s}),\\ \\ \\ \\ \\ \\ \\ \\ (1) where \\Delta \\Delta is the Laplace operator, q(t, x, y;x_\\mathrm{s}, y_\\mathrm{s}) q(t, x, y;x_\\mathrm{s}, y_\\mathrm{s}) is the seismic source, located at (x_\\mathrm{s}, y_\\mathrm{s}) (x_\\mathrm{s}, y_\\mathrm{s}) and \\eta(x, y) \\eta(x, y) is a space-dependent dampening parameter for the absorbing boundary layer (Cerjan et al. 1985). As shown in Figure 1, the physical model is extended in every direction by nbpml grid points to mimic an infinite domain. The dampening term \\eta\\, \\mathrm{d}u/\\mathrm{d}t \\eta\\, \\mathrm{d}u/\\mathrm{d}t attenuates the waves in the dampening layer and prevents waves from reflecting at the model boundaries. In Devito, the discrete representations of m m and \\eta \\eta are contained in a model object that contains a grid object with all relevant information such as the origin of the coordinate system, grid spacing, size of the model and dimensions time, x, y : # FIGURE 1 from IPython.display import HTML HTML ( \"../Figures/Figure1_composed.svg\" ) image/svg+xml 0.0 0.2 0.4 0.6 0.8 1.0 X position (km) 0.0 0.2 0.4 0.6 0.8 1.0 Depth (km) receivers source Origin v = 1.5 km/s v = 2.5 km/s Example velocity model 1.6 1.8 2.0 2.2 2.4 Velocity (km/s) offset = nbpml absorbing layer x y origin source physical domain receiver Figure 1: (a) Diagram showing the model domain, with the perfectly matched layer (PML) as an absorbing layer to attenuate the wavefield at the model boundary. (b) The example model used in this tutorial, with the source and receivers indicated. The grid lines show the cell boundaries. # NOT FOR MANUSCRIPT from examples.seismic import Model , plot_velocity # Define a velocity model. The velocity is in km/s vp = np . empty (( 101 , 101 ), dtype = np . float32 ) vp [:, : 51 ] = 1.5 vp [:, 51 :] = 2.5 model = Model ( vp = vp , # A velocity model. origin = ( 0 , 0 ), # Top left corner. shape = ( 101 , 101 ), # Number of grid points. spacing = ( 10 , 10 ), # Grid spacing in m. nbpml = 40 ) # boundary layer. # NOT FOR MANUSCRIPT # Quick plot of model. plot_velocity ( model ) In the Model instantiation, vp is the velocity in \\text{km}/\\text{s} \\text{km}/\\text{s} , origin is the origin of the physical model in meters, spacing is the discrete grid spacing in meters, shape is the number of grid points in each dimension and nbpml is the number of grid points in the absorbing boundary layer. Is is important to note that shape is the size of the physical domain only, while the total number of grid points, including the absorbing boundary layer, will be automatically derived from shape and nbpml .","title":"Wave simulations for inversion"},{"location":"tutorials/TLE_Forward/#symbolic-definition-of-the-wave-propagator","text":"To model seismic data by solving the acoustic wave equation, the first necessary step is to discretize this partial differential equation (PDE), which includes discrete representations of the velocity model and wavefields, as well as approximations of the spatial and temporal derivatives using finite-differences (FD). Unfortunately, implementing these finite-difference schemes in low-level code by hand is error prone, especially when we want performant and reliable code. The primary design objective of Devito is to allow users to define complex matrix-free finite-difference approximations from high-level symbolic definitions, while employing automated code generation to create highly optimized low-level C code. Using the symbolic algebra package SymPy (Meurer et al. 2017) to facilitate the automatic creation of derivative expressions, Devito generates computationally efficient wave propagators. At the core of Devito's symbolic API are symbolic types that behave like SymPy function objects, while also managing data: Function objects represent a spatially varying function discretized on a regular Cartesian grid. For example, a function symbol f = Function(name='f', grid=model.grid, space_order=2) is denoted symbolically as f(x, y) . The objects provide auto-generated symbolic expressions for finite-difference derivatives through shorthand expressions like f.dx and f.dx2 for the first and second derivative in x . TimeFunction objects represent a time-dependent function that has \\text{time} \\text{time} as the leading dimension, for example g(time, x, y) . In addition to spatial derivatives TimeFunction symbols also provide time derivatives g.dt and g.dt2 . SparseFunction objects represent sparse components, such as sources and receivers, which are usually distributed sparsely and often located off the computational grid \u2014 these objects also therefore handle interpolation onto the model grid. To demonstrate Devito's symbolic capabilities, let us consider a time-dependent function \\mathbf{u}(\\text{time}, x, y) \\mathbf{u}(\\text{time}, x, y) representing the discrete forward wavefield: # NOT FOR MANUSCRIPT from devito import TimeFunction t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing nt = int ( 1 + ( tn - t0 ) / dt ) # Discrete time axis length time = np . linspace ( t0 , tn , nt ) # Discrete modelling time u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 2 , save = True , time_dim = nt ) where the grid object provided by the model defines the size of the allocated memory region, time_order and space_order define the default discretization order of the derived derivative expressions. We can now use this symbolic representation of our wavefield to generate simple discretized expressions for finite-difference derivative approximations using shorthand expressions, such as u.dt and u.dt2 to denote \\frac{\\text{d} u}{\\text{d} t} \\frac{\\text{d} u}{\\text{d} t} and \\frac{\\text{d}^2 u}{\\text{d} t^2} \\frac{\\text{d}^2 u}{\\text{d} t^2} respectively: # NOT FOR MANUSCRIPT u u(time, x, y) u . dt -u(time - dt, x, y)/(2*dt) + u(time + dt, x, y)/(2*dt) u . dt2 -2*u(time, x, y)/dt**2 + u(time - dt, x, y)/dt**2 + u(time + dt, x, y)/dt**2 Using the automatic derivation of derivative expressions, we can now implement a discretized expression for Equation 1 without the source term q(x,y,t;x_s, y_s) q(x,y,t;x_s, y_s) . The model object, which we created earlier, already contains the squared slowness \\mathbf{m} \\mathbf{m} and damping term \\mathbf{\\eta} \\mathbf{\\eta} as Function objects: pde = model . m * u . dt2 - u . laplace + model . damp * u . dt If we write out the (second order) second time derivative u.dt2 as shown earlier and ignore the damping term for the moment, our pde expression translates to the following discrete the wave equation: \\frac{\\mathbf{m}}{\\text{dt}^2} \\Big( \\mathbf{u}[\\text{time}-\\text{dt}] - 2\\mathbf{u}[\\text{time}] + \\mathbf{u}[\\text{time}+\\text{dt}]\\Big) - \\Delta \\mathbf{u}[\\text{time}] = 0, \\quad \\text{time}=1 \\cdots n_{t-1} \\ \\ \\ \\ \\ \\ \\ (2) \\frac{\\mathbf{m}}{\\text{dt}^2} \\Big( \\mathbf{u}[\\text{time}-\\text{dt}] - 2\\mathbf{u}[\\text{time}] + \\mathbf{u}[\\text{time}+\\text{dt}]\\Big) - \\Delta \\mathbf{u}[\\text{time}] = 0, \\quad \\text{time}=1 \\cdots n_{t-1} \\ \\ \\ \\ \\ \\ \\ (2) with \\text{time} \\text{time} being the current time step and \\text{dt} \\text{dt} being the time stepping interval. To propagate the wavefield, we rearrange to obtain an expression for the wavefield \\mathbf{u}(\\text{time}+\\text{dt}) \\mathbf{u}(\\text{time}+\\text{dt}) at the next time step. Ignoring the damping term once again, this yields: \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Delta \\mathbf{u}[\\text{time}] \\ \\ \\ \\ \\ \\ \\ (3) \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Delta \\mathbf{u}[\\text{time}] \\ \\ \\ \\ \\ \\ \\ (3) We can rearrange our pde expression automatically using the SymPy utility function solve , then create an expression which defines the update of the wavefield for the new time step \\mathbf{u}(\\text{time}+\\text{dt}) \\mathbf{u}(\\text{time}+\\text{dt}) , with the command u.forward : # NOT FOR MANUSCRIPT from devito import Eq from sympy import solve stencil = Eq ( u . forward , solve ( pde , u . forward )[ 0 ]) stencil represents the finite-difference approximation derived from Equation 3, including the finite-difference approximation of the Laplacian and the damping term. Although it defines the update for a single time step only, Devito knows that we will be solving a time-dependent problem over a number of time steps because the wavefield u is a TimeFunction object.","title":"Symbolic definition of the wave propagator"},{"location":"tutorials/TLE_Forward/#setting-up-the-acquisition-geometry","text":"The expression for time stepping we derived in the previous section does not contain a seismic source function yet, so the update for the wavefield at a new time step is solely defined by the two previous wavefields. However as indicated in Equation 1, wavefields for seismic experiments are often excited by an active (impulsive) source q(x,y,t;x_\\text{s}) q(x,y,t;x_\\text{s}) , which is a function of space and time (just like the wavefield u ). To include such a source term in our modeling scheme, we simply add the the source wavefield as an additional term to Equation 3: \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Big(\\Delta \\mathbf{u}[\\text{time}] + \\mathbf{q}[\\text{time}]\\Big). \\ \\ \\ \\ \\ \\ \\ (4) \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Big(\\Delta \\mathbf{u}[\\text{time}] + \\mathbf{q}[\\text{time}]\\Big). \\ \\ \\ \\ \\ \\ \\ (4) Since the source appears on the right-hand side in the original equation (Equation 1), the term also needs to be multiplied with \\frac{\\text{dt}^2}{\\mathbf{m}} \\frac{\\text{dt}^2}{\\mathbf{m}} (this follows from rearranging Equation 2, with the source on the right-hand side in place of 0). Unlike the discrete wavefield u however, the source q is typically localized in space and only a function of time, which means the time-dependent source wavelet is injected into the propagating wavefield at a specified source location. The same applies when we sample the wavefield at receiver locations to simulate a shot record, i.e. the simulated wavefield needs to be sampled at specified receiver locations only. Source and receiver both do not necessarily coincide with the modeling grid. Here, RickerSource acts as a wrapper around SparseFunction and models a Ricker wavelet with a peak frequency f0 and source coordinates src_coords : # NOT FOR MANUSCRIPT from examples.seismic import RickerSource # Src is halfway across model, at depth of 20 m. x_extent , _ = model . domain_size src_coords = [ x_extent / 2 , 20 ] f0 = 0.010 # kHz, peak frequency. src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , time = time , coordinates = src_coords ) The src.inject function now injects the current time sample of the Ricker wavelet (weighted with \\frac{\\text{dt}^2}{\\mathbf{m}} \\frac{\\text{dt}^2}{\\mathbf{m}} as shown in Equation 4) into the updated wavefield u.forward at the specified coordinates. src_term = src . inject ( field = u . forward , expr = src * dt ** 2 / model . m , offset = model . nbpml ) To extract the wavefield at a predetermined set of receiver locations, there is a corresponding wrapper function for receivers as well, which creates a SparseFunction object for a given number npoint of receivers, number nt of time samples, and specified receiver coordinates rec_coords : # NOT FOR MANUSCRIPT from examples.seismic import Receiver # Recs are distributed across model, at depth of 20 m. x_locs = np . linspace ( 0 , x_extent , 101 ) rec_coords = [( x , 20 ) for x in x_locs ] rec = Receiver ( name = 'rec' , npoint = 101 , ntime = nt , grid = model . grid , coordinates = rec_coords ) Rather than injecting a function into the model as we did for the source, we now simply save the wavefield at the grid points that correspond to receiver positions and interpolate the data to their exact possibly of the computatational grid location: rec_term = rec . interpolate ( u , offset = model . nbpml ) # NOT FOR MANUSCRIPT # PLOTS HALF OF FIGURE 1. import matplotlib.patches as patches from matplotlib.ticker import MultipleLocator fig = plt . figure ( figsize = ( 9 , 9 )) extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] model_param = dict ( vmin = 1.5 , vmax = 2.5 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) ax0 = fig . add_subplot ( 111 ) im = plt . imshow ( np . transpose ( vp ), ** model_param ) cb = plt . colorbar ( shrink = 0.8 ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 20 ) ax0 . set_xlabel ( 'X position (km)' , fontsize = 20 ) cb . set_label ( 'Velocity (km/s)' , fontsize = 20 ) plt . xticks ( fontsize = 14 ) plt . yticks ( fontsize = 14 ) cb . ax . tick_params ( labelsize = 14 ) plt . scatter ( * ( rec . coordinates . data [:: 4 , :] . T / 1000 ), c = 'green' , clip_on = False , zorder = 100 ) plt . text ( * rec . coordinates . data [ 0 ] . T / 1000 + [ 0.02 , 0.05 ], \"receivers\" , color = 'green' , size = 14 ) plt . scatter ( * ( src . coordinates . data . squeeze () / 1000 ), c = 'red' , s = 60 ) plt . text ( * src . coordinates . data [ 0 ] / 1000 + [ 0 , 0.05 ], \"source\" , color = 'red' , size = 14 ) plt . scatter ( 0 , 0 , c = 'black' , s = 160 , clip_on = False , zorder = 101 ) plt . text ( - 0.01 , - 0.03 , \"Origin\" , color = 'k' , size = 16 , ha = \"right\" ) plt . text ( 0.02 , 0.5 - 0.03 , \"v = 1.5 km/s\" , color = 'k' , size = 16 , ha = \"left\" , va = 'center' ) plt . text ( 0.02 , 0.5 + 0.05 , \"v = 2.5 km/s\" , color = 'w' , size = 16 , ha = \"left\" , va = 'center' ) plt . title ( \"Example velocity model\" , color = 'k' , size = 24 ) plt . xlim (( 0 , 1 )) plt . ylim (( 1 , 0 )) minorLocator = MultipleLocator ( 1 / 100 ) ax0 . xaxis . set_minor_locator ( minorLocator ) ax0 . yaxis . set_minor_locator ( minorLocator ) plt . grid ( which = 'minor' , alpha = 0.3 ) plt . savefig ( \"../Figures/model.pdf\" , dpi = 400 ) plt . savefig ( \"../Figures/model.png\" ) plt . show ()","title":"Setting up the acquisition geometry"},{"location":"tutorials/TLE_Forward/#forward-simulation","text":"We can now define our forward propagator by adding the source and receiver terms to our stencil object: # NOT FOR MANUSCRIPT from devito import Operator op_fwd = Operator ([ stencil ] + src_term + rec_term ) The symbolic expressions used to create Operator contain sufficient meta-information for Devito to create a fully functional computational kernel. The dimension symbols contained in the symbolic function object ( time, x, y ) define the loop structure of the created code,while allowing Devito to automatically optimize the underlying loop structure to increase execution speed. The size of the loops and spacing between grid points is inferred from the symbolic Function objects and associated model.grid object at run-time. As a result, we can invoke the generated kernel through a simple Python function call by supplying the number of timesteps time and the timestep size dt . The user data associated with each Function is updated in-place during operator execution, allowing us to extract the final wavefield and shot record directly from the symbolic function objects without unwanted memory duplication: op_fwd ( time = nt , dt = model . critical_dt ) CustomCompiler: compiled /var/folders/8x/2cdqc7_57plfk5txbsszysbc0000gn/T/devito-nbfsni25/3d06ca83c7f841ceea604b9788ecda3d3e36bfef.c [1.99 s] ========================================================================================= Section section_1<595,1> with OI=0.80 computed in 0.000 s [0.45 GFlops/s] Section section_2<595,101> with OI=1.50 computed in 0.001 s [2.11 GFlops/s] Section main<595,180,180> with OI=3.27 computed in 0.072 s [14.15 GFlops/s, 0.27 GPts/s] ========================================================================================= When this has finished running, the resulting wavefield is stored in u.data and the shot record is in rec.data . We can easily plot this 2D array as an image, as shown in Figure 2. # NOT FOR MANUSCRIPT # GENERATES FIGURE 2 from matplotlib import cm fig1 = plt . figure ( figsize = ( 10 , 10 )) l = plt . imshow ( rec . data , vmin =- 1 , vmax = 1 , cmap = cm . gray , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], 1e-3 * tn , t0 ]) plt . xlabel ( 'X position (km)' , fontsize = 20 ) plt . ylabel ( 'Time (s)' , fontsize = 20 ) plt . tick_params ( labelsize = 20 ) plt . savefig ( \"../Figures/Figure2.png\" , dpi = 400 ) plt . savefig ( \"../Figures/Figure2.pdf\" ) plt . show () Figure 2. The shot record generated by Devito for the example velocity model. As demonstrated in the notebook, a movie of snapshots of the forward wavefield can also be generated by capturing the wavefield at discrete time steps. Figure 3 shows three timesteps from the movie. # NOT FOR MANUSCRIPT # GENERATES FIGURE 3 fig = plt . figure ( figsize = ( 15 , 5 )) times = [ 200 , 300 , 400 ] extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] data_param = dict ( vmin =- 1e0 , vmax = 1e0 , cmap = cm . Greys , aspect = 1 , extent = extent , interpolation = 'none' ) model_param = dict ( vmin = 1.5 , vmax = 2.5 , cmap = cm . GnBu , aspect = 1 , extent = extent , alpha =. 3 ) ax0 = fig . add_subplot ( 131 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 0 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 20 ) ax0 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 0 ]]), ha = \"center\" , color = 'k' ) ax1 = fig . add_subplot ( 132 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 1 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax1 . set_xlabel ( 'X position (km)' , fontsize = 20 ) ax1 . set_yticklabels ([]) ax1 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 1 ]]), ha = \"center\" , color = 'k' ) ax2 = fig . add_subplot ( 133 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 2 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 2 ]]), ha = \"center\" , color = 'k' ) plt . savefig ( \"../Figures/Figure3.pdf\" ) plt . savefig ( \"../Figures/Figure3.png\" , dpi = 400 ) plt . show () Figure 3. Three time steps from the wavefield simulation that resulted in the shot record in Figure 2. You can generate an animated version in the Notebook at github.com/seg. # NOT FOR MANUSCRIPT import matplotlib.animation as animation from IPython.display import HTML fig = plt . figure () im = plt . imshow ( np . transpose ( u . data [ 0 , 40 : - 40 , 40 : - 40 ]), cmap = \"Greys\" , animated = True , vmin =- 1e0 , vmax = 1e0 , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]]) plt . xlabel ( 'X position (km)' , fontsize = 20 ) plt . ylabel ( 'Depth (km)' , fontsize = 20 ) plt . tick_params ( labelsize = 20 ) im2 = plt . imshow ( np . transpose ( vp ), vmin = 1.5 , vmax = 2.5 , cmap = cm . GnBu , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]], alpha =. 4 ) def updatefig ( i ): im . set_array ( np . transpose ( u . data [ i * 5 , 40 : - 40 , 40 : - 40 ])) return im , im2 ani = animation . FuncAnimation ( fig , updatefig , frames = np . linspace ( 0 , nt / 5 - 1 , nt // 5 , dtype = np . int64 ), blit = True , interval = 50 ) plt . close ( ani . _fig ) HTML ( ani . to_html5_video ()) Your browser does not support the video tag. # ani.save('../figures/animation.gif', writer='imagemagick', fps=30) # from IPython.display import Image # Image(url='../figures/animation.gif')","title":"Forward simulation"},{"location":"tutorials/TLE_Forward/#conclusions","text":"In this first part of the tutorial, we have demonstrated how to set up the discretized forward acoustic wave equations and its associated wave propagator with runtime code generation. While we limited our discussion to the constant density acoustic wave equation, Devito is capable of handling more general wave equations but this is a topic beyond this tutorial on simulating waves for inversion. In part two of our tutorial, we will show how to calculate a valid gradient of the FWI objective using the adjoint state method. In part three, we will demonstrate how to set up a complete matrix-free and scalable optimization framework for acoustic FWI.","title":"Conclusions"},{"location":"tutorials/TLE_Forward/#acknowledgments","text":"This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre.","title":"Acknowledgments"},{"location":"tutorials/TLE_Forward/#references","text":"Cerjan, C., Kosloff, D., Kosloff, R., and Reshef, M., 1985, A nonreflecting boundary condition for discrete acoustic and elastic wave equations: GEOPHYSICS, 50, 705\u2013708. doi:10.1190/1.1441945 Lange, M., Kukreja, N., Louboutin, M., Luporini, F., Zacarias, F. V., Pandolfo, V., Gorman, G., 2016, Devito: Towards a generic finite difference DSL using symbolic python: 6 th workshop on python for high-performance and scientific computing. doi:10.1109/PyHPC.2016.9 Meurer A, Smith CP, Paprocki M, et al., 2017, SymPy: symbolic computing in Python. PeerJ Computer Science 3:e103 https://doi.org/10.7717/peerj-cs.103 Pratt, R. G., 1999, Seismic waveform inversion in the frequency domain, part 1: Theory and verification in a physical scale model: GEOPHYSICS, 64, 888\u2013901. doi:10.1190/1.1444597 Tarantola, A., 1984, Inversion of seismic reflection data in the acoustic approximation: GEOPHYSICS, 49, 1259\u20131266. doi:10.1190/1.1441754 Virieux, J., and Operto, S., 2009, An overview of full-waveform inversion in exploration geophysics: GEOPHYSICS, 74, WCC1\u2013WCC26. doi:10.1190/1.3238367","title":"References"},{"location":"tutorials/TLE_Forward/#supplemental-material","text":"Devito documentation Devito source code and examples Tutorial notebooks with latest Devito/master \u00a9 2017 The authors \u2014 licensed CC-BY-SA","title":"Supplemental material"},{"location":"tutorials/TLE_fwi/","text":"Installing Devito (do not include in manuscipt) This tutorial and the coming second part are based on Devito version 3.1.0. It requires the installation of the full software with examples, not only the code generation API. To install: git clone -b v3.1.0 https://github.com/opesci/devito cd devito conda env create -f environment.yml source activate devito pip install -e . That final dot is important, don't miss it out! Installing Julia Users need to install Julia, then the [JUDI] software package v1.0, [JOLI](https://github.com/slimgroup/JOLI.jl), and [SeisIO]. These packages can be downloaded using the Julia package manager. First install Julia 0.6, then start the Julia terminal and do this: ENV[\"PYTHON\"] = \" < PATH TO YOUR ENVS >/devito/bin/python\" # e.g. ~/anaconda/envs Pkg.add(\"IJulia\") Pkg.add(\"HDF5\") Pkg.add(\"PyCall\") Pkg.clone(\"https://github.com/slimgroup/SeisIO.jl.git\") Pkg.clone(\"https://github.com/slimgroup/JOLI.jl.git\") Pkg.clone(\"https://github.com/slimgroup/JUDI.jl.git\") Pkg.checkout(\"JUDI\",\"tle_tutorial_jan_2018\") Useful links Devito documentation Devito source code and examples Tutorial notebooks with latest Devito/master Geophysics tutorial Full-Waveform Inversion - Part 3: optimization Philipp Witte 1 *, Mathias Louboutin 1 , Keegan Lensink 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: pwitte@eoas.ubc.ca Introduction This tutorial is the third part of a full-waveform inversion (FWI) tutorial series with a step-by-step walkthrough of setting up forward and adjoint wave equations and building a basic FWI inversion framework. For discretizing and solving wave equations, we use Devito , a Python-based domain-specific language for automated generation of finite-difference code (Lange et al., 2016). The first two parts of this tutorial (Louboutin et al., 2017, 2018) demonstrated how to solve the acoustic wave equation for modeling seismic shot records and how to compute the gradient of the FWI objective function using the adjoint-state method. With these two key ingredients, we will now build an inversion framework that can be used to minimize the FWI least-squares objective function. FWI is a computationally and mathematically challenging problem. The computational complexity comes from the fact that an already expensive solution procedure for the wave equation needs to be repeated for a large number of source positions for each iteration of the optimization algorithm. The mathematical complexity comes from the fact that the FWI objective is known to have many local minima due to cycle skipping. NOT FOR MANUSCRIPT Furthermore, since the solution is not unique it is generally not possible to unambiguously recover the parameterization of the subsurface from the given data alone, making FWI an active field of research (e.g. Leeuwen et al., 2013; Warner and Guasch, 2014; Peters and Herrmann, 2017). This tutorial demonstrates how we can set up a basic FWI framework with two alternative gradient-based optimization algorithms: stochastic gradient descent, and the Gauss\u2013Newton method (Nocedal and Wright, 2009). We implement our inversion framework with the Julia Devito Inversion framework (JUDI), a parallel software package for seismic modeling and inversion in the Julia programming language. JUDI provides abstractions and function wrappers that allow the implementation of wave-equation-based inversion problems such as FWI using code that closely follows the mathematical notation, while using Devito\u2019s automatic code generation for solving the underlying wave equations. All the code to run the algorithms and generate the figures in this paper can be found at http://github.com/SEG . Optimizing the FWI objective function The goal of this tutorial series is to optimize the FWI objective function with the \\ell_2 \\ell_2 -misfit: \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_s} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_s} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, where \\mathbf{d}^\\mathrm{pred}_i \\mathbf{d}^\\mathrm{pred}_i and \\mathbf{d}^\\mathrm{obs}_i \\mathbf{d}^\\mathrm{obs}_i are the predicted and observed seismic shot records of the i^{\\text{th}} i^{\\text{th}} source location and \\mathbf{m} \\mathbf{m} is the velocity model (expressed as squared slowness). In part one, we demonstrated how to implement a forward modeling operator to generate the predicted shot records, which we will denote as \\mathbf{d}^\\mathrm{pred}_i = \\mathbf{F}(\\mathbf{m},\\mathbf{q}_i) \\mathbf{d}^\\mathrm{pred}_i = \\mathbf{F}(\\mathbf{m},\\mathbf{q}_i) . In the second tutorial, we then showed how we can compute the gradient \\nabla f(\\mathbf{m}) \\nabla f(\\mathbf{m}) of the objective function and update our initial model using gradient descent. There is a snag, however. This first-order optimization algorithm has a linear convergence rate at best, and typically requires many iterations to converge. Second-order optimization methods converge considerably faster. To implement them, we first approximate the objective with a second-order Taylor expansion: f(\\mathbf{m}) = f(\\mathbf{m}_0) + \\nabla f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\delta \\mathbf{m}^\\top \\nabla^2 f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\mathcal{O}(\\delta \\mathbf{m}^3), f(\\mathbf{m}) = f(\\mathbf{m}_0) + \\nabla f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\delta \\mathbf{m}^\\top \\nabla^2 f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\mathcal{O}(\\delta \\mathbf{m}^3), where \\mathcal{O}(\\delta \\mathbf{m}^3) \\mathcal{O}(\\delta \\mathbf{m}^3) represents the error term, \\nabla f(\\mathbf{m}_0) \\nabla f(\\mathbf{m}_0) is the gradient as implemented in part two, and \\nabla^2 f(\\mathbf{m}_0) \\nabla^2 f(\\mathbf{m}_0) is the Hessian of the objective function, which we will refer to as \\mathbf{H} \\mathbf{H} . Rather than using the negative gradient to incrementally update our model, as in gradient descent, we directly calculate a model update \\delta \\mathbf{m} \\delta \\mathbf{m} that leads us to the minimum. This is called Newton's method: \\delta \\mathbf{m} = - \\mathbf{H}(\\mathbf{m}_0)^{-1} \\nabla f(\\mathbf{m}_0). \\delta \\mathbf{m} = - \\mathbf{H}(\\mathbf{m}_0)^{-1} \\nabla f(\\mathbf{m}_0). Although the method converges to the minimum of the FWI objective function quickly, it comes at the cost of having to compute and invert the Hessian matrix (Nocedal and Wright, 2009). Fortunately, for least squares problems, such as FWI, the Hessian can be approximated by the Gauss-Newton (GN) Hessian \\mathbf{J}^\\top \\mathbf{J} \\mathbf{J}^\\top \\mathbf{J} , where \\mathbf{J} \\mathbf{J} is the Jacobian matrix. This is the partial derivative of the forward modeling operator \\mathbf{F}(\\mathbf{m},\\mathbf{q}) \\mathbf{F}(\\mathbf{m},\\mathbf{q}) with respect to \\mathbf{m} \\mathbf{m} \u2014 something we can easily compute. Furthermore, the Jacobian can also be used to express the gradient of the FWI objective function as \\nabla f(\\mathbf{m}_0) = \\mathbf{J}^\\top (\\mathbf{d}^\\mathrm{pred}_i - \\mathbf{d}_i^\\mathrm{obs}) \\nabla f(\\mathbf{m}_0) = \\mathbf{J}^\\top (\\mathbf{d}^\\mathrm{pred}_i - \\mathbf{d}_i^\\mathrm{obs}) , where \\mathbf{J}^\\top \\mathbf{J}^\\top is the adjoint (transposed) Jacobian. This is useful, because we now have a set of operators \\mathbf{F}, \\mathbf{J} \\mathbf{F}, \\mathbf{J} and \\mathbf{H}_{GN}=\\mathbf{J}^\\top\\mathbf{J} \\mathbf{H}_{GN}=\\mathbf{J}^\\top\\mathbf{J} , through which we can express both first and second order optimization algorithms for FWI. Although forming these matrices explicitly is not possible, since they can become extremely large, we only need the action of these operators on vectors. This allows us to implement these operators matrix-free. In the following section we will demonstrate how to set up these operators in our JUDI software framework and to how to use them to implement FWI algorithms. NOT FOR MANUSCRIPT [SeisIO]:https://github.com/slimgroup/SeisIO.jl The Julia Devito Inversion framework is a parallel matrix-free linear operator library for seismic modeling and inversion based on Devito and [SeisIO], a performant Julia package for reading and writing large data volumes in SEG-Y format. JUDI allows implementing seismic inversion algorithms as linear algebra operations, enabling rapid translations of FWI algorithms to executable Julia code. The underlying wave equations are set up and solved using Devito, as described in the first two tutorials, and are interfaced from Julia using the [PyCall](https://github.com/JuliaPy/PyCall.jl) package (Johnson, 2017). For reading and writing SEG-Y data, JUDI uses the SeisIO package, a sophisticated SEG-Y reader that allows us to scan large 3D data sets for creating look-up tables with header summaries. However, since our data set is relatively small, we will directly load the full file into memory. The `segy_read` command takes the file name as an input and returns a dense data block. This is our observed data and we store it as a JUDI vector. # NOT FOR MANUSCRIPT addprocs ( 4 ); # NOT FOR MANUSCRIPT using SeisIO using JUDI . TimeModeling , JUDI . SLIM_optim Implementing FWI in JUDI We start our demonstration by reading our data set, which consists of 16 shot records and was generated with an excerpt from the SEG/EAGE Overthrust model (Aminzadeh et al. 1997). We store it as a judiVector : block = segy_read ( \"overthrust_shot_records.segy\" ) d_obs = judiVector ( block ); \u001b[1m\u001b[33mWARNING: \u001b[39m\u001b[22m\u001b[33mFixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=7076688, maxsize=Inf, ptr=3601, mark=-1)\u001b[39m # NOT FOR MANUSCRIPT using PyPlot i = 8 figure ( figsize = ( 15 , 6 )) imshow ( d_obs . data [ i ], cmap = \"seismic\" , extent = [ 0 , size ( d_obs . data [ i ], 2 ), 2 , 0 ], aspect = 0.3 , vmin =- 3 , vmax = 3 ) ax1 = gca (); ax1 [ : set_aspect ]( \"auto\" ) xlabel ( \"Receiver number\" , size = 12 ) ylabel ( \"Time [s]\" , size = 12 ) text ( 3 , 0.13 , \"Shot record $i \" , size = 16 ) colorbar () savefig ( \"../Figures/Figure_1.png\" , dpi = 300 ) show () Figure 1 : Observed shot record number 8. JUDI vectors such as d_obs can be used like a regular Julia vectors, so we can compute norms via norm(d_obs) or the inner product via dot(d_obs, d_obs) , but they contain the shot records in their original dimension. Shot records can be accessed via their respective shot number with d_obs.data[shot_no] , while the header information can be accessed with d_obs.geometry . We extract the source geometry from our SEG-Y file and then manually set up a source vector q with an 8 Hz Ricker wavelet: f = 0.008 # kHz src_geom = Geometry ( block ; key = \"source\" ) src_data = ricker_wavelet ( src_geom . t [ 1 ], src_geom . dt [ 1 ], f ) q = judiVector ( src_geom , src_data ); # NOT FOR MANUSCRIPT plot ( q . data [ 1 ]) show () NOT FOR MANUSCRIPT Since our data set consists of $16$ shot records, both `d_obs` and `q` contain the data and geometries for all source positions. We can check the number of source positions with `d_obs.nsrc` and `q.nsrc` and we can extract the part of the vector that corresponds to one or multiple shots with `d_obs[shot_no], q[shot_no]`. We will now set up the forward modeling operator \\mathbf{F}(\\mathbf{m},\\mathbf{q}) \\mathbf{F}(\\mathbf{m},\\mathbf{q}) as a matrix-free operator for the inverse wave equation \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{A}(\\mathbf{m})^{-1} , where \\mathbf{m} \\mathbf{m} is the current model, and source/receiver injection and sampling operators \\mathbf{P}_\\mathrm{s} \\mathbf{P}_\\mathrm{s} and \\mathbf{P}_\\mathrm{r} \\mathbf{P}_\\mathrm{r} . Since the dimensions of the inverse wave equation operator depend on the number of computational time steps, we calculate this number using the get_computational_nt function and set up an info object that contains some dimensionality information required by all operators. Then we can define Pr and Ps as matrix-free operators implementing Devito sparse point injection and interpolation (Louboutin et al., 2017). Multiplications with Ps and Pr represent sampling the wavefield at source/receiver locations, while their adjoints Ps', Pr' denote injecting either source wavelets or shot records into the computational grid. These projection and modelling operators can then be set up in Julia in the following way: # NOT FOR MANUSCRIPT using HDF5 m0 , n , d , o = read ( h5open ( \"overthrust_model.h5\" , \"r\" ), \"m0\" , \"n\" , \"d\" , \"o\" ) model0 = Model (( n [ 1 ], n [ 2 ]), ( d [ 1 ], d [ 2 ]), ( o [ 1 ], o [ 2 ]), m0 ); ntComp = get_computational_nt ( q . geometry , d_obs . geometry , model0 ) info = Info ( prod ( model0 . n ), d_obs . nsrc , ntComp ) Pr = judiProjection ( info , d_obs . geometry ) Ps = judiProjection ( info , q . geometry ) Ainv = judiModeling ( info , model0 ); The forward modeling step can be expressed mathematically as F(\\mathbf{m};\\mathbf{q})=\\mathbf{P}_r\\mathbf{A}^{-1}(\\mathbf{m})\\mathbf{P}_s^\\top\\mathbf{q} F(\\mathbf{m};\\mathbf{q})=\\mathbf{P}_r\\mathbf{A}^{-1}(\\mathbf{m})\\mathbf{P}_s^\\top\\mathbf{q} which is expressed in Julia as d_pred = Pr * Ainv * Ps' * q This forward models all 16 predicted shot records in parallel. Notice that, in instantiating Ainv , we made the wave equation solver implicitly dependent on model0 . Finally, we set up the matrix-free Jacobian operator J and the Gauss\u2013Newton Hessian J' * J . As mentioned in the introduction, J is the partial derivative of the forward modeling operator \\mathbf{F}(\\mathbf{m}, \\mathbf{q}) \\mathbf{F}(\\mathbf{m}, \\mathbf{q}) with respect to the model m and is therefore directly constructed from our modeling operator Pr * Ainv * Ps' and a specified source vector q : J = judiJacobian ( Pr * Ainv * Ps ' , q ); NOT FOR MANUSCRIPT Note that, if we started our Julia session with multiple CPU cores or nodes (`julia -p n`, with `n` being the number of workers), the wave equation solves are automatically parallelized over source locations and all shots are collected in the `d_pred` vector. We can also model a single or subset of shots by indexing the operators with the respective shot numbers. E.g. if we want to model the first two shots, we define `i=[1,2]` and then run `d_sub = Pr[i]*Ainv[i]*Ps[i]'*q[i]`. The FWI gradient would then be given by: `g = J[i]' * (d_pred - d_obs[i])` If we want to solve an adjoint wave equation with the observed data as the adjoint source and restrictions of the wavefields back to the source locations, we can simply run `qad = Ps * Ainv' * Pr' * d_obs`, exemplifying the advantages of casting FWI in a proper computational linear algebra framework. Once we have `J` we can also form the Gauss\u2013Newton Hessian: `H_GN = J' * J` In the context of seismic inversion, the Jacobian is also called the linearized modeling or demigration operator and its adjoint J' is the migration operator. One drawback of this notation is that the forward wavefields for the gradient calculation have to be recomputed, since the forward modeling operator only returns the shot records and not the complete wavefields. For this reason, JUDI has an additional function for computing the gradients of the FWI objective function f,g = fwi_objective(model0,q[i],d_obs[i]) , which takes the current model, source and data vectors as an input and computes the objective value and gradient in parallel without having to recompute the forward wavefields. FWI via gradient descent With expressions for modeling operators, Jacobians and gradients of the FWI objective, we can now implement different FWI algorithms in a few lines of code. We will start with a basic gradient descent example with a line search. To reduce the computational cost of full gradient descent, we will use a stochastic approach in which we only compute the gradient and function value for a randomized subset of source locations. In JUDI, this is accomplished by choosing a random vector of integers between 1 and 16 and indexing the data vectors as described earlier. Furthermore, we will apply a projection operator proj(x) , which prevent velocities (or squared slownesses) becoming negative or too large by clipping values outside the allowed range. A few extra variables are defined in the notebook, but the full algorithm for FWI with stochastic gradient descent and box constraints is implemented as follows: # NOT FOR MANUSCRIPT # Set up bound constraints. v0 = sqrt . ( 1f0 ./ model0 . m ) vmin = ones ( Float32 , model0 . n ) * 1.3f0 vmax = ones ( Float32 , model0 . n ) * 6.5f0 # Fix water column. vmin [ : , 1 : 21 ] = v0 [ : , 1 : 21 ] vmax [ : , 1 : 21 ] = v0 [ : , 1 : 21 ] # Convert to squared slowness. mmin = vec (( 1f0 ./ vmax ) .^ 2 ) mmax = vec (( 1f0 ./ vmin ) .^ 2 ); # NOT FOR MANUSCRIPT maxiter = 10 batchsize = 8 # Number of shots for each iteration. proj ( x ) = reshape ( median ([ vec ( mmin ) vec ( x ) vec ( mmax )], 2 ), model0 . n ) fhistory_SGD = zeros ( Float32 , maxiter ); for j = 1 : maxiter # FWI objective function value and gradient. i = randperm ( d_obs . nsrc )[ 1 : batchsize ] fval , grad = fwi_objective ( model0 , q [ i ], d_obs [ i ]) fhistory_SGD [ j ] = fval # OMIT LINE FROM MANUSCRIPT # Line search and update model. update = backtracking_linesearch ( model0 , q [ i ], d_obs [ i ], fval , grad , proj ; alpha = 1f0 ) model0 . m += reshape ( update , model0 . n ) # Apply box constraints. model0 . m = proj ( model0 . m ) end # NOT FOR MANUSCRIPT model_SGD = copy ( model0 . m ); JUDI's backtracking_linesearch function performs an approximate line search and returns a model update that leads to a decrease of the objective function value (Armijo condition; Nocedal and Wright, 2009). The result after 10 iterations of SGD with box constraints is shown in Figure 2. In practice, where starting models are typically less accurate than in our example, FWI is often performed from low to high frequencies, since the objective function has less local minima for lower frequencies (Bunks et al., 1995). In this multi-scale FWI approach, a low-pass filtered version of the data is used to invert for a low resolution velocity model first and higher frequencies are added in subsequent iterations. FWI via the Gauss\u2013Newton method As discussed earlier, the convergence rate of GD depends on the objective function, but requires many FWI iterations necessary to reach an acceptable solution. Using our matrix-free operator for the Jacobian J, we can modify the above code to implement the Gauss\u2013Newton method (Equation 3) to improve the convergence rate. In practice, directly inverting the Gauss\u2013Newton Hessian J'* J should be avoided, because the matrix is badly conditioned and takes many iterations to invert. Instead, we perform a few iterations of a least-squares solver, lsqr() , to approximately solve J * p = d_pred - d_obs and obtain the update direction p . lsqr , from the Julia IterativeSolvers package, is a conjugate-gradient type algorithm for solving least squares problems and is mathematically equivalent to inverting J' * J , but has better numerical properties (Paige and Saunders, 1982). We implement the Gauss-Newton method as follows: # NOT FOR MANUSCRIPT model0 . m = m0 # Reset velocity model. fhistory_GN = zeros ( Float32 , maxiter ); using IterativeSolvers DO NOT RUN BY ACCIDENT # OMIT LINE FROM MANUSCRIPT for j = 1 : maxiter # Model predicted data. d_pred = Pr * Ainv * Ps ' * q # GN update direction. p = lsqr ( J , d_pred - d_obs ; maxiter = 6 ) fhistory_GN [ j ] = . 5f0 * norm ( d_pred - d_obs ) ^ 2 # OMIT LINE FROM MANUSCRIPT # update model and box constraints. model0 . m = model0 . m - reshape ( p , model0 . n ) end NOT FOR MANUSCRIPT An important benefit of matrix-free operators is that we do not need to implement our own least-squares solver, but can pass `J` and the data residual `d_pred - d_obs` to a third-party optimization library. The operator `J` does not need to be an explicit matrix, since `lsqr` only uses matrix-vector products. In contrast to our SGD algorithm, we use all shot records in every iteration, since stochastic methods for second order algorithms are less well understood, making this approach considerably more expensive than our previous algorithm. However, as shown in figures 2 and 3, it achieves a superior result, with a considerably lower misfit compared to the known model. Furthermore, figure 3 shows that it achieves the improved result in relatively few iterations. # NOT FOR MANUSCRIPT figure ( figsize = ( 15 , 12 )) subplot ( 311 ) imshow ( sqrt . ( 1f0 ./ m0 ) ' , cmap = \"GnBu\" , extent = ( 0 , 10 , 3 , 0 ), vmin = 1.5 , vmax = 5.4 ) text ( 0.15 , 0.3 , \"Starting model\" , size = 14 , color = \"black\" ) ylabel ( \"Depth [km]\" , size = 12 ) colorbar () text ( 10.35 , 1.5 , \"Velocity [km/s]\" , va = \"center\" , size = 12 , rotation = 90 ) subplot ( 312 ) imshow ( sqrt . ( 1f0 ./ model_SGD ) ' , cmap = \"GnBu\" , extent = ( 0 , 10 , 3 , 0 ), vmin = 1.5 , vmax = 5.4 ) misfit = round ( fhistory_SGD [ end ], 3 ) text ( 0.15 , 0.3 , \"Gradient descent, misfit = $misfit \" , size = 14 , color = \"black\" ) ylabel ( \"Depth [km]\" , size = 12 ) colorbar () text ( 10.35 , 1.5 , \"Velocity [km/s]\" , va = \"center\" , size = 12 , rotation = 90 ) subplot ( 313 ) imshow ( sqrt . ( 1f0 ./ model0 . m ) ' , cmap = \"GnBu\" , extent = ( 0 , 10 , 3 , 0 ), vmin = 1.5 , vmax = 5.4 ) misfit = round ( fhistory_GN [ end ], 3 ) text ( 0.15 , 0.3 , \"Gauss\u2013Newton, misfit = $misfit \" , size = 14 , color = \"black\" ) xlabel ( \"Lateral position [km]\" , size = 12 ) ylabel ( \"Depth [km]\" , size = 12 ) colorbar () text ( 10.35 , 1.5 , \"Velocity [km/s]\" , va = \"center\" , size = 12 , rotation = 90 ) savefig ( \"../Figures/Figure_2.png\" , dpi = 300 ) show () Figure 2 : (a) Initial model. (b) Recovered velocity model after 10 iterations of stochastic gradient descent with box constraints and a batch size of 8 shots. \u00a9 Recovered velocity model after 10 iterations of the Gauss\u2013Newton method, with 6 iterations of LSQR for the Gauss\u2013Newton subproblem, and using all shots in every iteration. The resulting misfit is substantially lower that what was achieved with gradient descent. # NOT FOR MANUSCRIPT fhistory_SGD = fhistory_SGD / norm ( fhistory_SGD , Inf ) fhistory_GN = fhistory_GN / norm ( fhistory_GN , Inf ); # NOT FOR MANUSCRIPT figure ( figsize = ( 8 , 3 )) plot ( 1 : 10 , fhistory_SGD , label = \"Gradient descent\" ) plot ( 1 : 10 , fhistory_GN , label = \"Gauss\u2013Newton\" ) text ( 9.8 , 0.28 , \"Gradient descent\" , ha = \"right\" , color = \"steelblue\" ) text ( 9.8 , 0.09 , \"Gauss\u2013Newton\" , ha = \"right\" , color = \"chocolate\" ) xlabel ( \"Iteration number\" , size = 12 ) ylabel ( \"Misfit\" , size = 12 ) xlim ( 1 , 10 ) savefig ( \"../Figures/Figure_3.png\" , dpi = 300 ) show () Figure 3 : Normalized function values for the FWI inversion example with stochastic gradient descent and the Gauss-Newton method. An alternative to (Gauss\u2013)Newton methods are quasi-Newton methods, which build up an approximation of the Hessian from previous gradients only and require no additional PDE solves or matrix inversions. Implementing an efficient and correct version of this method, such as the L-BFGS algorithm, exceeds a few lines of code and we therefore leave this exercise to the reader. Instead of implementing more complicated algorithms by hand, it is also possible to interface third-party Julia optimization libraries and an example for this is given in the notebook fwi_example_NLopt.ipynb . Even though all examples shown here are two-dimensional, in order to make them reproducible on a laptop or desktop PC, JUDI can be used for 3D modeling and inversion without having to change the code, since the number of dimensions are automatically inferred from the velocity model and data dimensions. Conclusions In this final part of our FWI tutorial series, we demonstrated how to set up basic optimization algorithms for waveform inversion using JUDI. The methods shown here are all gradient based and differ in the way how update directions for the velocity model are computed. Our numerical examples can serve for the reader as a basis for developing more advanced FWI workflows, which usually include additional data preprocessing, frequency continuation techniques or further model constraints. Acknowledgments This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre. References Aminzadeh, F., Brac, J., and Kunz, T., 1997. 3D Salt and Overthrust models. SEG/EAGE Modeling Series, No. 1: Distribution CD of Salt and Overthrust models, SEG Book Series Tulsa, Oklahoma. Bezanson, J., Karpinski, S., Shah, V. B., and Edelman, A., 2012, Julia: A fast dynamic language for technical computing: CoRR. Retrieved from http://arxiv.org/abs/1209.5145 Bunks, C., Saleck, F. M., Zaleski, S., and Chavent, G., 1995, Multiscale seismic waveform inversion: GEOPHYSICS, 60, 1457\u20131473. doi:10.1190/1.1443880 Johnson, S., 2017, Calling python functions from the julia language: GitHub repository. https://github.com/JuliaPy/PyCall.jl ; GitHub. Lange, M., Kukreja, N., Louboutin, M., Luporini, F., Zacarias, F. V., Pandolfo, V., \u2026 Gorman, G., 2016, Devito: Towards a generic finite difference DSL using symbolic python: 6 th workshop on python for high-performance and scientific computing. doi:10.1109/PyHPC.2016.9 Leeuwen, T. van, Aravkin, A. Y., Calandra, H., and Herrmann, F. J., 2013, In which domain should we measure the misfit for robust full waveform inversion? EAGE annual conference proceedings. doi:10.3997/2214-4609.20130839 Louboutin, M., Witte, P. A., Lange, M., Kukreja, N., Luporini, F., Gorman, G., and Herrmann, F. J., 2017, Full-waveform inversion - part 1: Forward modeling: Retrieved from https://www.slim.eos.ubc.ca/Publications/Private/Submitted/2017/louboutin2017fwi/louboutin2017fwi.html Louboutin, M., Witte, P. A., Lange, M., Kukreja, N., Luporini, F., Gorman, G., and Herrmann, F. J., 2018, Full-waveform inversion - part 2: Adjoint modeling: Nocedal, J., and Wright, S., 2009, Numerical optimization: (2 nd ed.). Springer. Paige, C. C., and Saunders, M. A., 1982, LSQR: An algorithm for sparse linear equations and sparse least squares: ACM Trans. Math. Softw., 8, 43\u201371. doi:10.1145/355984.355989 Peters, B., and Herrmann, F. J., 2017, Constraints versus penalties for edge-preserving full-waveform inversion: The Leading Edge, 36, 94\u2013100. doi:10.1190/tle36010094.1 Warner, M., and Guasch, L., 2014, Adaptive waveform inversion: Theory: In SEG technical program expanded abstracts 2014 (pp. 1089\u20131093). doi:10.1190/segam2014-0371.1","title":"FWI and algorithms"},{"location":"tutorials/TLE_fwi/#geophysics-tutorial","text":"","title":"Geophysics tutorial"},{"location":"tutorials/TLE_fwi/#full-waveform-inversion-part-3-optimization","text":"Philipp Witte 1 *, Mathias Louboutin 1 , Keegan Lensink 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: pwitte@eoas.ubc.ca","title":"Full-Waveform Inversion - Part 3: optimization"},{"location":"tutorials/TLE_fwi/#introduction","text":"This tutorial is the third part of a full-waveform inversion (FWI) tutorial series with a step-by-step walkthrough of setting up forward and adjoint wave equations and building a basic FWI inversion framework. For discretizing and solving wave equations, we use Devito , a Python-based domain-specific language for automated generation of finite-difference code (Lange et al., 2016). The first two parts of this tutorial (Louboutin et al., 2017, 2018) demonstrated how to solve the acoustic wave equation for modeling seismic shot records and how to compute the gradient of the FWI objective function using the adjoint-state method. With these two key ingredients, we will now build an inversion framework that can be used to minimize the FWI least-squares objective function. FWI is a computationally and mathematically challenging problem. The computational complexity comes from the fact that an already expensive solution procedure for the wave equation needs to be repeated for a large number of source positions for each iteration of the optimization algorithm. The mathematical complexity comes from the fact that the FWI objective is known to have many local minima due to cycle skipping.","title":"Introduction"},{"location":"tutorials/TLE_fwi/#optimizing-the-fwi-objective-function","text":"The goal of this tutorial series is to optimize the FWI objective function with the \\ell_2 \\ell_2 -misfit: \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_s} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_s} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, where \\mathbf{d}^\\mathrm{pred}_i \\mathbf{d}^\\mathrm{pred}_i and \\mathbf{d}^\\mathrm{obs}_i \\mathbf{d}^\\mathrm{obs}_i are the predicted and observed seismic shot records of the i^{\\text{th}} i^{\\text{th}} source location and \\mathbf{m} \\mathbf{m} is the velocity model (expressed as squared slowness). In part one, we demonstrated how to implement a forward modeling operator to generate the predicted shot records, which we will denote as \\mathbf{d}^\\mathrm{pred}_i = \\mathbf{F}(\\mathbf{m},\\mathbf{q}_i) \\mathbf{d}^\\mathrm{pred}_i = \\mathbf{F}(\\mathbf{m},\\mathbf{q}_i) . In the second tutorial, we then showed how we can compute the gradient \\nabla f(\\mathbf{m}) \\nabla f(\\mathbf{m}) of the objective function and update our initial model using gradient descent. There is a snag, however. This first-order optimization algorithm has a linear convergence rate at best, and typically requires many iterations to converge. Second-order optimization methods converge considerably faster. To implement them, we first approximate the objective with a second-order Taylor expansion: f(\\mathbf{m}) = f(\\mathbf{m}_0) + \\nabla f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\delta \\mathbf{m}^\\top \\nabla^2 f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\mathcal{O}(\\delta \\mathbf{m}^3), f(\\mathbf{m}) = f(\\mathbf{m}_0) + \\nabla f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\delta \\mathbf{m}^\\top \\nabla^2 f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\mathcal{O}(\\delta \\mathbf{m}^3), where \\mathcal{O}(\\delta \\mathbf{m}^3) \\mathcal{O}(\\delta \\mathbf{m}^3) represents the error term, \\nabla f(\\mathbf{m}_0) \\nabla f(\\mathbf{m}_0) is the gradient as implemented in part two, and \\nabla^2 f(\\mathbf{m}_0) \\nabla^2 f(\\mathbf{m}_0) is the Hessian of the objective function, which we will refer to as \\mathbf{H} \\mathbf{H} . Rather than using the negative gradient to incrementally update our model, as in gradient descent, we directly calculate a model update \\delta \\mathbf{m} \\delta \\mathbf{m} that leads us to the minimum. This is called Newton's method: \\delta \\mathbf{m} = - \\mathbf{H}(\\mathbf{m}_0)^{-1} \\nabla f(\\mathbf{m}_0). \\delta \\mathbf{m} = - \\mathbf{H}(\\mathbf{m}_0)^{-1} \\nabla f(\\mathbf{m}_0). Although the method converges to the minimum of the FWI objective function quickly, it comes at the cost of having to compute and invert the Hessian matrix (Nocedal and Wright, 2009). Fortunately, for least squares problems, such as FWI, the Hessian can be approximated by the Gauss-Newton (GN) Hessian \\mathbf{J}^\\top \\mathbf{J} \\mathbf{J}^\\top \\mathbf{J} , where \\mathbf{J} \\mathbf{J} is the Jacobian matrix. This is the partial derivative of the forward modeling operator \\mathbf{F}(\\mathbf{m},\\mathbf{q}) \\mathbf{F}(\\mathbf{m},\\mathbf{q}) with respect to \\mathbf{m} \\mathbf{m} \u2014 something we can easily compute. Furthermore, the Jacobian can also be used to express the gradient of the FWI objective function as \\nabla f(\\mathbf{m}_0) = \\mathbf{J}^\\top (\\mathbf{d}^\\mathrm{pred}_i - \\mathbf{d}_i^\\mathrm{obs}) \\nabla f(\\mathbf{m}_0) = \\mathbf{J}^\\top (\\mathbf{d}^\\mathrm{pred}_i - \\mathbf{d}_i^\\mathrm{obs}) , where \\mathbf{J}^\\top \\mathbf{J}^\\top is the adjoint (transposed) Jacobian. This is useful, because we now have a set of operators \\mathbf{F}, \\mathbf{J} \\mathbf{F}, \\mathbf{J} and \\mathbf{H}_{GN}=\\mathbf{J}^\\top\\mathbf{J} \\mathbf{H}_{GN}=\\mathbf{J}^\\top\\mathbf{J} , through which we can express both first and second order optimization algorithms for FWI. Although forming these matrices explicitly is not possible, since they can become extremely large, we only need the action of these operators on vectors. This allows us to implement these operators matrix-free. In the following section we will demonstrate how to set up these operators in our JUDI software framework and to how to use them to implement FWI algorithms.","title":"Optimizing the FWI objective function"},{"location":"tutorials/TLE_fwi/#implementing-fwi-in-judi","text":"We start our demonstration by reading our data set, which consists of 16 shot records and was generated with an excerpt from the SEG/EAGE Overthrust model (Aminzadeh et al. 1997). We store it as a judiVector : block = segy_read ( \"overthrust_shot_records.segy\" ) d_obs = judiVector ( block ); \u001b[1m\u001b[33mWARNING: \u001b[39m\u001b[22m\u001b[33mFixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=7076688, maxsize=Inf, ptr=3601, mark=-1)\u001b[39m # NOT FOR MANUSCRIPT using PyPlot i = 8 figure ( figsize = ( 15 , 6 )) imshow ( d_obs . data [ i ], cmap = \"seismic\" , extent = [ 0 , size ( d_obs . data [ i ], 2 ), 2 , 0 ], aspect = 0.3 , vmin =- 3 , vmax = 3 ) ax1 = gca (); ax1 [ : set_aspect ]( \"auto\" ) xlabel ( \"Receiver number\" , size = 12 ) ylabel ( \"Time [s]\" , size = 12 ) text ( 3 , 0.13 , \"Shot record $i \" , size = 16 ) colorbar () savefig ( \"../Figures/Figure_1.png\" , dpi = 300 ) show () Figure 1 : Observed shot record number 8. JUDI vectors such as d_obs can be used like a regular Julia vectors, so we can compute norms via norm(d_obs) or the inner product via dot(d_obs, d_obs) , but they contain the shot records in their original dimension. Shot records can be accessed via their respective shot number with d_obs.data[shot_no] , while the header information can be accessed with d_obs.geometry . We extract the source geometry from our SEG-Y file and then manually set up a source vector q with an 8 Hz Ricker wavelet: f = 0.008 # kHz src_geom = Geometry ( block ; key = \"source\" ) src_data = ricker_wavelet ( src_geom . t [ 1 ], src_geom . dt [ 1 ], f ) q = judiVector ( src_geom , src_data ); # NOT FOR MANUSCRIPT plot ( q . data [ 1 ]) show ()","title":"Implementing FWI in JUDI"},{"location":"tutorials/TLE_fwi/#fwi-via-gradient-descent","text":"With expressions for modeling operators, Jacobians and gradients of the FWI objective, we can now implement different FWI algorithms in a few lines of code. We will start with a basic gradient descent example with a line search. To reduce the computational cost of full gradient descent, we will use a stochastic approach in which we only compute the gradient and function value for a randomized subset of source locations. In JUDI, this is accomplished by choosing a random vector of integers between 1 and 16 and indexing the data vectors as described earlier. Furthermore, we will apply a projection operator proj(x) , which prevent velocities (or squared slownesses) becoming negative or too large by clipping values outside the allowed range. A few extra variables are defined in the notebook, but the full algorithm for FWI with stochastic gradient descent and box constraints is implemented as follows: # NOT FOR MANUSCRIPT # Set up bound constraints. v0 = sqrt . ( 1f0 ./ model0 . m ) vmin = ones ( Float32 , model0 . n ) * 1.3f0 vmax = ones ( Float32 , model0 . n ) * 6.5f0 # Fix water column. vmin [ : , 1 : 21 ] = v0 [ : , 1 : 21 ] vmax [ : , 1 : 21 ] = v0 [ : , 1 : 21 ] # Convert to squared slowness. mmin = vec (( 1f0 ./ vmax ) .^ 2 ) mmax = vec (( 1f0 ./ vmin ) .^ 2 ); # NOT FOR MANUSCRIPT maxiter = 10 batchsize = 8 # Number of shots for each iteration. proj ( x ) = reshape ( median ([ vec ( mmin ) vec ( x ) vec ( mmax )], 2 ), model0 . n ) fhistory_SGD = zeros ( Float32 , maxiter ); for j = 1 : maxiter # FWI objective function value and gradient. i = randperm ( d_obs . nsrc )[ 1 : batchsize ] fval , grad = fwi_objective ( model0 , q [ i ], d_obs [ i ]) fhistory_SGD [ j ] = fval # OMIT LINE FROM MANUSCRIPT # Line search and update model. update = backtracking_linesearch ( model0 , q [ i ], d_obs [ i ], fval , grad , proj ; alpha = 1f0 ) model0 . m += reshape ( update , model0 . n ) # Apply box constraints. model0 . m = proj ( model0 . m ) end # NOT FOR MANUSCRIPT model_SGD = copy ( model0 . m ); JUDI's backtracking_linesearch function performs an approximate line search and returns a model update that leads to a decrease of the objective function value (Armijo condition; Nocedal and Wright, 2009). The result after 10 iterations of SGD with box constraints is shown in Figure 2. In practice, where starting models are typically less accurate than in our example, FWI is often performed from low to high frequencies, since the objective function has less local minima for lower frequencies (Bunks et al., 1995). In this multi-scale FWI approach, a low-pass filtered version of the data is used to invert for a low resolution velocity model first and higher frequencies are added in subsequent iterations.","title":"FWI via gradient descent"},{"location":"tutorials/TLE_fwi/#fwi-via-the-gaussnewton-method","text":"As discussed earlier, the convergence rate of GD depends on the objective function, but requires many FWI iterations necessary to reach an acceptable solution. Using our matrix-free operator for the Jacobian J, we can modify the above code to implement the Gauss\u2013Newton method (Equation 3) to improve the convergence rate. In practice, directly inverting the Gauss\u2013Newton Hessian J'* J should be avoided, because the matrix is badly conditioned and takes many iterations to invert. Instead, we perform a few iterations of a least-squares solver, lsqr() , to approximately solve J * p = d_pred - d_obs and obtain the update direction p . lsqr , from the Julia IterativeSolvers package, is a conjugate-gradient type algorithm for solving least squares problems and is mathematically equivalent to inverting J' * J , but has better numerical properties (Paige and Saunders, 1982). We implement the Gauss-Newton method as follows: # NOT FOR MANUSCRIPT model0 . m = m0 # Reset velocity model. fhistory_GN = zeros ( Float32 , maxiter ); using IterativeSolvers DO NOT RUN BY ACCIDENT # OMIT LINE FROM MANUSCRIPT for j = 1 : maxiter # Model predicted data. d_pred = Pr * Ainv * Ps ' * q # GN update direction. p = lsqr ( J , d_pred - d_obs ; maxiter = 6 ) fhistory_GN [ j ] = . 5f0 * norm ( d_pred - d_obs ) ^ 2 # OMIT LINE FROM MANUSCRIPT # update model and box constraints. model0 . m = model0 . m - reshape ( p , model0 . n ) end","title":"FWI via the Gauss\u2013Newton method"},{"location":"tutorials/TLE_fwi/#conclusions","text":"In this final part of our FWI tutorial series, we demonstrated how to set up basic optimization algorithms for waveform inversion using JUDI. The methods shown here are all gradient based and differ in the way how update directions for the velocity model are computed. Our numerical examples can serve for the reader as a basis for developing more advanced FWI workflows, which usually include additional data preprocessing, frequency continuation techniques or further model constraints.","title":"Conclusions"},{"location":"tutorials/TLE_fwi/#acknowledgments","text":"This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre.","title":"Acknowledgments"},{"location":"tutorials/TLE_fwi/#references","text":"Aminzadeh, F., Brac, J., and Kunz, T., 1997. 3D Salt and Overthrust models. SEG/EAGE Modeling Series, No. 1: Distribution CD of Salt and Overthrust models, SEG Book Series Tulsa, Oklahoma. Bezanson, J., Karpinski, S., Shah, V. B., and Edelman, A., 2012, Julia: A fast dynamic language for technical computing: CoRR. Retrieved from http://arxiv.org/abs/1209.5145 Bunks, C., Saleck, F. M., Zaleski, S., and Chavent, G., 1995, Multiscale seismic waveform inversion: GEOPHYSICS, 60, 1457\u20131473. doi:10.1190/1.1443880 Johnson, S., 2017, Calling python functions from the julia language: GitHub repository. https://github.com/JuliaPy/PyCall.jl ; GitHub. Lange, M., Kukreja, N., Louboutin, M., Luporini, F., Zacarias, F. V., Pandolfo, V., \u2026 Gorman, G., 2016, Devito: Towards a generic finite difference DSL using symbolic python: 6 th workshop on python for high-performance and scientific computing. doi:10.1109/PyHPC.2016.9 Leeuwen, T. van, Aravkin, A. Y., Calandra, H., and Herrmann, F. J., 2013, In which domain should we measure the misfit for robust full waveform inversion? EAGE annual conference proceedings. doi:10.3997/2214-4609.20130839 Louboutin, M., Witte, P. A., Lange, M., Kukreja, N., Luporini, F., Gorman, G., and Herrmann, F. J., 2017, Full-waveform inversion - part 1: Forward modeling: Retrieved from https://www.slim.eos.ubc.ca/Publications/Private/Submitted/2017/louboutin2017fwi/louboutin2017fwi.html Louboutin, M., Witte, P. A., Lange, M., Kukreja, N., Luporini, F., Gorman, G., and Herrmann, F. J., 2018, Full-waveform inversion - part 2: Adjoint modeling: Nocedal, J., and Wright, S., 2009, Numerical optimization: (2 nd ed.). Springer. Paige, C. C., and Saunders, M. A., 1982, LSQR: An algorithm for sparse linear equations and sparse least squares: ACM Trans. Math. Softw., 8, 43\u201371. doi:10.1145/355984.355989 Peters, B., and Herrmann, F. J., 2017, Constraints versus penalties for edge-preserving full-waveform inversion: The Leading Edge, 36, 94\u2013100. doi:10.1190/tle36010094.1 Warner, M., and Guasch, L., 2014, Adaptive waveform inversion: Theory: In SEG technical program expanded abstracts 2014 (pp. 1089\u20131093). doi:10.1190/segam2014-0371.1","title":"References"},{"location":"tutorials/accuracy/","text":"import numpy as np from scipy.special import hankel2 from examples.seismic.acoustic import AcousticWaveSolver from examples.seismic import Model , RickerSource , Receiver , TimeAxis , AcquisitionGeometry from devito import set_log_level from benchmarks.user.tools.plotter import LinePlotter import matplotlib.pyplot as plt from matplotlib import cm % matplotlib inline # Switch to error logging so that info is printed but runtime is hidden from devito import configuration configuration [ 'log-level' ] = 'ERROR' # Model with fixed time step value class ModelBench ( Model ): \"\"\" Physical model used for accuracy benchmarking. The critical dt is made small enough to ignore time discretization errors \"\"\" @property def critical_dt ( self ): \"\"\"Critical computational time step value.\"\"\" return . 1 Verification We compute the error between the numerical and reference solutions for varying spatial discretization order and grid spacing. We also compare the time to solution to the error for these parameters. # Discretization order orders = ( 2 , 4 , 6 , 8 , 10 ) norder = len ( orders ) # Number of time steps nt = 1501 # Time axis dt = 0.1 t0 = 0. tn = dt * ( nt - 1 ) time = np . linspace ( t0 , tn , nt ) print ( \"t0, tn, dt, nt; %.4f %.4f %.4f %d \" % ( t0 , tn , dt , nt )) # Source peak frequency in KHz f0 = . 09 t0, tn, dt, nt; 0.0000 150.0000 0.1000 1501 # Domain sizes and gird spacing shapes = (( 201 , 2.0 ), ( 161 , 2.5 ), ( 101 , 4.0 )) dx = [ 2.0 , 2.5 , 4.0 ] nshapes = len ( shapes ) # Fine grid model c0 = 1.5 model = ModelBench ( vp = c0 , origin = ( 0. , 0. ), spacing = ( . 5 , . 5 ), bcs = \"damp\" , shape = ( 801 , 801 ), space_order = 20 , nbl = 40 , dtype = np . float32 ) # Source and receiver geometries src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = 200. # Single receiver offset 100 m from source rec_coordinates = np . empty (( 1 , 2 )) rec_coordinates [:, :] = 260. print ( \"The computational Grid has ( %s , %s ) grid points \" \"and a physical extent of ( %s m, %s m)\" % ( * model . grid . shape , * model . grid . extent )) print ( \"Source is at the center with coordinates ( %s m, %s m)\" % tuple ( src_coordinates [ 0 ])) print ( \"Receiver (single receiver) is located at ( %s m, %s m) \" % tuple ( rec_coordinates [ 0 ])) # Note: gets time sampling from model.critical_dt geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 = t0 , tn = tn , src_type = 'Ricker' , f0 = f0 , t0w = 1.5 / f0 ) The computational Grid has (881, 881) grid points and a physical extent of (440.0m, 440.0m) Source is at the center with coordinates (200.0m, 200.0m) Receiver (single receiver) is located at (260.0m, 260.0m) Reference solution for numerical convergence solver = AcousticWaveSolver ( model , geometry , kernel = 'OT2' , space_order = 8 ) ref_rec , ref_u , _ = solver . forward () Analytical solution for comparison with the reference numerical solution The analytical solution of the 2D acoustic wave-equation with a source pulse is defined as: \\begin{aligned} u_s(r, t) &= \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} \\{ -i \\pi H_0^{(2)}\\left(k r \\right) q(\\omega) e^{i\\omega t} d\\omega\\}\\\\[10pt] r &= \\sqrt{(x - x_{src})^2+(y - y_{src})^2} \\end{aligned} \\begin{aligned} u_s(r, t) &= \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} \\{ -i \\pi H_0^{(2)}\\left(k r \\right) q(\\omega) e^{i\\omega t} d\\omega\\}\\\\[10pt] r &= \\sqrt{(x - x_{src})^2+(y - y_{src})^2} \\end{aligned} where H_0^{(2)} H_0^{(2)} is the Hankel function of the second kind, F(\\omega) F(\\omega) is the Fourier spectrum of the source time function at angular frequencies \\omega \\omega and k = \\frac{\\omega}{v} k = \\frac{\\omega}{v} is the wavenumber. We look at the analytical and numerical solution at a single grid point. We ensure that this grid point is on-the-grid for all discretizations analyised in the further verification. # Source and receiver coordinates sx , sz = src_coordinates [ 0 , :] rx , rz = rec_coordinates [ 0 , :] # Define a Ricker wavelet shifted to zero lag for the Fourier transform def ricker ( f , T , dt , t0 ): t = np . linspace ( - t0 , T - t0 , int ( T / dt )) tt = ( np . pi ** 2 ) * ( f ** 2 ) * ( t ** 2 ) y = ( 1.0 - 2.0 * tt ) * np . exp ( - tt ) return y def analytical ( nt , model , time , ** kwargs ): dt = kwargs . get ( 'dt' , model . critical_dt ) # Fourier constants nf = int ( nt / 2 + 1 ) fnyq = 1. / ( 2 * dt ) df = 1.0 / time [ - 1 ] faxis = df * np . arange ( nf ) wavelet = ricker ( f0 , time [ - 1 ], dt , 1.5 / f0 ) # Take the Fourier transform of the source time-function R = np . fft . fft ( wavelet ) R = R [ 0 : nf ] nf = len ( R ) # Compute the Hankel function and multiply by the source spectrum U_a = np . zeros (( nf ), dtype = complex ) for a in range ( 1 , nf - 1 ): k = 2 * np . pi * faxis [ a ] / c0 tmp = k * np . sqrt ((( rx - sx )) ** 2 + (( rz - sz )) ** 2 ) U_a [ a ] = - 1 j * np . pi * hankel2 ( 0.0 , tmp ) * R [ a ] # Do inverse fft on 0:dt:T and you have analytical solution U_t = 1.0 / ( 2.0 * np . pi ) * np . real ( np . fft . ifft ( U_a [:], nt )) # The analytic solution needs be scaled by dx^2 to convert to pressure return np . real ( U_t ) * ( model . spacing [ 0 ] ** 2 ) time1 = np . linspace ( 0.0 , 3000. , 30001 ) U_t = analytical ( 30001 , model , time1 , dt = time1 [ 1 ] - time1 [ 0 ]) U_t = U_t [ 0 : 1501 ] #NBVAL_IGNORE_OUTPUT print ( \"Numerical data min,max,abs; %+.6e %+.6e %+.6e \" % ( np . min ( ref_rec . data ), np . max ( ref_rec . data ), np . max ( np . abs ( ref_rec . data )) )) print ( \"Analytic data min,max,abs; %+.6e %+.6e %+.6e \" % ( np . min ( U_t ), np . max ( U_t ), ( np . max ( np . abs ( U_t ))))) Numerical data min,max,abs; -5.349830e-03 +8.529913e-03 +8.529913e-03 Analytic data min,max,abs; -5.322232e-03 +8.543911e-03 +8.543911e-03 # Plot wavefield and source/rec position plt . figure ( figsize = ( 8 , 8 )) amax = np . max ( np . abs ( ref_u . data [ 1 ,:,:])) plt . imshow ( ref_u . data [ 1 ,:,:], vmin =- 1.0 * amax , vmax =+ 1.0 * amax , cmap = \"seismic\" ) plt . plot ( 2 * sx + 40 , 2 * sz + 40 , 'r*' , markersize = 11 , label = 'source' ) # plot position of the source in model, add nbl for correct position plt . plot ( 2 * rx + 40 , 2 * rz + 40 , 'k^' , markersize = 8 , label = 'receiver' ) # plot position of the receiver in model, add nbl for correct position plt . legend () plt . xlabel ( 'x position (m)' ) plt . ylabel ( 'z position (m)' ) plt . savefig ( 'wavefieldperf.pdf' ) # Plot trace plt . figure ( figsize = ( 12 , 8 )) plt . subplot ( 2 , 1 , 1 ) plt . plot ( time , ref_rec . data [:, 0 ], '-b' , label = 'numerical' ) plt . plot ( time , U_t [:], '--r' , label = 'analytical' ) plt . xlim ([ 0 , 150 ]) plt . ylim ([ 1.15 * np . min ( U_t [:]), 1.15 * np . max ( U_t [:])]) plt . xlabel ( 'time (ms)' ) plt . ylabel ( 'amplitude' ) plt . legend () plt . subplot ( 2 , 1 , 2 ) plt . plot ( time , 100 * ( ref_rec . data [:, 0 ] - U_t [:]), '-b' , label = 'difference x100' ) plt . xlim ([ 0 , 150 ]) plt . ylim ([ 1.15 * np . min ( U_t [:]), 1.15 * np . max ( U_t [:])]) plt . xlabel ( 'time (ms)' ) plt . ylabel ( 'amplitude x100' ) plt . legend () plt . savefig ( 'ref.pdf' ) plt . show () #NBVAL_IGNORE_OUTPUT error_time = np . zeros ( 5 ) error_time [ 0 ] = np . linalg . norm ( U_t [: - 1 ] - ref_rec . data [: - 1 , 0 ], 2 ) / np . sqrt ( nt ) errors_plot = [( time , U_t [: - 1 ] - ref_rec . data [: - 1 , 0 ])] print ( error_time [ 0 ]) 1.1274823771092997e-05 Convergence in time We first show the convergence of the time discretization for a fix high-order spatial discretization (20 th order). After we show that the time discretization converges in O(dt^2) O(dt^2) and therefore only contains the error in time, we will take the numerical solution for dt=.1ms as a reference for the spatial discretization analysis. #NBVAL_IGNORE_OUTPUT dt = [ 0.1000 , 0.0800 , 0.0750 , 0.0625 , 0.0500 ] nnt = ( np . divide ( 150.0 , dt ) + 1 ) . astype ( int ) for i in range ( 1 , 5 ): # Time axis t0 = 0.0 tn = 150.0 time = np . linspace ( t0 , tn , nnt [ i ]) # Source geometry src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = 200. # Single receiver offset 100 m from source rec_coordinates = np . empty (( 1 , 2 )) rec_coordinates [:, :] = 260. geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 = t0 , tn = tn , src_type = 'Ricker' , f0 = f0 , t0w = 1.5 / f0 ) # Note: incorrect data size will be generated here due to AcquisitionGeometry bug ... # temporarily fixed below by resizing the output from the solver geometry . resample ( dt [ i ]) print ( \"geometry.time_axes; \" , geometry . time_axis ) solver = AcousticWaveSolver ( model , geometry , time_order = 2 , space_order = 8 ) ref_rec1 , ref_u1 , _ = solver . forward ( dt = dt [ i ]) ref_rec1_data = ref_rec1 . data [ 0 : nnt [ i ],:] time1 = np . linspace ( 0.0 , 3000. , 20 * ( nnt [ i ] - 1 ) + 1 ) U_t1 = analytical ( 20 * ( nnt [ i ] - 1 ) + 1 , model , time1 , dt = time1 [ 1 ] - time1 [ 0 ]) U_t1 = U_t1 [ 0 : nnt [ i ]] error_time [ i ] = np . linalg . norm ( U_t1 [: - 1 ] - ref_rec1_data [: - 1 , 0 ], 2 ) / np . sqrt ( nnt [ i ] - 1 ) ratio_d = dt [ i - 1 ] / dt [ i ] if i > 0 else 1.0 ratio_e = error_time [ i - 1 ] / error_time [ i ] if i > 0 else 1.0 print ( \"error for dt= %.4f is %12.6e -- ratio dt^2,ratio err; %12.6f %12.6f \\n \" % ( dt [ i ], error_time [ i ], ratio_d ** 2 , ratio_e )) errors_plot . append (( geometry . time_axis . time_values , U_t1 [: - 1 ] - ref_rec1_data [: - 1 , 0 ])) geometry.time_axes; TimeAxis: start=0, stop=150.08, step=0.08, num=1877 error for dt=0.0800 is 7.403730e-06 -- ratio dt^2,ratio err; 1.562500 1.522857 geometry.time_axes; TimeAxis: start=0, stop=150, step=0.075, num=2001 error for dt=0.0750 is 6.557951e-06 -- ratio dt^2,ratio err; 1.137778 1.128970 geometry.time_axes; TimeAxis: start=0, stop=150, step=0.0625, num=2401 error for dt=0.0625 is 4.647428e-06 -- ratio dt^2,ratio err; 1.440000 1.411093 geometry.time_axes; TimeAxis: start=0, stop=150, step=0.05, num=3001 error for dt=0.0500 is 3.026210e-06 -- ratio dt^2,ratio err; 1.562500 1.535726 plt . figure ( figsize = ( 20 , 10 )) theory = [ t ** 2 for t in dt ] theory = [ error_time [ 0 ] * th / theory [ 0 ] for th in theory ] plt . loglog ([ t for t in dt ], error_time , '-ob' , label = ( 'Numerical' ), linewidth = 4 , markersize = 10 ) plt . loglog ([ t for t in dt ], theory , '-^r' , label = ( 'Theory (2nd order)' ), linewidth = 4 , markersize = 10 ) for x , y , a in zip ([ t for t in dt ], theory , [( 'dt = %s ms' % ( t )) for t in dt ]): plt . annotate ( a , xy = ( x , y ), xytext = ( 4 , 2 ), textcoords = 'offset points' , size = 20 , horizontalalignment = 'left' , verticalalignment = 'top' ) plt . xlabel ( \"Time-step $dt$ (ms)\" , fontsize = 20 ) plt . ylabel ( \"$|| u_ {num} - u_ {ana} ||_2$\" , fontsize = 20 ) plt . tick_params ( axis = 'both' , which = 'both' , labelsize = 20 ) plt . tight_layout () plt . xlim (( 0.05 , 0.1 )) plt . legend ( fontsize = 20 , ncol = 4 , fancybox = True , loc = 'best' ) plt . savefig ( \"TimeConvergence.pdf\" , format = 'pdf' , facecolor = 'white' , orientation = 'landscape' , bbox_inches = 'tight' ) plt . show () #NBVAL_IGNORE_OUTPUT stylel = ( '--y' , '--b' , '--r' , '--g' , '--c' ) start_t = lambda dt : int ( 50 / dt ) end_t = lambda dt : int ( 100 / dt ) plt . figure ( figsize = ( 20 , 10 )) for i , dti in enumerate ( dt ): timei , erri = errors_plot [ i ] s , e = start_t ( dti ), end_t ( dti ) if i == 0 : plt . plot ( timei [ s : e ], U_t [ s : e ], 'k' , label = 'analytical' , linewidth = 2 ) plt . plot ( timei [ s : e ], 100 * erri [ s : e ], stylel [ i ], label = \"100 x error dt= %s ms\" % dti , linewidth = 2 ) plt . xlim ([ 50 , 100 ]) plt . xlabel ( \"Time (ms)\" , fontsize = 20 ) plt . legend ( fontsize = 20 ) plt . show () #NBVAL_IGNORE_OUTPUT pf = np . polyfit ( np . log ([ t for t in dt ]), np . log ( error_time ), deg = 1 ) print ( \"Convergence rate in time is: %.4f \" % pf [ 0 ]) assert np . isclose ( pf [ 0 ], 1.9 , atol = 0 , rtol =. 1 ) Convergence rate in time is: 1.8966 Convergence in space We have a correct reference solution we can use for space discretization analysis #NBVAL_IGNORE_OUTPUT errorl2 = np . zeros (( norder , nshapes )) timing = np . zeros (( norder , nshapes )) set_log_level ( \"ERROR\" ) ind_o = - 1 for spc in orders : ind_o += 1 ind_spc = - 1 for nn , h in shapes : ind_spc += 1 time = np . linspace ( 0. , 150. , nt ) model_space = ModelBench ( vp = c0 , origin = ( 0. , 0. ), spacing = ( h , h ), bcs = \"damp\" , shape = ( nn , nn ), space_order = spc , nbl = 40 , dtype = np . float32 ) # Source geometry src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = 200. # Single receiver offset 100 m from source rec_coordinates = np . empty (( 1 , 2 )) rec_coordinates [:, :] = 260. geometry = AcquisitionGeometry ( model_space , rec_coordinates , src_coordinates , t0 = t0 , tn = tn , src_type = 'Ricker' , f0 = f0 , t0w = 1.5 / f0 ) solver = AcousticWaveSolver ( model_space , geometry , time_order = 2 , space_order = spc ) loc_rec , loc_u , summary = solver . forward () # Note: we need to correct for fixed spacing pressure corrections in both analytic # (run at the old model spacing) and numerical (run at the new model spacing) solutions c_ana = 1 / model . spacing [ 0 ] ** 2 c_num = 1 / model_space . spacing [ 0 ] ** 2 # Compare to reference solution # Note: we need to normalize by the factor of grid spacing squared errorl2 [ ind_o , ind_spc ] = np . linalg . norm ( loc_rec . data [: - 1 , 0 ] * c_num - U_t [: - 1 ] * c_ana , 2 ) / np . sqrt ( U_t . shape [ 0 ] - 1 ) timing [ ind_o , ind_spc ] = np . max ([ v for _ , v in summary . timings . items ()]) print ( \"starting space order %s with ( %s , %s ) grid points the error is %s for %s seconds runtime\" % ( spc , nn , nn , errorl2 [ ind_o , ind_spc ], timing [ ind_o , ind_spc ])) starting space order 2 with (201, 201) grid points the error is 0.00376890390735257 for 0.11462100000000232 seconds runtime starting space order 2 with (161, 161) grid points the error is 0.005813084671822352 for 0.21845700000000504 seconds runtime starting space order 2 with (101, 101) grid points the error is 0.013011803756815122 for 0.032794999999999366 seconds runtime starting space order 4 with (201, 201) grid points the error is 0.0003403506132631831 for 0.0771300000000017 seconds runtime starting space order 4 with (161, 161) grid points the error is 0.0009417872279623022 for 0.07411399999999989 seconds runtime starting space order 4 with (101, 101) grid points the error is 0.006347337804825049 for 0.041079000000000594 seconds runtime starting space order 6 with (201, 201) grid points the error is 4.502665029531472e-05 for 0.08156900000000102 seconds runtime starting space order 6 with (161, 161) grid points the error is 0.00020691319261459238 for 0.07217499999999948 seconds runtime starting space order 6 with (101, 101) grid points the error is 0.0037431036246854867 for 0.04163999999999989 seconds runtime starting space order 8 with (201, 201) grid points the error is 4.1027806557032715e-05 for 0.10310699999999935 seconds runtime starting space order 8 with (161, 161) grid points the error is 7.128947664631205e-05 for 0.27055700000000116 seconds runtime starting space order 8 with (101, 101) grid points the error is 0.002573508922203025 for 0.04638000000000103 seconds runtime starting space order 10 with (201, 201) grid points the error is 4.4153663464842855e-05 for 0.1793579999999967 seconds runtime starting space order 10 with (161, 161) grid points the error is 4.9407728678141816e-05 for 0.21400200000000336 seconds runtime starting space order 10 with (101, 101) grid points the error is 0.0019485859969163928 for 0.08266899999999956 seconds runtime stylel = ( '-^k' , '-^b' , '-^r' , '-^g' , '-^c' ) plt . figure ( figsize = ( 20 , 10 )) for i in range ( 0 , 5 ): plt . loglog ( errorl2 [ i , :], timing [ i , :], stylel [ i ], label = ( 'order %s ' % orders [ i ]), linewidth = 4 , markersize = 10 ) for x , y , a in zip ( errorl2 [ i , :], timing [ i , :], [( 'dx = %s m' % ( sc )) for sc in dx ]): plt . annotate ( a , xy = ( x , y ), xytext = ( 4 , 2 ), textcoords = 'offset points' , size = 20 ) plt . xlabel ( \"$|| u_ {num} - u_ {ref} ||_ {inf} $\" , fontsize = 20 ) plt . ylabel ( \"Runtime (sec)\" , fontsize = 20 ) plt . tick_params ( axis = 'both' , which = 'both' , labelsize = 20 ) plt . tight_layout () plt . legend ( fontsize = 20 , ncol = 3 , fancybox = True , loc = 'lower left' ) plt . savefig ( \"TimeAccuracy.pdf\" , format = 'pdf' , facecolor = 'white' , orientation = 'landscape' , bbox_inches = 'tight' ) plt . show () stylel = ( '-^k' , '-^b' , '-^r' , '-^g' , '-^c' ) style2 = ( '--k' , '--b' , '--r' , '--g' , '--c' ) plt . figure ( figsize = ( 20 , 10 )) for i in range ( 0 , 5 ): theory = [ k ** ( orders [ i ]) for k in dx ] theory = [ errorl2 [ i , 2 ] * th / theory [ 2 ] for th in theory ] plt . loglog ([ sc for sc in dx ], errorl2 [ i , :], stylel [ i ], label = ( 'Numerical order %s ' % orders [ i ]), linewidth = 4 , markersize = 10 ) plt . loglog ([ sc for sc in dx ], theory , style2 [ i ], label = ( 'Theory order %s ' % orders [ i ]), linewidth = 4 , markersize = 10 ) plt . xlabel ( \"Grid spacing $dx$ (m)\" , fontsize = 20 ) plt . ylabel ( \"$||u_ {num} - u_ {ref} ||_ {inf} $\" , fontsize = 20 ) plt . tick_params ( axis = 'both' , which = 'both' , labelsize = 20 ) plt . tight_layout () plt . legend ( fontsize = 20 , ncol = 2 , fancybox = True , loc = 'lower right' ) # plt.xlim((2.0, 4.0)) plt . savefig ( \"Convergence.pdf\" , format = 'pdf' , facecolor = 'white' , orientation = 'landscape' , bbox_inches = 'tight' ) plt . show () #NBVAL_IGNORE_OUTPUT for i in range ( 5 ): pf = np . polyfit ( np . log ([ sc for sc in dx ]), np . log ( errorl2 [ i , :]), deg = 1 )[ 0 ] if i == 3 : pf = np . polyfit ( np . log ([ sc for sc in dx ][ 1 :]), np . log ( errorl2 [ i , 1 :]), deg = 1 )[ 0 ] print ( \"Convergence rate for order %s is %s \" % ( orders [ i ], pf )) if i < 4 : assert np . isclose ( pf , orders [ i ], atol = 0 , rtol =. 2 ) Convergence rate for order 2 is 1.7762872863258858 Convergence rate for order 4 is 4.196113606027213 Convergence rate for order 6 is 6.343794127096714 Convergence rate for order 8 is 7.630317382624955 Convergence rate for order 10 is 5.827482875857245","title":"Convergence analysis for the acoustic wave-equation"},{"location":"tutorials/accuracy/#verification","text":"We compute the error between the numerical and reference solutions for varying spatial discretization order and grid spacing. We also compare the time to solution to the error for these parameters. # Discretization order orders = ( 2 , 4 , 6 , 8 , 10 ) norder = len ( orders ) # Number of time steps nt = 1501 # Time axis dt = 0.1 t0 = 0. tn = dt * ( nt - 1 ) time = np . linspace ( t0 , tn , nt ) print ( \"t0, tn, dt, nt; %.4f %.4f %.4f %d \" % ( t0 , tn , dt , nt )) # Source peak frequency in KHz f0 = . 09 t0, tn, dt, nt; 0.0000 150.0000 0.1000 1501 # Domain sizes and gird spacing shapes = (( 201 , 2.0 ), ( 161 , 2.5 ), ( 101 , 4.0 )) dx = [ 2.0 , 2.5 , 4.0 ] nshapes = len ( shapes ) # Fine grid model c0 = 1.5 model = ModelBench ( vp = c0 , origin = ( 0. , 0. ), spacing = ( . 5 , . 5 ), bcs = \"damp\" , shape = ( 801 , 801 ), space_order = 20 , nbl = 40 , dtype = np . float32 ) # Source and receiver geometries src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = 200. # Single receiver offset 100 m from source rec_coordinates = np . empty (( 1 , 2 )) rec_coordinates [:, :] = 260. print ( \"The computational Grid has ( %s , %s ) grid points \" \"and a physical extent of ( %s m, %s m)\" % ( * model . grid . shape , * model . grid . extent )) print ( \"Source is at the center with coordinates ( %s m, %s m)\" % tuple ( src_coordinates [ 0 ])) print ( \"Receiver (single receiver) is located at ( %s m, %s m) \" % tuple ( rec_coordinates [ 0 ])) # Note: gets time sampling from model.critical_dt geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 = t0 , tn = tn , src_type = 'Ricker' , f0 = f0 , t0w = 1.5 / f0 ) The computational Grid has (881, 881) grid points and a physical extent of (440.0m, 440.0m) Source is at the center with coordinates (200.0m, 200.0m) Receiver (single receiver) is located at (260.0m, 260.0m)","title":"Verification"},{"location":"tutorials/accuracy/#reference-solution-for-numerical-convergence","text":"solver = AcousticWaveSolver ( model , geometry , kernel = 'OT2' , space_order = 8 ) ref_rec , ref_u , _ = solver . forward ()","title":"Reference solution for numerical convergence"},{"location":"tutorials/accuracy/#analytical-solution-for-comparison-with-the-reference-numerical-solution","text":"The analytical solution of the 2D acoustic wave-equation with a source pulse is defined as: \\begin{aligned} u_s(r, t) &= \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} \\{ -i \\pi H_0^{(2)}\\left(k r \\right) q(\\omega) e^{i\\omega t} d\\omega\\}\\\\[10pt] r &= \\sqrt{(x - x_{src})^2+(y - y_{src})^2} \\end{aligned} \\begin{aligned} u_s(r, t) &= \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} \\{ -i \\pi H_0^{(2)}\\left(k r \\right) q(\\omega) e^{i\\omega t} d\\omega\\}\\\\[10pt] r &= \\sqrt{(x - x_{src})^2+(y - y_{src})^2} \\end{aligned} where H_0^{(2)} H_0^{(2)} is the Hankel function of the second kind, F(\\omega) F(\\omega) is the Fourier spectrum of the source time function at angular frequencies \\omega \\omega and k = \\frac{\\omega}{v} k = \\frac{\\omega}{v} is the wavenumber. We look at the analytical and numerical solution at a single grid point. We ensure that this grid point is on-the-grid for all discretizations analyised in the further verification. # Source and receiver coordinates sx , sz = src_coordinates [ 0 , :] rx , rz = rec_coordinates [ 0 , :] # Define a Ricker wavelet shifted to zero lag for the Fourier transform def ricker ( f , T , dt , t0 ): t = np . linspace ( - t0 , T - t0 , int ( T / dt )) tt = ( np . pi ** 2 ) * ( f ** 2 ) * ( t ** 2 ) y = ( 1.0 - 2.0 * tt ) * np . exp ( - tt ) return y def analytical ( nt , model , time , ** kwargs ): dt = kwargs . get ( 'dt' , model . critical_dt ) # Fourier constants nf = int ( nt / 2 + 1 ) fnyq = 1. / ( 2 * dt ) df = 1.0 / time [ - 1 ] faxis = df * np . arange ( nf ) wavelet = ricker ( f0 , time [ - 1 ], dt , 1.5 / f0 ) # Take the Fourier transform of the source time-function R = np . fft . fft ( wavelet ) R = R [ 0 : nf ] nf = len ( R ) # Compute the Hankel function and multiply by the source spectrum U_a = np . zeros (( nf ), dtype = complex ) for a in range ( 1 , nf - 1 ): k = 2 * np . pi * faxis [ a ] / c0 tmp = k * np . sqrt ((( rx - sx )) ** 2 + (( rz - sz )) ** 2 ) U_a [ a ] = - 1 j * np . pi * hankel2 ( 0.0 , tmp ) * R [ a ] # Do inverse fft on 0:dt:T and you have analytical solution U_t = 1.0 / ( 2.0 * np . pi ) * np . real ( np . fft . ifft ( U_a [:], nt )) # The analytic solution needs be scaled by dx^2 to convert to pressure return np . real ( U_t ) * ( model . spacing [ 0 ] ** 2 ) time1 = np . linspace ( 0.0 , 3000. , 30001 ) U_t = analytical ( 30001 , model , time1 , dt = time1 [ 1 ] - time1 [ 0 ]) U_t = U_t [ 0 : 1501 ] #NBVAL_IGNORE_OUTPUT print ( \"Numerical data min,max,abs; %+.6e %+.6e %+.6e \" % ( np . min ( ref_rec . data ), np . max ( ref_rec . data ), np . max ( np . abs ( ref_rec . data )) )) print ( \"Analytic data min,max,abs; %+.6e %+.6e %+.6e \" % ( np . min ( U_t ), np . max ( U_t ), ( np . max ( np . abs ( U_t ))))) Numerical data min,max,abs; -5.349830e-03 +8.529913e-03 +8.529913e-03 Analytic data min,max,abs; -5.322232e-03 +8.543911e-03 +8.543911e-03 # Plot wavefield and source/rec position plt . figure ( figsize = ( 8 , 8 )) amax = np . max ( np . abs ( ref_u . data [ 1 ,:,:])) plt . imshow ( ref_u . data [ 1 ,:,:], vmin =- 1.0 * amax , vmax =+ 1.0 * amax , cmap = \"seismic\" ) plt . plot ( 2 * sx + 40 , 2 * sz + 40 , 'r*' , markersize = 11 , label = 'source' ) # plot position of the source in model, add nbl for correct position plt . plot ( 2 * rx + 40 , 2 * rz + 40 , 'k^' , markersize = 8 , label = 'receiver' ) # plot position of the receiver in model, add nbl for correct position plt . legend () plt . xlabel ( 'x position (m)' ) plt . ylabel ( 'z position (m)' ) plt . savefig ( 'wavefieldperf.pdf' ) # Plot trace plt . figure ( figsize = ( 12 , 8 )) plt . subplot ( 2 , 1 , 1 ) plt . plot ( time , ref_rec . data [:, 0 ], '-b' , label = 'numerical' ) plt . plot ( time , U_t [:], '--r' , label = 'analytical' ) plt . xlim ([ 0 , 150 ]) plt . ylim ([ 1.15 * np . min ( U_t [:]), 1.15 * np . max ( U_t [:])]) plt . xlabel ( 'time (ms)' ) plt . ylabel ( 'amplitude' ) plt . legend () plt . subplot ( 2 , 1 , 2 ) plt . plot ( time , 100 * ( ref_rec . data [:, 0 ] - U_t [:]), '-b' , label = 'difference x100' ) plt . xlim ([ 0 , 150 ]) plt . ylim ([ 1.15 * np . min ( U_t [:]), 1.15 * np . max ( U_t [:])]) plt . xlabel ( 'time (ms)' ) plt . ylabel ( 'amplitude x100' ) plt . legend () plt . savefig ( 'ref.pdf' ) plt . show () #NBVAL_IGNORE_OUTPUT error_time = np . zeros ( 5 ) error_time [ 0 ] = np . linalg . norm ( U_t [: - 1 ] - ref_rec . data [: - 1 , 0 ], 2 ) / np . sqrt ( nt ) errors_plot = [( time , U_t [: - 1 ] - ref_rec . data [: - 1 , 0 ])] print ( error_time [ 0 ]) 1.1274823771092997e-05","title":"Analytical solution for comparison with the reference numerical solution"},{"location":"tutorials/accuracy/#convergence-in-time","text":"We first show the convergence of the time discretization for a fix high-order spatial discretization (20 th order). After we show that the time discretization converges in O(dt^2) O(dt^2) and therefore only contains the error in time, we will take the numerical solution for dt=.1ms as a reference for the spatial discretization analysis. #NBVAL_IGNORE_OUTPUT dt = [ 0.1000 , 0.0800 , 0.0750 , 0.0625 , 0.0500 ] nnt = ( np . divide ( 150.0 , dt ) + 1 ) . astype ( int ) for i in range ( 1 , 5 ): # Time axis t0 = 0.0 tn = 150.0 time = np . linspace ( t0 , tn , nnt [ i ]) # Source geometry src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = 200. # Single receiver offset 100 m from source rec_coordinates = np . empty (( 1 , 2 )) rec_coordinates [:, :] = 260. geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 = t0 , tn = tn , src_type = 'Ricker' , f0 = f0 , t0w = 1.5 / f0 ) # Note: incorrect data size will be generated here due to AcquisitionGeometry bug ... # temporarily fixed below by resizing the output from the solver geometry . resample ( dt [ i ]) print ( \"geometry.time_axes; \" , geometry . time_axis ) solver = AcousticWaveSolver ( model , geometry , time_order = 2 , space_order = 8 ) ref_rec1 , ref_u1 , _ = solver . forward ( dt = dt [ i ]) ref_rec1_data = ref_rec1 . data [ 0 : nnt [ i ],:] time1 = np . linspace ( 0.0 , 3000. , 20 * ( nnt [ i ] - 1 ) + 1 ) U_t1 = analytical ( 20 * ( nnt [ i ] - 1 ) + 1 , model , time1 , dt = time1 [ 1 ] - time1 [ 0 ]) U_t1 = U_t1 [ 0 : nnt [ i ]] error_time [ i ] = np . linalg . norm ( U_t1 [: - 1 ] - ref_rec1_data [: - 1 , 0 ], 2 ) / np . sqrt ( nnt [ i ] - 1 ) ratio_d = dt [ i - 1 ] / dt [ i ] if i > 0 else 1.0 ratio_e = error_time [ i - 1 ] / error_time [ i ] if i > 0 else 1.0 print ( \"error for dt= %.4f is %12.6e -- ratio dt^2,ratio err; %12.6f %12.6f \\n \" % ( dt [ i ], error_time [ i ], ratio_d ** 2 , ratio_e )) errors_plot . append (( geometry . time_axis . time_values , U_t1 [: - 1 ] - ref_rec1_data [: - 1 , 0 ])) geometry.time_axes; TimeAxis: start=0, stop=150.08, step=0.08, num=1877 error for dt=0.0800 is 7.403730e-06 -- ratio dt^2,ratio err; 1.562500 1.522857 geometry.time_axes; TimeAxis: start=0, stop=150, step=0.075, num=2001 error for dt=0.0750 is 6.557951e-06 -- ratio dt^2,ratio err; 1.137778 1.128970 geometry.time_axes; TimeAxis: start=0, stop=150, step=0.0625, num=2401 error for dt=0.0625 is 4.647428e-06 -- ratio dt^2,ratio err; 1.440000 1.411093 geometry.time_axes; TimeAxis: start=0, stop=150, step=0.05, num=3001 error for dt=0.0500 is 3.026210e-06 -- ratio dt^2,ratio err; 1.562500 1.535726 plt . figure ( figsize = ( 20 , 10 )) theory = [ t ** 2 for t in dt ] theory = [ error_time [ 0 ] * th / theory [ 0 ] for th in theory ] plt . loglog ([ t for t in dt ], error_time , '-ob' , label = ( 'Numerical' ), linewidth = 4 , markersize = 10 ) plt . loglog ([ t for t in dt ], theory , '-^r' , label = ( 'Theory (2nd order)' ), linewidth = 4 , markersize = 10 ) for x , y , a in zip ([ t for t in dt ], theory , [( 'dt = %s ms' % ( t )) for t in dt ]): plt . annotate ( a , xy = ( x , y ), xytext = ( 4 , 2 ), textcoords = 'offset points' , size = 20 , horizontalalignment = 'left' , verticalalignment = 'top' ) plt . xlabel ( \"Time-step $dt$ (ms)\" , fontsize = 20 ) plt . ylabel ( \"$|| u_ {num} - u_ {ana} ||_2$\" , fontsize = 20 ) plt . tick_params ( axis = 'both' , which = 'both' , labelsize = 20 ) plt . tight_layout () plt . xlim (( 0.05 , 0.1 )) plt . legend ( fontsize = 20 , ncol = 4 , fancybox = True , loc = 'best' ) plt . savefig ( \"TimeConvergence.pdf\" , format = 'pdf' , facecolor = 'white' , orientation = 'landscape' , bbox_inches = 'tight' ) plt . show () #NBVAL_IGNORE_OUTPUT stylel = ( '--y' , '--b' , '--r' , '--g' , '--c' ) start_t = lambda dt : int ( 50 / dt ) end_t = lambda dt : int ( 100 / dt ) plt . figure ( figsize = ( 20 , 10 )) for i , dti in enumerate ( dt ): timei , erri = errors_plot [ i ] s , e = start_t ( dti ), end_t ( dti ) if i == 0 : plt . plot ( timei [ s : e ], U_t [ s : e ], 'k' , label = 'analytical' , linewidth = 2 ) plt . plot ( timei [ s : e ], 100 * erri [ s : e ], stylel [ i ], label = \"100 x error dt= %s ms\" % dti , linewidth = 2 ) plt . xlim ([ 50 , 100 ]) plt . xlabel ( \"Time (ms)\" , fontsize = 20 ) plt . legend ( fontsize = 20 ) plt . show () #NBVAL_IGNORE_OUTPUT pf = np . polyfit ( np . log ([ t for t in dt ]), np . log ( error_time ), deg = 1 ) print ( \"Convergence rate in time is: %.4f \" % pf [ 0 ]) assert np . isclose ( pf [ 0 ], 1.9 , atol = 0 , rtol =. 1 ) Convergence rate in time is: 1.8966","title":"Convergence in time"},{"location":"tutorials/accuracy/#convergence-in-space","text":"We have a correct reference solution we can use for space discretization analysis #NBVAL_IGNORE_OUTPUT errorl2 = np . zeros (( norder , nshapes )) timing = np . zeros (( norder , nshapes )) set_log_level ( \"ERROR\" ) ind_o = - 1 for spc in orders : ind_o += 1 ind_spc = - 1 for nn , h in shapes : ind_spc += 1 time = np . linspace ( 0. , 150. , nt ) model_space = ModelBench ( vp = c0 , origin = ( 0. , 0. ), spacing = ( h , h ), bcs = \"damp\" , shape = ( nn , nn ), space_order = spc , nbl = 40 , dtype = np . float32 ) # Source geometry src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = 200. # Single receiver offset 100 m from source rec_coordinates = np . empty (( 1 , 2 )) rec_coordinates [:, :] = 260. geometry = AcquisitionGeometry ( model_space , rec_coordinates , src_coordinates , t0 = t0 , tn = tn , src_type = 'Ricker' , f0 = f0 , t0w = 1.5 / f0 ) solver = AcousticWaveSolver ( model_space , geometry , time_order = 2 , space_order = spc ) loc_rec , loc_u , summary = solver . forward () # Note: we need to correct for fixed spacing pressure corrections in both analytic # (run at the old model spacing) and numerical (run at the new model spacing) solutions c_ana = 1 / model . spacing [ 0 ] ** 2 c_num = 1 / model_space . spacing [ 0 ] ** 2 # Compare to reference solution # Note: we need to normalize by the factor of grid spacing squared errorl2 [ ind_o , ind_spc ] = np . linalg . norm ( loc_rec . data [: - 1 , 0 ] * c_num - U_t [: - 1 ] * c_ana , 2 ) / np . sqrt ( U_t . shape [ 0 ] - 1 ) timing [ ind_o , ind_spc ] = np . max ([ v for _ , v in summary . timings . items ()]) print ( \"starting space order %s with ( %s , %s ) grid points the error is %s for %s seconds runtime\" % ( spc , nn , nn , errorl2 [ ind_o , ind_spc ], timing [ ind_o , ind_spc ])) starting space order 2 with (201, 201) grid points the error is 0.00376890390735257 for 0.11462100000000232 seconds runtime starting space order 2 with (161, 161) grid points the error is 0.005813084671822352 for 0.21845700000000504 seconds runtime starting space order 2 with (101, 101) grid points the error is 0.013011803756815122 for 0.032794999999999366 seconds runtime starting space order 4 with (201, 201) grid points the error is 0.0003403506132631831 for 0.0771300000000017 seconds runtime starting space order 4 with (161, 161) grid points the error is 0.0009417872279623022 for 0.07411399999999989 seconds runtime starting space order 4 with (101, 101) grid points the error is 0.006347337804825049 for 0.041079000000000594 seconds runtime starting space order 6 with (201, 201) grid points the error is 4.502665029531472e-05 for 0.08156900000000102 seconds runtime starting space order 6 with (161, 161) grid points the error is 0.00020691319261459238 for 0.07217499999999948 seconds runtime starting space order 6 with (101, 101) grid points the error is 0.0037431036246854867 for 0.04163999999999989 seconds runtime starting space order 8 with (201, 201) grid points the error is 4.1027806557032715e-05 for 0.10310699999999935 seconds runtime starting space order 8 with (161, 161) grid points the error is 7.128947664631205e-05 for 0.27055700000000116 seconds runtime starting space order 8 with (101, 101) grid points the error is 0.002573508922203025 for 0.04638000000000103 seconds runtime starting space order 10 with (201, 201) grid points the error is 4.4153663464842855e-05 for 0.1793579999999967 seconds runtime starting space order 10 with (161, 161) grid points the error is 4.9407728678141816e-05 for 0.21400200000000336 seconds runtime starting space order 10 with (101, 101) grid points the error is 0.0019485859969163928 for 0.08266899999999956 seconds runtime stylel = ( '-^k' , '-^b' , '-^r' , '-^g' , '-^c' ) plt . figure ( figsize = ( 20 , 10 )) for i in range ( 0 , 5 ): plt . loglog ( errorl2 [ i , :], timing [ i , :], stylel [ i ], label = ( 'order %s ' % orders [ i ]), linewidth = 4 , markersize = 10 ) for x , y , a in zip ( errorl2 [ i , :], timing [ i , :], [( 'dx = %s m' % ( sc )) for sc in dx ]): plt . annotate ( a , xy = ( x , y ), xytext = ( 4 , 2 ), textcoords = 'offset points' , size = 20 ) plt . xlabel ( \"$|| u_ {num} - u_ {ref} ||_ {inf} $\" , fontsize = 20 ) plt . ylabel ( \"Runtime (sec)\" , fontsize = 20 ) plt . tick_params ( axis = 'both' , which = 'both' , labelsize = 20 ) plt . tight_layout () plt . legend ( fontsize = 20 , ncol = 3 , fancybox = True , loc = 'lower left' ) plt . savefig ( \"TimeAccuracy.pdf\" , format = 'pdf' , facecolor = 'white' , orientation = 'landscape' , bbox_inches = 'tight' ) plt . show () stylel = ( '-^k' , '-^b' , '-^r' , '-^g' , '-^c' ) style2 = ( '--k' , '--b' , '--r' , '--g' , '--c' ) plt . figure ( figsize = ( 20 , 10 )) for i in range ( 0 , 5 ): theory = [ k ** ( orders [ i ]) for k in dx ] theory = [ errorl2 [ i , 2 ] * th / theory [ 2 ] for th in theory ] plt . loglog ([ sc for sc in dx ], errorl2 [ i , :], stylel [ i ], label = ( 'Numerical order %s ' % orders [ i ]), linewidth = 4 , markersize = 10 ) plt . loglog ([ sc for sc in dx ], theory , style2 [ i ], label = ( 'Theory order %s ' % orders [ i ]), linewidth = 4 , markersize = 10 ) plt . xlabel ( \"Grid spacing $dx$ (m)\" , fontsize = 20 ) plt . ylabel ( \"$||u_ {num} - u_ {ref} ||_ {inf} $\" , fontsize = 20 ) plt . tick_params ( axis = 'both' , which = 'both' , labelsize = 20 ) plt . tight_layout () plt . legend ( fontsize = 20 , ncol = 2 , fancybox = True , loc = 'lower right' ) # plt.xlim((2.0, 4.0)) plt . savefig ( \"Convergence.pdf\" , format = 'pdf' , facecolor = 'white' , orientation = 'landscape' , bbox_inches = 'tight' ) plt . show () #NBVAL_IGNORE_OUTPUT for i in range ( 5 ): pf = np . polyfit ( np . log ([ sc for sc in dx ]), np . log ( errorl2 [ i , :]), deg = 1 )[ 0 ] if i == 3 : pf = np . polyfit ( np . log ([ sc for sc in dx ][ 1 :]), np . log ( errorl2 [ i , 1 :]), deg = 1 )[ 0 ] print ( \"Convergence rate for order %s is %s \" % ( orders [ i ], pf )) if i < 4 : assert np . isclose ( pf , orders [ i ], atol = 0 , rtol =. 2 ) Convergence rate for order 2 is 1.7762872863258858 Convergence rate for order 4 is 4.196113606027213 Convergence rate for order 6 is 6.343794127096714 Convergence rate for order 8 is 7.630317382624955 Convergence rate for order 10 is 5.827482875857245","title":"Convergence in space"}]}